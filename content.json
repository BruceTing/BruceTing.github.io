{"meta":{"title":"DuoDuo","subtitle":null,"description":"好少年光芒万丈","author":"duoduo","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-10-19T13:56:24.456Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[爱思考のduoduo] 与&nbsp; duoduo&nbsp; （ 真情告白 ） 对话中... bot_ui_ini()","keywords":null},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-10-19T13:56:24.456Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-10-19T13:56:24.456Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-10-19T13:56:24.456Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-10-19T13:56:24.457Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-10-19T13:56:24.457Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-10-19T13:56:24.457Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"MyBatis源码分析之SqlSessionFactory","slug":"tech-mybatis-sqlSessionFactory","date":"2019-11-03T07:30:10.000Z","updated":"2019-11-03T15:03:05.165Z","comments":true,"path":"2019/11/03/tech-mybatis-sqlSessionFactory/","link":"","permalink":"/2019/11/03/tech-mybatis-sqlSessionFactory/","excerpt":"","text":"构造SqlSessionFactory的主流程学习过基本用法之后呢，接着来分析分析源码，首先来看看其中的SqlSessionFactory，我们把之前的MyBatisTest粘一下： public class MyBatisTest { public static void main(String[] args) throws Exception { String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { UserDAO mapper = session.getMapper(UserDAO.class); User user = mapper.selectUser(1L); System.out.println(user.toString()); } } } 先来看看这行代码干了啥： SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); org.apache.ibatis.session.SqlSessionFactoryBuilder#build(java.io.InputStream) 开始构造SqlSessionFactory： org.apache.ibatis.builder.xml.XMLConfigBuilder#XMLConfigBuilder(java.io.InputStream, java.lang.String, java.util.Properties) 配置文件、环境、解析器初始化 org.apache.ibatis.builder.xml.XMLMapperEntityResolver 构造mybatis dtd文件解析器 org.apache.ibatis.parsing.XPathParser#XPathParser(java.io.InputStream, boolean, java.util.Properties, org.xml.sax.EntityResolver) 初始化文件解析器XPathParser，根据配置文件，构造文件的Document对象 org.apache.ibatis.session.Configuration 注册通用别名，比如：JDBC -&gt; JdbcTransactionFactory.class，LOG4J -&gt; Log4jImpl.class等，这个是非常重要非常重要非常重要的类，我们所有的配置以及操作都和它相关 public Configuration() { // JDBC typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class); typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class); // JNDI typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class); // CACHE typeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;, PerpetualCache.class); typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class); typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class); typeAliasRegistry.registerAlias(&quot;SOFT&quot;, SoftCache.class); typeAliasRegistry.registerAlias(&quot;WEAK&quot;, WeakCache.class); // DB_VENDOR typeAliasRegistry.registerAlias(&quot;DB_VENDOR&quot;, VendorDatabaseIdProvider.class); // XML typeAliasRegistry.registerAlias(&quot;XML&quot;, XMLLanguageDriver.class); typeAliasRegistry.registerAlias(&quot;RAW&quot;, RawLanguageDriver.class); // LOG typeAliasRegistry.registerAlias(&quot;SLF4J&quot;, Slf4jImpl.class); typeAliasRegistry.registerAlias(&quot;COMMONS_LOGGING&quot;, JakartaCommonsLoggingImpl.class); typeAliasRegistry.registerAlias(&quot;LOG4J&quot;, Log4jImpl.class); typeAliasRegistry.registerAlias(&quot;LOG4J2&quot;, Log4j2Impl.class); typeAliasRegistry.registerAlias(&quot;JDK_LOGGING&quot;, Jdk14LoggingImpl.class); typeAliasRegistry.registerAlias(&quot;STDOUT_LOGGING&quot;, StdOutImpl.class); typeAliasRegistry.registerAlias(&quot;NO_LOGGING&quot;, NoLoggingImpl.class); // CGLIB typeAliasRegistry.registerAlias(&quot;CGLIB&quot;, CglibProxyFactory.class); typeAliasRegistry.registerAlias(&quot;JAVASSIST&quot;, JavassistProxyFactory.class); // LANGUAGE languageRegistry.setDefaultDriverClass(XMLLanguageDriver.class); languageRegistry.register(RawLanguageDriver.class); } org.apache.ibatis.builder.xml.XMLConfigBuilder#parse 配置文件解析标识，避免重复解析 org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration 解析配置文件的核心代码： private void parseConfiguration(XNode root) { try { //issue #117 read properties first propertiesElement(root.evalNode(&quot;properties&quot;)); Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;)); loadCustomVfs(settings); loadCustomLogImpl(settings); typeAliasesElement(root.evalNode(&quot;typeAliases&quot;)); pluginElement(root.evalNode(&quot;plugins&quot;)); objectFactoryElement(root.evalNode(&quot;objectFactory&quot;)); objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;)); reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;)); settingsElement(settings); // read it after objectFactory and objectWrapperFactory issue #631 environmentsElement(root.evalNode(&quot;environments&quot;)); // 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有的不带 // databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有， // 则不带的会被忽略。 databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;)); typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;)); mapperElement(root.evalNode(&quot;mappers&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e); } } org.apache.ibatis.session.SqlSessionFactoryBuilder#build(org.apache.ibatis.session.Configuration) 根据解析出来的配置构造SqlSessionFactory： public SqlSessionFactory build(Configuration config) { return new DefaultSqlSessionFactory(config); } 通过上面的代码分析知道，我们配置的mybatis-config.xml配置文件，正是在new SqlSessionFactoryBuilder().build(inputStream)方法下进行解析的，主要来看看typeAliases、plugins、environments、typeHandlers、mappers配置怎么解析的，解析到哪里去了。 typeAliases解析直接上源码：org.apache.ibatis.builder.xml.XMLConfigBuilder#typeAliasesElement： private void typeAliasesElement(XNode parent) { if (parent != null) { // 将配置的数据注册到TypeAliasRegistry的typeAliases属性中： // private final Map&lt;String, Class&lt;?&gt;&gt; typeAliases = new HashMap&lt;&gt;(); // key: alise value: type // 如果alise为null，则key为：type.getSimpleName() for (XNode child : parent.getChildren()) { if (&quot;package&quot;.equals(child.getName())) { String typeAliasPackage = child.getStringAttribute(&quot;name&quot;); configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage); } else { String alias = child.getStringAttribute(&quot;alias&quot;); String type = child.getStringAttribute(&quot;type&quot;); try { Class&lt;?&gt; clazz = Resources.classForName(type); if (alias == null) { typeAliasRegistry.registerAlias(clazz); } else { typeAliasRegistry.registerAlias(alias, clazz); } } catch (ClassNotFoundException e) { throw new BuilderException(&quot;Error registering typeAlias for &#39;&quot; + alias + &quot;&#39;. Cause: &quot; + e, e); } } } } } plugins解析直接上源码：org.apache.ibatis.builder.xml.XMLConfigBuilder#pluginElement： private void pluginElement(XNode parent) throws Exception { if (parent != null) { for (XNode child : parent.getChildren()) { String interceptor = child.getStringAttribute(&quot;interceptor&quot;); Properties properties = child.getChildrenAsProperties(); Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance(); interceptorInstance.setProperties(properties); // 解析出每个plugin，反射实例化后，注册到configuration的interceptorChain属性中， // 其实是放到interceptorChain的list集合org.apache.ibatis.plugin.InterceptorChain#interceptors中： // private final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); // 每个插件处理器都实现了Interceptor接口，我们可以实现Interceptor接口，实现自定义的插件处理器 configuration.addInterceptor(interceptorInstance); } } } environments解析先看看源码org.apache.ibatis.builder.xml.XMLConfigBuilder#environmentsElement： private void environmentsElement(XNode context) throws Exception { if (context != null) { // 我们在调用new SqlSessionFactoryBuilder().build(inputStream)的时候，只是把配置文件传进去，没有传数据源ID或其他的属性配置，所以这个地方会去获取默认的数据源配置，刚好我们在配置的时候指定了default，通过传入数据源ID，可以达到使用多数据源的目的。注意：在使用默认环境数据源时，一定要保证默认的环境 ID 要匹配其中一个环境 ID。 if (environment == null) { environment = context.getStringAttribute(&quot;default&quot;); } for (XNode child : context.getChildren()) { String id = child.getStringAttribute(&quot;id&quot;); // 这个地方就是环境ID校验了 if (isSpecifiedEnvironment(id)) { TransactionFactory txFactory = transactionManagerElement(child.evalNode(&quot;transactionManager&quot;)); DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;)); DataSource dataSource = dsFactory.getDataSource(); Environment.Builder environmentBuilder = new Environment.Builder(id) .transactionFactory(txFactory) .dataSource(dataSource); configuration.setEnvironment(environmentBuilder.build()); } } } } 来看看环境ID是怎么校验的，很好理解： private boolean isSpecifiedEnvironment(String id) { if (environment == null) { throw new BuilderException(&quot;No environment specified.&quot;); } else if (id == null) { throw new BuilderException(&quot;Environment requires an id attribute.&quot;); } else if (environment.equals(id)) { return true; } return false; } 事物TransactionFactory解析 private TransactionFactory transactionManagerElement(XNode context) throws Exception { if (context != null) { // 事物管理器类型，有两种[JDBC|MANAGED]： // JDBC：直接使用 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务的作用域。 // MANAGED：这个配置几乎没做什么，既不提交也不会滚，让容器自己去管理，默认情况下，它只会关闭连接，然而并不是所有的容器允许这么做，通常需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为，列入： // &lt;transactionManager type=&quot;MANAGED&quot;&gt; // &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt; // &lt;/transactionManager&gt; // 这两种事务管理器类型都不需要设置任何属性。它们其实是类型别名，换句话说，你可以使用 TransactionFactory 接口的实现类的完全限定名或类型别名代替它们。 // 属性配置，如果使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。 String type = context.getStringAttribute(&quot;type&quot;); // 属性配置 Properties props = context.getChildrenAsProperties(); // 反射获取TransactionFactory的实例 TransactionFactory factory = (TransactionFactory) resolveClass(type).getDeclaredConstructor().newInstance(); // 属性设置 factory.setProperties(props); return factory; } throw new BuilderException(&quot;Environment declaration requires a TransactionFactory.&quot;); } 来看看resolveClass(type)里都干了啥 protected &lt;T&gt; Class&lt;? extends T&gt; resolveClass(String alias) { if (alias == null) { return null; } try { return resolveAlias(alias); } catch (Exception e) { throw new BuilderException(&quot;Error resolving class. Cause: &quot; + e, e); } } protected &lt;T&gt; Class&lt;? extends T&gt; resolveAlias(String alias) { return typeAliasRegistry.resolveAlias(alias); } org.apache.ibatis.type.TypeAliasRegistry#resolveAlias: public &lt;T&gt; Class&lt;T&gt; resolveAlias(String string) { try { if (string == null) { return null; } // issue #748 String key = string.toLowerCase(Locale.ENGLISH); Class&lt;T&gt; value; if (typeAliases.containsKey(key)) { value = (Class&lt;T&gt;) typeAliases.get(key); } else { value = (Class&lt;T&gt;) Resources.classForName(string); } return value; } catch (ClassNotFoundException e) { throw new TypeException(&quot;Could not resolve type alias &#39;&quot; + string + &quot;&#39;. Cause: &quot; + e, e); } } 这个就是通过注册的别名去获取Class，通过JDBC获取到事物管理器Class：JdbcTransactionFactory.class，然后反射拿到它的实例，也就是TransactionFactory啦。 DataSource解析这个地方其实就是和TransactionFactory解析一样的啦： private DataSourceFactory dataSourceElement(XNode context) throws Exception { if (context != null) { String type = context.getStringAttribute(&quot;type&quot;); Properties props = context.getChildrenAsProperties(); DataSourceFactory factory = (DataSourceFactory) resolveClass(type).getDeclaredConstructor().newInstance(); factory.setProperties(props); return factory; } throw new BuilderException(&quot;Environment declaration requires a DataSourceFactory.&quot;); } 最后通过反射拿到PooledDataSourceFactory实例。来看看getDeclaredConstructor().newInstance()构造器里干了啥： public class PooledDataSourceFactory extends UnpooledDataSourceFactory { public PooledDataSourceFactory() { this.dataSource = new PooledDataSource(); } } PooledDataSourceFactory继承UnpooledDataSourceFactory，UnpooledDataSourceFactory实现DataSourceFactory。new PooledDataSource()里干了啥： public PooledDataSource() { dataSource = new UnpooledDataSource(); } PooledDataSource、UnpooledDataSource实现了DataSource，所以看到的是PooledDataSource，其实使用的是UnpooledDataSource。看到的PooledDataSourceFactory，其实使用的UnpooledDataSourceFactory，也就是说干的事情都委托给了UnpooledDataSource和UnpooledDataSourceFactory。所以最终获取到的DataSource是UnpooledDataSource。 构建Environment，配置ConfigurationenvironmentsElement(XNode context)方法中最后的几行代码就是把获取到的TransactionFactory、DataSource实例扔给Environment.Builder构造出Environment对象，然后赋值给Configuration的environment属性： public Environment build() { return new Environment(this.id, this.transactionFactory, this.dataSource); } 至此，Environment解析完毕。 typeHandlers解析先看看源码org.apache.ibatis.builder.xml.XMLConfigBuilder#typeHandlerElement： private void typeHandlerElement(XNode parent) { if (parent != null) { // 解析出配置的typeHandler，并注册到configuration的typeHandlerRegistry中 // 每个类型处理器均实现了TypeHandler接口，我们可以实现TypeHandler接口，自定义自己的类型解析器 for (XNode child : parent.getChildren()) { if (&quot;package&quot;.equals(child.getName())) { String typeHandlerPackage = child.getStringAttribute(&quot;name&quot;); typeHandlerRegistry.register(typeHandlerPackage); } else { String javaTypeName = child.getStringAttribute(&quot;javaType&quot;); String jdbcTypeName = child.getStringAttribute(&quot;jdbcType&quot;); String handlerTypeName = child.getStringAttribute(&quot;handler&quot;); Class&lt;?&gt; javaTypeClass = resolveClass(javaTypeName); JdbcType jdbcType = resolveJdbcType(jdbcTypeName); Class&lt;?&gt; typeHandlerClass = resolveClass(handlerTypeName); if (javaTypeClass != null) { if (jdbcType == null) { typeHandlerRegistry.register(javaTypeClass, typeHandlerClass); } else { typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass); } } else { typeHandlerRegistry.register(typeHandlerClass); } } } } } mappers解析先看看源码org.apache.ibatis.builder.xml.XMLConfigBuilder#mapperElement： private void mapperElement(XNode parent) throws Exception { if (parent != null) { for (XNode child : parent.getChildren()) { // 解析配置了扫描 mappers 的package节点 if (&quot;package&quot;.equals(child.getName())) { String mapperPackage = child.getStringAttribute(&quot;name&quot;); configuration.addMappers(mapperPackage); } else { /** * 解析配置了扫描 mappers 的 mapper 节点 * Mapper的配置方式有三种，有且只能配置其中一种，每种都可以配置多个： * 1、使用相对于类路径的资源引用，例如： * &lt;mappers&gt; * &lt;mapper resource=&quot;org/mybatis/builder/UserMapper.xml&quot;/&gt; * .... * &lt;/mappers&gt; * * 2、使用完全限定资源定位符（URL），例如： * &lt;mappers&gt; * &lt;mapper url=&quot;file:///var/mappers/UserMapper.xml&quot;/&gt; * .... * &lt;/mappers&gt; * * 3、使用映射器接口实现类的完全限定类名，例如： * &lt;mappers&gt; * &lt;mapper class=&quot;org.mybatis.builder.UserMapper&quot;/&gt; * .... * &lt;/mappers&gt; */ String resource = child.getStringAttribute(&quot;resource&quot;); String url = child.getStringAttribute(&quot;url&quot;); String mapperClass = child.getStringAttribute(&quot;class&quot;); if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) { // Mapper方式解析 ErrorContext.instance().resource(resource); InputStream inputStream = Resources.getResourceAsStream(resource); XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); } else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) { // URL方式解析 ErrorContext.instance().resource(url); InputStream inputStream = Resources.getUrlAsStream(url); XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments()); mapperParser.parse(); } else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) { // 完全限定类方式解析 Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass); configuration.addMapper(mapperInterface); } else { throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;); } } } } } Package方式解析看看configuration.addMappers(mapperPackage)这行代码里面干了啥： public void addMappers(String packageName) { mapperRegistry.addMappers(packageName); } 原来是把扫描出的Mapper接口注册到mapperRegistry中，接着来看： /** * @since 3.2.2 */ public void addMappers(String packageName, Class&lt;?&gt; superType) { ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;(); resolverUtil.find(new ResolverUtil.IsA(superType), packageName); Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses(); for (Class&lt;?&gt; mapperClass : mapperSet) { addMapper(mapperClass); } } /** * @since 3.2.2 */ public void addMappers(String packageName) { addMappers(packageName, Object.class); } 后面调用addMappers(String packageName, Class&lt;?&gt; superType)方法并且指定检查的超类是Object.class，该超类对象通过new ResolverUtil.IsA(superType)赋值给IsA implements Test类中的parent属性，用作后面的类型检查。调用ResolverUtil实例的find方法，将匹配的类的Class对象放到ResolverUtil实例的matches集合中： public ResolverUtil&lt;T&gt; find(Test test, String packageName) { String path = getPackagePath(packageName); try { List&lt;String&gt; children = VFS.getInstance().list(path); for (String child : children) { if (child.endsWith(&quot;.class&quot;)) { addIfMatching(test, child); } } } catch (IOException ioe) { log.error(&quot;Could not read package: &quot; + packageName, ioe); } return this; } protected void addIfMatching(Test test, String fqn) { try { String externalName = fqn.substring(0, fqn.indexOf(&#39;.&#39;)).replace(&#39;/&#39;, &#39;.&#39;); ClassLoader loader = getClassLoader(); if (log.isDebugEnabled()) { log.debug(&quot;Checking to see if class &quot; + externalName + &quot; matches criteria [&quot; + test + &quot;]&quot;); } Class&lt;?&gt; type = loader.loadClass(externalName); if (test.matches(type)) { matches.add((Class&lt;T&gt;) type); } } catch (Throwable t) { log.warn(&quot;Could not examine class &#39;&quot; + fqn + &quot;&#39;&quot; + &quot; due to a &quot; + t.getClass().getName() + &quot; with message: &quot; + t.getMessage()); } } 回到addMappers(String packageName, Class&lt;?&gt; superType)中，最终把匹配的类注册到org.apache.ibatis.binding.MapperRegistry#knownMappersMap集合中： public &lt;T&gt; void addMapper(Class&lt;T&gt; type) { if (type.isInterface()) { if (hasMapper(type)) { throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;); } boolean loadCompleted = false; try { knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type)); // It&#39;s important that the type is added before the parser is run // otherwise the binding may automatically be attempted by the // mapper parser. If the type is already known, it won&#39;t try. MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type); parser.parse(); loadCompleted = true; } finally { if (!loadCompleted) { knownMappers.remove(type); } } } } Mapper方式解析来看看new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments())里面干了啥： public XMLMapperBuilder(InputStream inputStream, Configuration configuration, String resource, Map&lt;String, XNode&gt; sqlFragments) { // 这个地方和解析 Configuration 时是差不多的 // 然后创建xxxMapper.xml的Document对象 this(new XPathParser(inputStream, true, configuration.getVariables(), new XMLMapperEntityResolver()), configuration, resource, sqlFragments); } private XMLMapperBuilder(XPathParser parser, Configuration configuration, String resource, Map&lt;String, XNode&gt; sqlFragments) { super(configuration); this.builderAssistant = new MapperBuilderAssistant(configuration, resource); this.parser = parser; this.sqlFragments = sqlFragments; this.resource = resource; } 因为XMLMapperBuilder extends BaseBuilder，所以看看super(configuration)里干了啥： public BaseBuilder(Configuration configuration) { this.configuration = configuration; this.typeAliasRegistry = this.configuration.getTypeAliasRegistry(); this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry(); } 从configuration里把typeAliasRegistry、typeHandlerRegistry拿出来赋值给BaseBuilder中的typeAliasRegistry、typeHandlerRegistry。MapperBuilderAssistant extends BaseBuilder，看看构造方法： public MapperBuilderAssistant(Configuration configuration, String resource) { // 这里的super和上面是一样的 super(configuration); ErrorContext.instance().resource(resource); this.resource = resource; } 最后拿到XMLMapperBuilder实例后，调用它的parse()方法： public void parse() { // 检查configuration的Set集合loadedResources中是否包含当前的resource if (!configuration.isResourceLoaded(resource)) { // 开始去解析Mapper，将最终的结果集存入configuration中 configurationElement(parser.evalNode(&quot;/mapper&quot;)); // 保存已解析过的mapper configuration.addLoadedResource(resource); // 将已加载过的Mapper的namespace注册到configuration的mapperRegistry属性中的 // knownMappers集合中： // private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;(); bindMapperForNamespace(); } // 将未完成解析的ResultMaps解析到configuration的resultMaps集合中 parsePendingResultMaps(); /** * private void parsePendingResultMaps() { * Collection&lt;ResultMapResolver&gt; incompleteResultMaps = configuration.getIncompleteResultMaps(); * synchronized (incompleteResultMaps) { * Iterator&lt;ResultMapResolver&gt; iter = incompleteResultMaps.iterator(); * while (iter.hasNext()) { * try { * // org.apache.ibatis.builder.ResultMapResolver#resolve * iter.next().resolve(); * iter.remove(); * } catch (IncompleteElementException e) { * // ResultMap is still missing a resource... * } * } * } * } */ // 缓存解析 parsePendingCacheRefs(); // SQL解析：select | insert | update | delete // 将未完成解析的SQLStatements解析到configuration的mappedStatements集合中 parsePendingStatements(); /** * private void parsePendingStatements() { * Collection&lt;XMLStatementBuilder&gt; incompleteStatements = configuration.getIncompleteStatements(); * synchronized (incompleteStatements) { * Iterator&lt;XMLStatementBuilder&gt; iter = incompleteStatements.iterator(); * while (iter.hasNext()) { * try { * // org.apache.ibatis.builder.xml.XMLStatementBuilder#parseStatementNode * iter.next().parseStatementNode(); * iter.remove(); * } catch (IncompleteElementException e) { * // Statement is still missing a resource... * } * } * } * } */ } configurationElement(parser.evalNode(“/mapper”))org.apache.ibatis.builder.xml.XMLMapperBuilder#configurationElement源码： private void configurationElement(XNode context) { try { // namespace检查与设置 String namespace = context.getStringAttribute(&quot;namespace&quot;); if (namespace == null || namespace.equals(&quot;&quot;)) { throw new BuilderException(&quot;Mapper&#39;s namespace cannot be empty&quot;); } builderAssistant.setCurrentNamespace(namespace); // 二级缓存配置：可以在当前namespace中使用&lt;cache/&gt;开启二级缓存， // 当前空间的缓存只在当前空间有效，如果需要引用其他空间的缓存，则需要配置&lt;cache-ref/&gt; cacheRefElement(context.evalNode(&quot;cache-ref&quot;)); cacheElement(context.evalNode(&quot;cache&quot;)); // 解析引用外部的参数parameterMap，已经废弃 parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;)); // resultMap 节点数据解析，resultMap节点可以配置多个，id区分，将最终的解析结果已 // resultMap的id为key，resultMap为value存入configuration的resultMaps集合中 resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;)); // sql节点解析 sqlElement(context.evalNodes(&quot;/mapper/sql&quot;)); // select|insert|update|delete 节点解析 buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#39;&quot; + resource + &quot;&#39;. Cause: &quot; + e, e); } } 解析ResultMaporg.apache.ibatis.builder.xml.XMLMapperBuilder#resultMapElements： private void resultMapElements(List&lt;XNode&gt; list) throws Exception { for (XNode resultMapNode : list) { try { resultMapElement(resultMapNode); } catch (IncompleteElementException e) { // ignore, it will be retried } } } private ResultMap resultMapElement(XNode resultMapNode) throws Exception { return resultMapElement(resultMapNode, Collections.emptyList(), null); } private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings, Class&lt;?&gt; enclosingType) throws Exception { ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier()); // 获取ResultMap的类型，我们通常配置的都是type，也即是：JAVA实体类的类型 String type = resultMapNode.getStringAttribute(&quot;type&quot;, resultMapNode.getStringAttribute(&quot;ofType&quot;, resultMapNode.getStringAttribute(&quot;resultType&quot;, resultMapNode.getStringAttribute(&quot;javaType&quot;)))); // 通过别名或是全限定名获取type的Class对象 Class&lt;?&gt; typeClass = resolveClass(type); if (typeClass == null) { // type不配或是配不正确，resolveClass都会报错，所以到不了这个地方，暂不研究 typeClass = inheritEnclosingType(resultMapNode, enclosingType); } Discriminator discriminator = null; List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;&gt;(); resultMappings.addAll(additionalResultMappings); List&lt;XNode&gt; resultChildren = resultMapNode.getChildren(); for (XNode resultChild : resultChildren) { if (&quot;constructor&quot;.equals(resultChild.getName())) { /** 解析在ResultMap中配置的java实体构造器节点，例如： * &lt;constructor&gt; * &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&gt; * &lt;arg column=&quot;username&quot; javaType=&quot;String&quot;/&gt; * ...... * &lt;/constructor&gt; * 使用类似String column = context.getStringAttribute(&quot;column&quot;);方式获取节点数据 * 将解析出来的节点数据放入ResultMapping中 */ processConstructorElement(resultChild, typeClass, resultMappings); } else if (&quot;discriminator&quot;.equals(resultChild.getName())) { /** * 使用结果值来决定使用哪个 resultMap * 同样的将节点的数据放入ResultMapping中，并将ResultMapping结果集存入Discriminator的resultMapping属性中 */ discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings); } else { /** * 主要来看看这个buildResultMappingFromContext(resultChild, typeClass, flags)方法，从方法就可以看出，是用于构造ResultMapping，一个result对应就对应一个resultMapping */ List&lt;ResultFlag&gt; flags = new ArrayList&lt;&gt;(); if (&quot;id&quot;.equals(resultChild.getName())) { flags.add(ResultFlag.ID); } resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags)); } } // resultMap的id String id = resultMapNode.getStringAttribute(&quot;id&quot;, resultMapNode.getValueBasedIdentifier()); // 继承于其他resultMap的id String extend = resultMapNode.getStringAttribute(&quot;extends&quot;); // 是否开启/关闭自动映射 Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;); ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping); try { // 获取ResultMap return resultMapResolver.resolve(); } catch (IncompleteElementException e) { configuration.addIncompleteResultMap(resultMapResolver); throw e; } } private ResultMapping buildResultMappingFromContext(XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags) throws Exception { // 获取配置的各种属性值 String property; if (flags.contains(ResultFlag.CONSTRUCTOR)) { property = context.getStringAttribute(&quot;name&quot;); } else { property = context.getStringAttribute(&quot;property&quot;); } String column = context.getStringAttribute(&quot;column&quot;); String javaType = context.getStringAttribute(&quot;javaType&quot;); String jdbcType = context.getStringAttribute(&quot;jdbcType&quot;); String nestedSelect = context.getStringAttribute(&quot;select&quot;); String nestedResultMap = context.getStringAttribute(&quot;resultMap&quot;, processNestedResultMappings(context, Collections.emptyList(), resultType)); String notNullColumn = context.getStringAttribute(&quot;notNullColumn&quot;); String columnPrefix = context.getStringAttribute(&quot;columnPrefix&quot;); String typeHandler = context.getStringAttribute(&quot;typeHandler&quot;); String resultSet = context.getStringAttribute(&quot;resultSet&quot;); String foreignColumn = context.getStringAttribute(&quot;foreignColumn&quot;); boolean lazy = &quot;lazy&quot;.equals(context.getStringAttribute(&quot;fetchType&quot;, configuration.isLazyLoadingEnabled() ? &quot;lazy&quot; : &quot;eager&quot;)); // 通过别名或全限定名解析java实体类的类型 Class&lt;?&gt; javaTypeClass = resolveClass(javaType); // 通过别名或全限定名解析类型处理器的类型 Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = resolveClass(typeHandler); // 通过别名获取jdbc的类型 JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType); // 根据解析出来的属性值构造ResultMapping return builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy); } org.apache.ibatis.builder.MapperBuilderAssistant#buildResultMapping： public ResultMapping buildResultMapping( Class&lt;?&gt; resultType, String property, String column, Class&lt;?&gt; javaType, JdbcType jdbcType, String nestedSelect, String nestedResultMap, String notNullColumn, String columnPrefix, Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler, List&lt;ResultFlag&gt; flags, String resultSet, String foreignColumn, boolean lazy) { // 解析property对应的java类型 Class&lt;?&gt; javaTypeClass = resolveResultJavaType(resultType, property, javaType); // 根据typeHandlerType或javaTypeClass和typeHandlerType从typeHandlerRegistry中获取TypeHandler TypeHandler&lt;?&gt; typeHandlerInstance = resolveTypeHandler(javaTypeClass, typeHandler); List&lt;ResultMapping&gt; composites; if ((nestedSelect == null || nestedSelect.isEmpty()) &amp;&amp; (foreignColumn == null || foreignColumn.isEmpty())) { composites = Collections.emptyList(); } else { composites = parseCompositeColumnName(column); } return new ResultMapping.Builder(configuration, property, column, javaTypeClass) .jdbcType(jdbcType) .nestedQueryId(applyCurrentNamespace(nestedSelect, true)) .nestedResultMapId(applyCurrentNamespace(nestedResultMap, true)) .resultSet(resultSet) .typeHandler(typeHandlerInstance) .flags(flags == null ? new ArrayList&lt;&gt;() : flags) .composites(composites) .notNullColumns(parseMultipleColumnNames(notNullColumn)) .columnPrefix(columnPrefix) .foreignColumn(foreignColumn) .lazy(lazy) .build(); } private Class&lt;?&gt; resolveResultJavaType(Class&lt;?&gt; resultType, String property, Class&lt;?&gt; javaType) { if (javaType == null &amp;&amp; property != null) { try { /** * MetaClass.forClass(resultType,configuration.getReflectorFactory()) * 就是通过resultType、reflectorFactory构造MetaClass，构造方法： * private MetaClass(Class&lt;?&gt; type, ReflectorFactory reflectorFactory) { * this.reflectorFactory = reflectorFactory; * this.reflector = reflectorFactory.findForClass(type); * } * * org.apache.ibatis.reflection.DefaultReflectorFactory#findForClass方法 * public Reflector findForClass(Class&lt;?&gt; type) { * if (classCacheEnabled) { * // synchronized (type) removed see issue #461 * // private final ConcurrentMap&lt;Class&lt;?&gt;, Reflector&gt; reflectorMap = new ConcurrentHashMap&lt;&gt;(); * return reflectorMap.computeIfAbsent(type,Reflector::new); * } else { * return new Reflector(type); * } * } * * public class Reflector { * * private final Class&lt;?&gt; type; * private final String[] readablePropertyNames; * private final String[] writablePropertyNames; * private final Map&lt;String, Invoker&gt; setMethods = new HashMap&lt;&gt;(); * private final Map&lt;String, Invoker&gt; getMethods = new HashMap&lt;&gt;(); * private final Map&lt;String, Class&lt;?&gt;&gt; setTypes = new HashMap&lt;&gt;(); * private final Map&lt;String, Class&lt;?&gt;&gt; getTypes = new HashMap&lt;&gt;(); * private Constructor&lt;?&gt; defaultConstructor; * * private Map&lt;String, String&gt; caseInsensitivePropertyMap = new HashMap&lt;&gt;(); * * public Reflector(Class&lt;?&gt; clazz) { * type = clazz; * // 添加默认构造器 * addDefaultConstructor(clazz); * // clazz的所有Get方法 * addGetMethods(clazz); * // clazz的所有Set方法 * addSetMethods(clazz); * // clazz的所有属性 * addFields(clazz); * readablePropertyNames = getMethods.keySet().toArray(new String[0]); * writablePropertyNames = setMethods.keySet().toArray(new String[0]); * for (String propName : readablePropertyNames) { * caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName); * } * for (String propName : writablePropertyNames) { * caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName); * } * } * ....... * } * */ MetaClass metaResultType = MetaClass.forClass(resultType, configuration.getReflectorFactory()); // 通过Reflector获取属性Setter方法的类型，因为从数据库获取到值的时候， // 会通过typeHandler转成property对应的SetterType，将值set进去 javaType = metaResultType.getSetterType(property); } catch (Exception e) { //ignore, following null check statement will deal with the situation } } if (javaType == null) { javaType = Object.class; } return javaType; } public ResultMapping build() { // lock down collections resultMapping.flags = Collections.unmodifiableList(resultMapping.flags); resultMapping.composites = Collections.unmodifiableList(resultMapping.composites); // TypeHandler解析 resolveTypeHandler(); // 安全性验证 validate(); return resultMapping; } private void resolveTypeHandler() { if (resultMapping.typeHandler == null &amp;&amp; resultMapping.javaType != null) { Configuration configuration = resultMapping.configuration; TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry(); resultMapping.typeHandler = typeHandlerRegistry.getTypeHandler(resultMapping.javaType, resultMapping.jdbcType); } } private void validate() { // Issue #697: cannot define both nestedQueryId and nestedResultMapId if (resultMapping.nestedQueryId != null &amp;&amp; resultMapping.nestedResultMapId != null) { throw new IllegalStateException(&quot;Cannot define both nestedQueryId and nestedResultMapId in property &quot; + resultMapping.property); } // Issue #5: there should be no mappings without typehandler if (resultMapping.nestedQueryId == null &amp;&amp; resultMapping.nestedResultMapId == null &amp;&amp; resultMapping.typeHandler == null) { throw new IllegalStateException(&quot;No typehandler found for property &quot; + resultMapping.property); } // Issue #4 and GH #39: column is optional only in nested resultmaps but not in the rest if (resultMapping.nestedResultMapId == null &amp;&amp; resultMapping.column == null &amp;&amp; resultMapping.composites.isEmpty()) { throw new IllegalStateException(&quot;Mapping is missing column attribute for property &quot; + resultMapping.property); } if (resultMapping.getResultSet() != null) { int numColumns = 0; if (resultMapping.column != null) { numColumns = resultMapping.column.split(&quot;,&quot;).length; } int numForeignColumns = 0; if (resultMapping.foreignColumn != null) { numForeignColumns = resultMapping.foreignColumn.split(&quot;,&quot;).length; } if (numColumns != numForeignColumns) { throw new IllegalStateException(&quot;There should be the same number of columns and foreignColumns in property &quot; + resultMapping.property); } } } 最后来看看org.apache.ibatis.builder.ResultMapResolver#resolve： public ResultMap resolve() { return assistant.addResultMap(this.id, this.type, this.extend, this.discriminator, this.resultMappings, this.autoMapping); } org.apache.ibatis.builder.MapperBuilderAssistant#addResultMap： public ResultMap addResultMap( String id, Class&lt;?&gt; type, String extend, Discriminator discriminator, List&lt;ResultMapping&gt; resultMappings, Boolean autoMapping) { // 命名空间设置 id = applyCurrentNamespace(id, false); extend = applyCurrentNamespace(extend, true); // 解析继承的result if (extend != null) { if (!configuration.hasResultMap(extend)) { throw new IncompleteElementException(&quot;Could not find a parent resultmap with id &#39;&quot; + extend + &quot;&#39;&quot;); } ResultMap resultMap = configuration.getResultMap(extend); List&lt;ResultMapping&gt; extendedResultMappings = new ArrayList&lt;&gt;(resultMap.getResultMappings()); extendedResultMappings.removeAll(resultMappings); // Remove parent constructor if this resultMap declares a constructor. boolean declaresConstructor = false; for (ResultMapping resultMapping : resultMappings) { if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) { declaresConstructor = true; break; } } if (declaresConstructor) { extendedResultMappings.removeIf(resultMapping -&gt; resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)); } resultMappings.addAll(extendedResultMappings); } // 通过解析出来的数据构造resultMap ResultMap resultMap = new ResultMap.Builder(configuration, id, type, resultMappings, autoMapping) .discriminator(discriminator) .build(); // 将resultMap的id作为key，resultMap作为value保存到Configuration的resultMaps属性中 configuration.addResultMap(resultMap); return resultMap; } public ResultMap build() { if (resultMap.id == null) { throw new IllegalArgumentException(&quot;ResultMaps must have an id&quot;); } // 存放column resultMap.mappedColumns = new HashSet&lt;&gt;(); // 存放property resultMap.mappedProperties = new HashSet&lt;&gt;(); // 存放id resultMap.idResultMappings = new ArrayList&lt;&gt;(); // 存放构造器 resultMap.constructorResultMappings = new ArrayList&lt;&gt;(); // 存放整个result结果集 resultMap.propertyResultMappings = new ArrayList&lt;&gt;(); // 存放构造器参数 final List&lt;String&gt; constructorArgNames = new ArrayList&lt;&gt;(); // 解析获取到的resultMap.resultMappings for (ResultMapping resultMapping : resultMap.resultMappings) { resultMap.hasNestedQueries = resultMap.hasNestedQueries || resultMapping.getNestedQueryId() != null; resultMap.hasNestedResultMaps = resultMap.hasNestedResultMaps || (resultMapping.getNestedResultMapId() != null &amp;&amp; resultMapping.getResultSet() == null); final String column = resultMapping.getColumn(); if (column != null) { resultMap.mappedColumns.add(column.toUpperCase(Locale.ENGLISH)); } else if (resultMapping.isCompositeResult()) { for (ResultMapping compositeResultMapping : resultMapping.getComposites()) { final String compositeColumn = compositeResultMapping.getColumn(); if (compositeColumn != null) { resultMap.mappedColumns.add(compositeColumn.toUpperCase(Locale.ENGLISH)); } } } final String property = resultMapping.getProperty(); if (property != null) { resultMap.mappedProperties.add(property); } if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) { resultMap.constructorResultMappings.add(resultMapping); if (resultMapping.getProperty() != null) { constructorArgNames.add(resultMapping.getProperty()); } } else { // 没有构造器就把整个result结果集存起来 resultMap.propertyResultMappings.add(resultMapping); } if (resultMapping.getFlags().contains(ResultFlag.ID)) { resultMap.idResultMappings.add(resultMapping); } } if (resultMap.idResultMappings.isEmpty()) { resultMap.idResultMappings.addAll(resultMap.resultMappings); } // 解析实际的构造参数 if (!constructorArgNames.isEmpty()) { final List&lt;String&gt; actualArgNames = argNamesOfMatchingConstructor(constructorArgNames); if (actualArgNames == null) { throw new BuilderException(&quot;Error in result map &#39;&quot; + resultMap.id + &quot;&#39;. Failed to find a constructor in &#39;&quot; + resultMap.getType().getName() + &quot;&#39; by arg names &quot; + constructorArgNames + &quot;. There might be more info in debug log.&quot;); } resultMap.constructorResultMappings.sort((o1, o2) -&gt; { int paramIdx1 = actualArgNames.indexOf(o1.getProperty()); int paramIdx2 = actualArgNames.indexOf(o2.getProperty()); return paramIdx1 - paramIdx2; }); } // 已解析过的数据不可变 // lock down collections resultMap.resultMappings = Collections.unmodifiableList(resultMap.resultMappings); resultMap.idResultMappings = Collections.unmodifiableList(resultMap.idResultMappings); resultMap.constructorResultMappings = Collections.unmodifiableList(resultMap.constructorResultMappings); resultMap.propertyResultMappings = Collections.unmodifiableList(resultMap.propertyResultMappings); resultMap.mappedColumns = Collections.unmodifiableSet(resultMap.mappedColumns); return resultMap; } 解析sqlElementorg.apache.ibatis.builder.xml.XMLMapperBuilder#sqlElement： private void sqlElement(List&lt;XNode&gt; list) { if (configuration.getDatabaseId() != null) { sqlElement(list, configuration.getDatabaseId()); } sqlElement(list, null); } private void sqlElement(List&lt;XNode&gt; list, String requiredDatabaseId) { for (XNode context : list) { String databaseId = context.getStringAttribute(&quot;databaseId&quot;); String id = context.getStringAttribute(&quot;id&quot;); id = builderAssistant.applyCurrentNamespace(id, false); if (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) { // 将sqlElement保存到org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments 集合中 // private final Map&lt;String, XNode&gt; sqlFragments sqlFragments.put(id, context); } } } 解析select | insert | update | delete private void buildStatementFromContext(List&lt;XNode&gt; list) { if (configuration.getDatabaseId() != null) { buildStatementFromContext(list, configuration.getDatabaseId()); } buildStatementFromContext(list, null); } private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) { for (XNode context : list) { // org.apache.ibatis.builder.xml.XMLStatementBuilder final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId); try { statementParser.parseStatementNode(); } catch (IncompleteElementException e) { configuration.addIncompleteStatement(statementParser); } } } // 开始解析 public void parseStatementNode() { String id = context.getStringAttribute(&quot;id&quot;); String databaseId = context.getStringAttribute(&quot;databaseId&quot;); if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) { return; } // 获取节点类型 // SqlCommandType：UNKNOWN, INSERT, UPDATE, DELETE, SELECT, FLUSH String nodeName = context.getNode().getNodeName(); SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH)); boolean isSelect = sqlCommandType == SqlCommandType.SELECT; boolean flushCache = context.getBooleanAttribute(&quot;flushCache&quot;, !isSelect); boolean useCache = context.getBooleanAttribute(&quot;useCache&quot;, isSelect); boolean resultOrdered = context.getBooleanAttribute(&quot;resultOrdered&quot;, false); // Include Fragments before parsing // 解析包含的&lt;include/&gt;节点 XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant); includeParser.applyIncludes(context.getNode()); // 解析参数类型 String parameterType = context.getStringAttribute(&quot;parameterType&quot;); Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType); // 解析数据库语言驱动LanguageDriver：XMLLanguageDriver String lang = context.getStringAttribute(&quot;lang&quot;); LanguageDriver langDriver = getLanguageDriver(lang); // 解析selectKey，通常是配置的需要自动生成值的键 // Parse selectKey after includes and remove them. processSelectKeyNodes(id, parameterTypeClass, langDriver); // Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed) KeyGenerator keyGenerator; String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX; keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true); if (configuration.hasKeyGenerator(keyStatementId)) { keyGenerator = configuration.getKeyGenerator(keyStatementId); } else { keyGenerator = context.getBooleanAttribute(&quot;useGeneratedKeys&quot;, configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType)) ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE; } /** * 解析SQL * langDriver.createSqlSource(configuration, context, parameterTypeClass) * 来分析下： * org.apache.ibatis.scripting.xmltags.XMLLanguageDriver#createSqlSource * public SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType) { * XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script, parameterType); * return builder.parseScriptNode(); * } * * org.apache.ibatis.scripting.xmltags.XMLScriptBuilder#XMLScriptBuilder * public XMLScriptBuilder(Configuration configuration, XNode context, Class&lt;?&gt; parameterType) { * /** * * super(configuration) * * 配置赋值 XMLScriptBuilder extends org.apache.ibatis.builder.BaseBuilder#BaseBuilder * * public BaseBuilder(Configuration configuration) { * * this.configuration = configuration; * * this.typeAliasRegistry = this.configuration.getTypeAliasRegistry(); * * this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry(); * * } * */ * super(configuration); * this.context = context; * this.parameterType = parameterType; * initNodeHandlerMap(); * } * 动态SQL处理初始化 * private void initNodeHandlerMap() { * nodeHandlerMap.put(&quot;trim&quot;, new TrimHandler()); * nodeHandlerMap.put(&quot;where&quot;, new WhereHandler()); * nodeHandlerMap.put(&quot;set&quot;, new SetHandler()); * nodeHandlerMap.put(&quot;foreach&quot;, new ForEachHandler()); * nodeHandlerMap.put(&quot;if&quot;, new IfHandler()); * nodeHandlerMap.put(&quot;choose&quot;, new ChooseHandler()); * nodeHandlerMap.put(&quot;when&quot;, new IfHandler()); * nodeHandlerMap.put(&quot;otherwise&quot;, new OtherwiseHandler()); * nodeHandlerMap.put(&quot;bind&quot;, new BindHandler()); * } * * org.apache.ibatis.scripting.xmltags.XMLScriptBuilder#parseScriptNode * public SqlSource parseScriptNode() { * MixedSqlNode rootSqlNode = parseDynamicTags(context); * SqlSource sqlSource; * // DynamicSqlSource、RawSqlSourc、StaticSqlSource均实现了SqlSource接口 * if (isDynamic) { * // 直接构造一个DynamicSqlSource对象，对于&quot;${}&quot;的动态SQL直接构造返回， * // 不会对其进行解析，因此容易造成SQL注入攻击 * sqlSource = new DynamicSqlSource(configuration, rootSqlNode); * /** * * public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) { * * this.configuration = configuration; * * this.rootSqlNode = rootSqlNode; * * } * */ * } else { * // 在RawSqlSource中对sql进行解析，对于&quot;#{}&quot;每次都会进行解析，可以预防SQL注入攻击 * sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType); * /** * * org.apache.ibatis.scripting.defaults.RawSqlSource#RawSqlSource * * public RawSqlSource(Configuration configuration, SqlNode rootSqlNode, Class&lt;?&gt; parameterType) { * * this(configuration, getSql(configuration, rootSqlNode), parameterType); * * } * * public RawSqlSource(Configuration configuration, String sql, Class&lt;?&gt; parameterType) { * * SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); * * Class&lt;?&gt; clazz = parameterType == null ? Object.class : parameterType; * * this.sqlSource = sqlSourceParser.parse(sql, clazz, new HashMap()); * * } * * * * org.apache.ibatis.builder.SqlSourceBuilder#parse * * public SqlSourceBuilder(Configuration configuration) { * * // 初始化configuration、typeAliasRegistry、typeHandlerRegistry * * super(configuration); * * } * * * * public SqlSource parse(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters) { * * SqlSourceBuilder.ParameterMappingTokenHandler handler = new SqlSourceBuilder.ParameterMappingTokenHandler(this.configuration, parameterType, additionalParameters); * * GenericTokenParser parser = new GenericTokenParser(&quot;#{&quot;, &quot;}&quot;, handler); * * // 解析占位符&quot;#{}&quot;，构造SQL * * String sql = parser.parse(originalSql); * * // 返回解析出的静态SQL * * return new StaticSqlSource(this.configuration, sql, handler.getParameterMappings()); * * } * */ * } * return sqlSource; * } * * parseDynamicTags(context) * 解析SQL放入contents集合 * SQL会被解析成3个部分：select、查询的属性、剩余的一段，例如： * select id,name,email from user where id = 1 * 解析出来后就是： * 1、select * 2、id,name,email * 3、from user where id = 1 * * protected MixedSqlNode parseDynamicTags(XNode node) { * List&lt;SqlNode&gt; contents = new ArrayList&lt;&gt;(); * NodeList children = node.getNode().getChildNodes(); * for (int i = 0; i &lt; children.getLength(); i++) { * XNode child = node.newXNode(children.item(i)); * // 节点类型：org.w3c.dom.Node * if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) { * String data = child.getStringBody(&quot;&quot;); * TextSqlNode textSqlNode = new TextSqlNode(data); * // 根据是否包含&quot;${}&quot;判断是否是动态SQL * if (textSqlNode.isDynamic()) { * contents.add(textSqlNode); * isDynamic = true; * } else { * contents.add(new StaticTextSqlNode(data)); * } * } else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) { // issue #628 * String nodeName = child.getNode().getNodeName(); * // 根据节点名称从initNodeHandlerMap()中获取相应的SQL动态处理器 * NodeHandler handler = nodeHandlerMap.get(nodeName); * if (handler == null) { * throw new BuilderException(&quot;Unknown element &lt;&quot; + nodeName + &quot;&gt; in SQL statement.&quot;); * } * // 使用获取到的处理器处理动态SQL * handler.handleNode(child, contents); * // 如果节点类型是：Node.ELEMENT_NODE，也会判定为动态SQL * isDynamic = true; * } * } * // 将contents放入MixedSqlNode的contents集合中 * /** * * org.apache.ibatis.scripting.xmltags.MixedSqlNode#MixedSqlNode * * public class MixedSqlNode implements SqlNode { * * private final List&lt;SqlNode&gt; contents; * * public MixedSqlNode(List&lt;SqlNode&gt; contents) { * * this.contents = contents; * * } * * * * @Override * * public boolean apply(DynamicContext context) { * * contents.forEach(node -&gt; node.apply(context)); * * return true; * * } * * } * */ * return new MixedSqlNode(contents); * } * */ SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass); // 获取声明类型StatementType：STATEMENT, PREPARED, CALLABLE StatementType statementType = StatementType.valueOf(context.getStringAttribute(&quot;statementType&quot;, StatementType.PREPARED.toString())); // 获取设置的其他的属性 Integer fetchSize = context.getIntAttribute(&quot;fetchSize&quot;); Integer timeout = context.getIntAttribute(&quot;timeout&quot;); String parameterMap = context.getStringAttribute(&quot;parameterMap&quot;); String resultType = context.getStringAttribute(&quot;resultType&quot;); Class&lt;?&gt; resultTypeClass = resolveClass(resultType); String resultMap = context.getStringAttribute(&quot;resultMap&quot;); String resultSetType = context.getStringAttribute(&quot;resultSetType&quot;); ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType); if (resultSetTypeEnum == null) { resultSetTypeEnum = configuration.getDefaultResultSetType(); } String keyProperty = context.getStringAttribute(&quot;keyProperty&quot;); String keyColumn = context.getStringAttribute(&quot;keyColumn&quot;); String resultSets = context.getStringAttribute(&quot;resultSets&quot;); // 构造SQL的MappedStatement，MappedStatement是啥呢，往下看 builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum, flushCache, useCache, resultOrdered, keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets); } /** * org.apache.ibatis.builder.MapperBuilderAssistant#addMappedStatement * // MappedStatement就是用于存放解析出来的每个SQL的元数据信息，看看构造参数就知道了哈 * public MappedStatement addMappedStatement( * String id, * SqlSource sqlSource, * StatementType statementType, * SqlCommandType sqlCommandType, * Integer fetchSize, * Integer timeout, * String parameterMap, * Class&lt;?&gt; parameterType, * String resultMap, * Class&lt;?&gt; resultType, * ResultSetType resultSetType, * boolean flushCache, * boolean useCache, * boolean resultOrdered, * KeyGenerator keyGenerator, * String keyProperty, * String keyColumn, * String databaseId, * LanguageDriver lang, * String resultSets) { * * if (unresolvedCacheRef) { * throw new IncompleteElementException(&quot;Cache-ref not yet resolved&quot;); * } * * id = applyCurrentNamespace(id, false); * boolean isSelect = sqlCommandType == SqlCommandType.SELECT; * * MappedStatement.Builder statementBuilder = new MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType) * .resource(resource) * .fetchSize(fetchSize) * .timeout(timeout) * .statementType(statementType) * .keyGenerator(keyGenerator) * .keyProperty(keyProperty) * .keyColumn(keyColumn) * .databaseId(databaseId) * .lang(lang) * .resultOrdered(resultOrdered) * .resultSets(resultSets) * .resultMaps(getStatementResultMaps(resultMap, resultType, id)) * .resultSetType(resultSetType) * .flushCacheRequired(valueOrDefault(flushCache, !isSelect)) * .useCache(valueOrDefault(useCache, isSelect)) * .cache(currentCache); * * ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id); * /** * * private ParameterMap getStatementParameterMap( * * String parameterMapName, * * Class&lt;?&gt; parameterTypeClass, * * String statementId) { * * parameterMapName = applyCurrentNamespace(parameterMapName, true); * * ParameterMap parameterMap = null; * * if (parameterMapName != null) { * * try { * * parameterMap = configuration.getParameterMap(parameterMapName); * * } catch (IllegalArgumentException e) { * * throw new IncompleteElementException(&quot;Could not find parameter map &quot; + parameterMapName, e); * * } * * } else if (parameterTypeClass != null) { * * List&lt;ParameterMapping&gt; parameterMappings = new ArrayList&lt;&gt;(); * * parameterMap = new ParameterMap.Builder(configuration, statementId + &quot;-Inline&quot;, parameterTypeClass, parameterMappings).build(); * * } * * return parameterMap; * * } * */ * if (statementParameterMap != null) { * statementBuilder.parameterMap(statementParameterMap); * } * * MappedStatement statement = statementBuilder.build(); * /** * * org.apache.ibatis.mapping.MappedStatement.Builder#build * * public MappedStatement build() { * * assert mappedStatement.configuration != null; * * assert mappedStatement.id != null; * * assert mappedStatement.sqlSource != null; * * assert mappedStatement.lang != null; * * // 解析出来的结果就不允许改变了，否则会导致数据一致性问题 * * mappedStatement.resultMaps = Collections.unmodifiableList(mappedStatement.resultMaps); * * return mappedStatement; * * } * */ * // 最终把数据放到configuration的mappedStatements属性中： * // protected final Map&lt;String, MappedStatement&gt; mappedStatements = new StrictMap&lt;MappedStatement&gt;(...) * configuration.addMappedStatement(statement); * return statement; * } * */ 资源限定符（URL）方式解析这种方式其实就是和Mapper方式解析是一样的啦，就是数据的来源不一样而已！ 全限定类名方式解析这种方式也很简单，直接把类加载出来注册到configuration的属性mapperRegistry中的org.apache.ibatis.binding.MapperRegistry#knownMappers属性中 小总结构造SqlSessionFactory的过程就是对配置文件进行解析的过程，然后根据配置文件返回一个DefaultSqlSessionFactory。配置文件的解析主要涉及： typeAliases的解析结果注册到：org.apache.ibatis.type.TypeAliasRegistry#typeAliases plugins的解析结果注册到：org.apache.ibatis.plugin.InterceptorChain#interceptors environments的解析： 多数据源的解析 结果注册到：org.apache.ibatis.session.Configuration#environment typeHandlers的解析 如果JavaType不为null，其中key为javatype注册到org.apache.ibatis.type.TypeHandlerRegistry#typeHandlerMap(private final Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = new ConcurrentHashMap&lt;&gt;()) 如果JavaType为null，其中key为handle的type注册到org.apache.ibatis.type.TypeHandlerRegistry#allTypeHandlersMap(private final Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; allTypeHandlersMap = new HashMap&lt;&gt;()) mappers的解析 parameterMaps的解析结果注册到：org.apache.ibatis.session.Configuration#parameterMaps resultMap的解析结果注册到：org.apache.ibatis.session.Configuration#resultMaps sql节点的解析结果注册到：org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments select | insert | update | delete的解析 动态SQL与静态SQL的解析 区别${} 和 #{}的解析 结果注册到：org.apache.ibatis.session.Configuration#mappedStatements 以上数据解析出来之后，最终的结果都会汇总到configuration中，也就是说以上解析出来的结果在configuration中都有一个属性与之对应。","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"/tags/mybatis/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"MyBatis介绍及基本用法","slug":"tech-mybatis-introduction","date":"2019-10-29T07:30:10.000Z","updated":"2019-11-03T14:54:26.096Z","comments":true,"path":"2019/10/29/tech-mybatis-introduction/","link":"","permalink":"/2019/10/29/tech-mybatis-introduction/","excerpt":"","text":"什么是MyBatisMyBatis官网给出的定义如下： MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings. MyBatis eliminates almost all of the JDBC code and manual setting of parameters and retrieval of results. MyBatis can use simple XML or Annotations for configuration and map primitives, Map interfaces and Java POJOs (Plain Old Java Objects) to database records. 英文不好？没关系，MyBatis给出了多种语言，其中就包括了中文版官方翻译，来看看： MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 怎么使用呢我们就不按照官网那样，初始化一个maven项目，然后再手动引入jar包的方式来构建项目了。我们直接使用Idea来初始化一个Springboot项目(目前大家都已在用Springboot开发项目，所以直接使用Spring Initializr初始化项目就OK。实在不想用，那就没办法咯！)，熟悉一下Springboot整合中间件的流程。打开Idea，依次File -&gt; new -&gt; Project... ， 选择Spring Initializr，配置好JDK，然后Next，配置好Project Metadata，然后next，可以选择Web -&gt; Spring Web方便后续做测试，重要的是选择SQL -&gt; MyBatis Framework 、MySQL Driver这两项，然后next配置项目名称及存储路径，Finish后呢，项目就建好了，顺带所需要的依赖包也引入到项目了。在开始之前呢，需要准备一个测试库（库名按你喜欢的方式命名就好）以及一个测试表（以下测试表为USER），准备好之后呢，就可以开始以下骚操作了。 编程式1、添加配置在resources包下新建mybatis-config.xml，然后加入下面模板内容： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; // 环境的名称，可以配置多个环境 &lt;environments default=&quot;development&quot;&gt; // 环境ID或数据源ID，通过ID可以配置多个数据源 &lt;environment id=&quot;development&quot;&gt; // 启用事物 &lt;transactionManager type=&quot;JDBC&quot;/&gt; // 构建连接池 &lt;dataSource type=&quot;POOLED&quot;&gt; // MySQL驱动 &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; // MySQL数据库链接地址 &lt;property name=&quot;url&quot; value=&quot;xxx&quot;/&gt; // 用户名 &lt;property name=&quot;username&quot; value=&quot;test&quot;/&gt; // 密码 &lt;property name=&quot;password&quot; value=&quot;test&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; // SQL查询语句配置 // SQL的配置方式有两种： // 第一种：采用这种XML的配置方式 // 第二种：使用注解的方式，直接在接口方法上使用@Select等注解，例如： // public interface UserMapper { // @Select(&quot;SELECT * FROM USER WHERE id = #{id}&quot;) // User selectUser(Long id); // } // 两种方式各有优劣，使用哪一种完全取决于自己或是开发团队 &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 依次填上你MySQL的相关信息即可。&lt;configuration&gt;节点中还可以配置&lt;typeHandlers&gt;，&lt;typeHandlers&gt;会对实体类的属性类型和数据库中的字段类型进行转换，MyBatis默认支持已很多的类型转换，比如：String和char、varchar互转，Date和TIMESTAMP互转等。还可以配置&lt;plugins&gt;，用于在处理数据前后做一些事情，比如常用的分页插件，用于对分页进行处理。还有其他的一些配置可以直接在官网的configuration配置文档中查看。MySQL链接的通常写法： jdbc:mysql://ip或domain:port/库名?characterEncoding=utf-8&amp;amp;autoReconnect=true&amp;amp;failOverReadOnly=false&amp;amp;serverTimezone=Asia/Shanghai 在xml中配置的时候，需要把&amp;进行转义为&amp;amp;否则会报错： Exception in thread &quot;main&quot; org.apache.ibatis.exceptions.PersistenceException: ### Error building SqlSession. ### Cause: org.apache.ibatis.builder.BuilderException: Error creating document instance. Cause: org.xml.sax.SAXParseException; lineNumber: 11; columnNumber: 126; 对实体 &quot;autoReconnect&quot; 的引用必须以 &#39;;&#39; 分隔符结尾。 at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) at org.apache.ibatis.session.SqlSessionFactoryBuilder.build(SqlSessionFactoryBuilder.java:80) at org.apache.ibatis.session.SqlSessionFactoryBuilder.build(SqlSessionFactoryBuilder.java:64) at com.springboot.mybatis.MyBatisTest.main(MyBatisTest.java:22) 2、构建User实体类新建包com.springboot.springbootmybatis.model，编写实体类User： public class User { /** * 主键 */ private Long id; /** * 用户ID */ private Long userId; /** * 用户名 */ private String name; /** * 用户的邮箱 */ private String email; /** * 创建时间 */ private Date createdTime; /** * 修改时间 */ private Date modifiedTime; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public Long getUserId() { return userId; } public void setUserId(Long userId) { this.userId = userId; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Date getCreatedTime() { return createdTime; } public void setCreatedTime(Date createdTime) { this.createdTime = createdTime; } public Date getModifiedTime() { return modifiedTime; } public void setModifiedTime(Date modifiedTime) { this.modifiedTime = modifiedTime; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, userId=&quot; + userId + &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, email=&#39;&quot; + email + &#39;\\&#39;&#39; + &quot;, createdTime=&quot; + createdTime + &quot;, modifiedTime=&quot; + modifiedTime + &#39;}&#39;; } } 3、构建UserDAO接口新建包com.springboot.springbootmybatis.dao，新建接口UserDAO： @Repository public interface UserDAO { /** * 根据主键查询User信息 * @param id * @return */ User selectUser(Long id); } 4、构建userMapper.xml文件在resources下新建mapper文件夹，然后新建userMapper.xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.springboot.dao.UserDAO&quot;&gt; &lt;resultMap id=&quot;baseResultMap&quot; type=&quot;com.springboot.model.User&quot;&gt; &lt;id column=&quot;ID&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;USER_ID&quot; jdbcType=&quot;BIGINT&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;NAME&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;EMAIL&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;CREATED_TIME&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createdTime&quot;/&gt; &lt;result column=&quot;MODIFIED_TIME&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;modifiedTime&quot;/&gt; &lt;/resultMap&gt; &lt;sql id=&quot;columns&quot;&gt; ID, USER_ID, NAME, EMAIL, CREATED_TIME, MODIFIED_TIME &lt;/sql&gt; &lt;select id=&quot;selectUser&quot; resultMap=&quot;baseResultMap&quot;&gt; select &lt;include refid=&quot;columns&quot;/&gt; from USER where id = #{id} &lt;/select&gt; &lt;/mapper&gt; 以上工作准备好之后，我们就可以开始测试了。新建包com.springboot.springbootmybatis.mybatis，然后新建类MyBatisTest，在main方法中，引入： public class MyBatisTest { public static void main(String[] args) throws Exception { String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { UserDAO mapper = session.getMapper(UserDAO.class); User user = mapper.selectUser(1L); System.out.println(user.toString()); } } } 来看看其中几个重要类的官方解释： SqlSessionFactoryBuilder：这个类可以被实例化、使用和丢弃，一旦创建了SqlSessionFactory，就不再需要它了。 因此SqlSessionFactoryBuilder实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要让其一直存在，以保证所有的 XML 解析资源可以被释放给更重要的事情。 SqlSessionFactory：SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用SqlSessionFactory的最佳实践是在应用运行期间不要重复创建多次，多次重建SqlSessionFactory被视为一种代码“坏味道（bad smell）”。因此SqlSessionFactory的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession：每个线程都应该有它自己的SqlSession实例。SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将SqlSession实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如Servlet框架中的HttpSession。 如果你现在正在使用一种Web框架，要考虑SqlSession放在一个和HTTP请求对象相似的作用域中。 换句话说，每次收到的HTTP请求，就可以打开一个SqlSession，返回一个响应，就关闭它。 这个关闭操作是很重要的，你应该把这个关闭操作放到finally块中以确保每次都能执行关闭。 在你的所有的代码中一致地使用以下确保SqlSession关闭的标准模式来保证所有数据库资源都能被正确地关闭： try (SqlSession session = sqlSessionFactory.openSession()) { // 你的应用逻辑代码 } 映射器实例，即xxxDAO或xxxMapper：映射器是一些由你创建的、绑定你映射的语句的接口。映射器接口的实例是从SqlSession中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的SqlSession相同的。尽管如此，映射器实例的最佳作用域是方法作用域。 也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可丢弃。 并不需要显式地关闭映射器实例，尽管在整个请求作用域保持映射器实例也不会有什么问题，但是你很快会发现，像SqlSession一样，在这个作用域上管理太多的资源的话会难于控制。 为了避免这种复杂性，最好把映射器放在方法作用域内。下面的示例就展示了这个实践： try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); // 你的应用逻辑代码 } 后面我们会对这几个重要的类进行源码分析，看看底层都干了啥，怎么干的。 好了，运行代码后，就可以看到正常的日志输出啦： 12:27:14.182 [main] DEBUG org.apache.ibatis.logging.LogFactory - Logging initialized using &#39;class org.apache.ibatis.logging.slf4j.Slf4jImpl&#39; adapter. 12:27:14.216 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections. 12:27:14.216 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections. 12:27:14.216 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections. 12:27:14.216 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections. 12:27:14.326 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection 12:27:15.277 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - Created connection 1709804316. 12:27:15.277 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@65e98b1c] 12:27:15.287 [main] DEBUG com.springboot.dao.UserDAO.selectUser - ==&gt; Preparing: select ID, USER_ID, NAME, EMAIL, CREATED_TIME, MODIFIED_TIME from USER where id = ? 12:27:15.321 [main] DEBUG com.springboot.dao.UserDAO.selectUser - ==&gt; Parameters: 1(Long) 12:27:15.348 [main] DEBUG com.springboot.dao.UserDAO.selectUser - &lt;== Total: 1 User{id=1, userId=28250, name=&#39;测试人&#39;, email=&#39;test@danke.com&#39;, createdTime=Tue Oct 29 11:49:44 CST 2019, modifiedTime=Tue Oct 29 11:49:44 CST 2019} 12:27:15.349 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@65e98b1c] 12:27:15.352 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@65e98b1c] 12:27:15.352 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection 1709804316 to pool. 到这里，我们可能会去想：上面的USER实体类、UserDAO、UserMapper.xml这几个文件，我们都要自己去写吗，一个两个还好，多的话那岂不是很麻烦？非也。官方的大佬已经为我们考虑好了，完全可以使用MyBatis Generator(MBG)来生成嘛。所以，我们在分析了我们的业务后，把数据库表建好，就直接可以使用MBG生成代码啦，这不就很爽了吗！ 集成式我们保留dao、model、mapper，自动配置的时候，还需要使用，可别删了，要不还得再来一遍。把mybatis-config.xml注释掉或改为mybatis-config.xml.bak，MyBatisTest可以暂时不用管。 1、数据源及Mapper配置将resources/application.properties文件改为resources/application.yml，当然，不改也可以，个人喜欢yml方式配置而已。😎然后在application.yml文件中添加以下配置： spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver username: test password: test url: xxx mybatis: mapper-locations: classpath:/mapper/*.xml 注意：在写yml文件的时候，数据库链接url中的&amp;不需要转义成&amp;amp; 2、构建Controller新建包com.springboot.springbootmybatis.controller，新建类HelloUserController： @RestController public class HelloUserController { @Autowired private UserDAO userDAO; //如果在UserDAO上没有@Repository，此处会报红色的下划线 @GetMapping(&quot;/user/{userId}&quot;) public User getUser(@PathVariable(&quot;userId&quot;) Long userId) { User user = userDAO.selectUser(userId); return user; } } 这里省略了service层，直接在HelloUserController中调用DAO的接口。实际开发中，Service层是必不可少的。这里的@GetMapping 等于 @RequestMapping(method = RequestMethod.GET)，简单的写法，与之对应的还有@PostMapping。 3、添加Mapper扫描在主类SpringbootMybatisApplication上添加注解：@MapperScan(basePackages = &quot;com.springboot.springbootmybatis.dao&quot;)，配置扫描DAO接口的包路径。 @SpringBootApplication @MapperScan(basePackages = &quot;com.springboot.springbootmybatis.dao&quot;) public class SpringbootMybatisApplication { public static void main(String[] args) { SpringApplication.run(SpringbootMybatisApplication.class, args); } } 注意：添加的包需要和主类SpringbootMybatisApplication在同一级目录，否则扫描不到其中的类，之前Springboot的自动配置源码已分析过：会以主类SpringbootMybatisApplication所在的包为basePackage进行组件扫描。既然如此，那这里不配置@MapperScan行不行呢，当然不行！想想啊，我们面向接口编程，需要使用DAO接口去数据库查询数据，然后返回给调用者，如果接口没有实现类，那怎么去数据库查询呢。而且如果没有实现类，Spring怎么去实例化，怎么去帮助我们管理Bean呢，那不用Spring行不行？行啊，那就使用上面的那种方式，也可以实现，但是不觉得麻烦吗，所有的事情都要自己去做了，比如：Bean的创建及管理，连接的打开关闭等。那这里加了@MapperScan后，为什么就可以了呢？预知后事如何，请听下回分解！ 4、访问测试启动应用程序，在SpringbootMybatisApplication类中右键Run `SpringbootMybatisApplication `，就可以启动啦！在控制台，可以看到以下输出： o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &#39;&#39; 在浏览器中访问：http://localhost:8080/user/1，即可看到结果： {&quot;id&quot;:1,&quot;userId&quot;:11111,&quot;name&quot;:&quot;测试人&quot;,&quot;email&quot;:&quot;test@163.com&quot;,&quot;createdTime&quot;:&quot;2019-10-29 15:49:44&quot;,&quot;modifiedTime&quot;:&quot;2019-10-29 15:49:44&quot;} 小总结1、理解什么是MyBatisMyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 2、使用MyBatis的两种方式 编程式 集成式 3、SQL配置的两种方式 优点 缺点 XML方式 处理复杂的SQL；对SQL进行统一的管理 XML文件比较多；需要查找XML文件 注解方式 简洁直观；不需要去查找XML文件 不能很好的处理复杂的SQL，会比较混乱 4、重要类的作用域(Scope)和生命周期 作用域(Scope)和生命周期 SqlSessionFactoryBuilder 方法作用域（即：局部方法变量） SqlSessionFactory 应用作用域（单例模式或者静态单例模式） SqlSession 请求或方法作用域（放到finally块或try中，确保关闭） 映射器实例 方法作用域（即：局部方法变量） 5、开发业务顺序理解业务 -&gt; 建立库表 -&gt; 使用MBG生成相关代码","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"/tags/mybatis/"},{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"自定义Springboot的Starter","slug":"tech-springboot-custstarter","date":"2019-10-24T10:30:00.000Z","updated":"2019-10-25T14:08:08.479Z","comments":true,"path":"2019/10/24/tech-springboot-custstarter/","link":"","permalink":"/2019/10/24/tech-springboot-custstarter/","excerpt":"","text":"理解了Springboot自动配置原理后呢，来看看怎么自定义一个starter。Starter的命名也是有一定的规范的，官方说的是：spring-boot-starter-xxx被官方保留使用啦，第三方自定义就使用xxx-spring-boot-starter。 自定义Springboot Starter怎么初始化一个项目，请看这里吧！1、使用Idea初始化一个没有整合任何中间件的项目，也就是说在使用工具中的Spring Initializr初始化项目的时候，在选择中间件依赖的时候，啥也不选直接next。这里就初始化一个叫hello-spring-boot-starter的项目 2、在初始化出来的项目中，把生成的包及其中的类删掉，然后新建自己的包。 3、新建com.springboot.hello.marker包，这个包用于条件注解用，也就是说，自定义的自动配置必须在有这个类的前提下，自动配置才能生效。 public class Marker { } 4、新建com.springboot.hello.service包，用于写业务逻辑： public class HelloStarterService { public String helloStarter() { return &quot;WOW！Hello starter is working...&quot;; } } 5、新建 com.springboot.hello.autoconfig包，在其中编写自动配置类： @Configuration(proxyBeanMethods = false) @ConditionalOnClass(Marker.class) public class HelloStarterAutoConfiguration { @Bean public HelloStarterService getHelloStarterService() { return new HelloStarterService(); } } 如果业务逻辑中需要属性配置，还可以在类上加上@EnableConfigurationProperties({xxxProperties.class})，也可以在类上使用@EnableConfigurationProperties启用属性配置后，在方法上使用@ConfigurationProperties(prefix = &quot;xxx.xxx&quot;)进行配置，也可以加上其他的条件注解@ConditionalXXX进行更复杂的配置。 6、在resources包下新建META-INF/spring.factories文件，在其中写上自动配置类： # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.springboot.hello.autoconfig.HelloStarterAutoConfiguration 7、在打包之前删除pom.xml中的这段配置，否则回报找不到main类的错误： &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 8、在我们之前的springboot-web项目的pom.xml中引入这个starter： &lt;dependency&gt; &lt;groupId&gt;com.springboot&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 然后我们在项目的application.yml文件中打开debug： server: port: 8081 debug: true 上面的端口号，是之前改的，后面访问的时候就使用这个端口！ 9、在Helloworld.java中加入在自动配置类中写的HelloStarterService，这个地方不需要去实例化，就可以拿到接口HelloStarterService的实例，自动配置已经帮我们搞好了，直接用就行了。 @RestController public class Helloworld { @Autowired private HelloStarterService helloStarterService; @RequestMapping public String helloworld() { return &quot;hello world&quot;; } @RequestMapping(&quot;/helloStarter&quot;) public String helloStarter() { return helloStarterService.helloStarter(); } } 启动一下，见证奇迹的时刻。在启动后的日志中发现，自定义的自动配置类已经生效了： ============================ CONDITIONS EVALUATION REPORT ============================ Positive matches: ----------------- ... ... HelloStarterAutoConfiguration matched: - @ConditionalOnClass found required class &#39;com.springboot.hello.marker.Marker&#39; (OnClassCondition) ... ... Negative matches: ----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class &#39;javax.jms.ConnectionFactory&#39; (OnClassCondition) ... ... Positive matches是自动配置生效的，Negative matches是自动配置没有生效的。如果我们的自动配置没有生效会不会出现在Negative matches中呢，把自动配置中的条件稍微改一下，来看看： @Configuration(proxyBeanMethods = false) @ConditionalOnBean(Marker.class) public class HelloStarterAutoConfiguration { @Bean public HelloStarterService getHelloStarterService() { return new HelloStarterService(); } } 把条件改成了@ConditionalOnBean(Marker.class)，由于在Spring context环境中是不存在Marker类实例的，所以自动配置是不会生效的，重新打包，reimport一下maven依赖，然后启动springboot-web项目后，会看到这样的输出日志： *************************** APPLICATION FAILED TO START *************************** Description: Field helloStarterService in com.springboot.springbootweb.controller.Helloworld required a bean of type &#39;com.springboot.hello.service.HelloStarterService&#39; that could not be found. The injection point has the following annotations: - @org.springframework.beans.factory.annotation.Autowired(required=true) The following candidates were found but could not be injected: - Bean method &#39;getHelloStarterService&#39; in &#39;HelloStarterAutoConfiguration&#39; not loaded because @ConditionalOnBean (types: com.springboot.hello.marker.Marker; SearchStrategy: all) did not find any beans of type com.springboot.hello.marker.Marker Action: Consider revisiting the entries above or defining a bean of type &#39;com.springboot.hello.service.HelloStarterService&#39; in your configuration. 自动配置失效，属性注入失败，应用启动失败！把helloStarterService这个属性注释掉： @RestController public class Helloworld { // @Autowired // private HelloStarterService helloStarterService; @RequestMapping public String helloworld() { return &quot;hello world&quot;; } @RequestMapping(&quot;/helloStarter&quot;) public String helloStarter() { // return helloStarterService.helloStarter(); return null; } } 再启动下，服务正常启动后看看日志： ============================ CONDITIONS EVALUATION REPORT ============================ Positive matches: ----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class &#39;org.springframework.web.servlet.DispatcherServlet&#39; (OnClassCondition) - found &#39;session&#39; scope (OnWebApplicationCondition) ... ... Negative matches: ----------------- ... ... HelloStarterAutoConfiguration: Did not match: - @ConditionalOnBean (types: com.springboot.hello.marker.Marker; SearchStrategy: all) did not find any beans of type com.springboot.hello.marker.Marker (OnBeanCondition) ... ... 预料之中，对吧！通个这个日志就可以知道自定义的自动配置类有没有生效啦！OK！我们去掉helloStarterService属性及方法中的注释，将Starter中的@ConditionalOnBean改回@ConditionalOnClass，重新打包后，在项目中reimport一下项目依赖，让项目重新正常启动起来。 10、在浏览器中输入：http://localhost:8081/helloStarter后，可以看到： WOW！hello starter is working... 到此呢，自定义Springboot Starter就搞定了。再来总结下步骤： 初始化一个starter项目 编写业务逻辑 编写自动配置类及配置相应的配置 将自动配置类加入到META-INF/spring.factories文件中 打包starter 在项目中引用","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"Springboot自动配置原理解析","slug":"tech-springboot-autoconfig","date":"2019-10-23T02:00:00.000Z","updated":"2019-10-24T13:10:49.497Z","comments":true,"path":"2019/10/23/tech-springboot-autoconfig/","link":"","permalink":"/2019/10/23/tech-springboot-autoconfig/","excerpt":"","text":"有了Springboot核心注解的基础之后呢，来看看Springboot是怎么实现自动配置的？首先，来看看启动类： @SpringBootApplication public class SpringbootWebApplication { public static void main(String[] args) { SpringApplication.run(SpringbootWebApplication.class, args); } } 从run方法进去，直到以下代码： public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) { // 资源加载器 this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); // WEB类型推断 // 由于我们在POM里引入了spring-boot-starter-web,所以类型推断后： // this.webApplicationType = WebApplicationType.SERVLET // 也就说会启动一个SERVLET容器 this.webApplicationType = WebApplicationType.deduceFromClasspath(); // 获取并设置应用的初始化器：用于在refresh（ConfigurableApplicationContext#refresh）之前初始化Spring的回调接口(ApplicationContextInitializer#initialize) setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // 获取并设置应用程序监听器：从3.0开始，一个ApplicationListener可以声明感兴趣的事件类型。当事件被注册到Spring ApplicationContext时，事件会被相应地过滤，并且监听器仅调用匹配的监听事件（事件这个地方会花个章节来说一下） setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 推断运行的主类，这个地方就是上面编写的：SpringbootWebApplication this.mainApplicationClass = deduceMainApplicationClass(); } 上面这段代码，就是为后面运行springboot做好准备。接着往下到run方法： // 运行Spring application，创建并且刷新一个新的ApplicationContext public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); // headless属性设置不用管 configureHeadlessProperty(); // 加载SpringApplication运行时的监听器，此时会获得一个：EventPublishingRunListener SpringApplicationRunListeners listeners = getRunListeners(args); // 广播ApplicationStartingEvent事件 listeners.starting(); try { // 默认ApplicationArguments的实现，用于配置环境 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 因为之前的类型推断是SERVLET，所以会准备一个StandardServletEnvironment的环境，然后配置propertySource、profile等，然后会通过EventPublishingRunListener将该事件广播出去后，将环境绑定到SpringApplication ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 设置调用JavaBean的时候让Spring使用Introspector#IGNORE_ALL_BEANINFO模式，这个就不管了 configureIgnoreBeanInfo(environment); // 控制台的banner哪里来的，就是这里打印的啦！ // banner可以自定义，可以是图片或是text，当然两个都有，也可以打印 Banner printedBanner = printBanner(environment); // 因为之前的类型推断是SERVLET，所以会创建一个AnnotationConfigServletWebServerApplicationContext context = createApplicationContext(); // 错误分析的，会得到一个：FailureAnalyzers exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); // context环境设置，转换器和格式化设置，应用Initializers，Bean定义加载等 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 核心方法啦，进去之后呢，你会发现是Spring的refresh方法，顿时是不是就熟悉啦 refreshContext(context); // 这是个空方法 afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); } // 广播ApplicationStartedEvent事件 listeners.started(context); // 没发现有啥用 callRunners(context, applicationArguments); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); } try { // 广播ApplicationReadyEvent事件 listeners.running(context); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); } return context; } 从refreshContext(context)进去，直到refresh(): @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. // 调用在context中注册为Bean的工厂处理器，自动配置的核心所在 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 实例化Bean（非懒加载） finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &#39;active&#39; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring&#39;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } 自动配置的核心方法，下面一步步来，看看这个核心方法里都在干啥： protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } } 点击进PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())： public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) { // Invoke BeanDefinitionRegistryPostProcessors first, if any. Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;(); if (beanFactory instanceof BeanDefinitionRegistry) { BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;(); List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;(); for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) { if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) { BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; registryProcessor.postProcessBeanDefinitionRegistry(registry); registryProcessors.add(registryProcessor); } else { regularPostProcessors.add(postProcessor); } } // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! // Separate between BeanDefinitionRegistryPostProcessors that implement // PriorityOrdered, Ordered, and the rest. List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;(); // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear. boolean reiterate = true; while (reiterate) { reiterate = false; postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (!processedBeans.contains(ppName)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); reiterate = true; } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); } // Now, invoke the postProcessBeanFactory callback of all processors handled so far. invokeBeanFactoryPostProcessors(registryProcessors, beanFactory); invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); } else { // Invoke factory processors registered with the context instance. invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory); } // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); // Separate between BeanFactoryPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;(); for (String ppName : postProcessorNames) { if (processedBeans.contains(ppName)) { // skip - already processed in first phase above } else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { orderedPostProcessorNames.add(ppName); } else { nonOrderedPostProcessorNames.add(ppName); } } // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); // 调用工厂处理器，进入到这个方法 invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory); // Next, invoke the BeanFactoryPostProcessors that implement Ordered. List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size()); for (String postProcessorName : orderedPostProcessorNames) { orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); } sortPostProcessors(orderedPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory); // Finally, invoke all other BeanFactoryPostProcessors. List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size()); for (String postProcessorName : nonOrderedPostProcessorNames) { nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); } invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); // Clear cached merged bean definitions since the post-processors might have // modified the original metadata, e.g. replacing placeholders in values... beanFactory.clearMetadataCache(); } 点击进invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory): private static void invokeBeanFactoryPostProcessors( Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory) { for (BeanFactoryPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeanFactory(beanFactory); } } 点击进postProcessor.postProcessBeanFactory(beanFactory)，这个地方，会发现有很多的xxxProcessor，其他的不用说，我们这里介绍自动配置，所以选择ConfigurationClassPostProcessor#postProcessBeanFactory进去： public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { int factoryId = System.identityHashCode(beanFactory); if (this.factoriesPostProcessed.contains(factoryId)) { throw new IllegalStateException( &quot;postProcessBeanFactory already called on this post-processor against &quot; + beanFactory); } this.factoriesPostProcessed.add(factoryId); if (!this.registriesPostProcessed.contains(factoryId)) { // BeanDefinitionRegistryPostProcessor hook apparently not supported... // Simply call processConfigurationClasses lazily at this point then. processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory); } enhanceConfigurationClasses(beanFactory); beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory)); } 点击进processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);: public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) { List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;(); String[] candidateNames = registry.getBeanDefinitionNames(); // 获取@Configuration class的Bean定义信息 for (String beanName : candidateNames) { BeanDefinition beanDef = registry.getBeanDefinition(beanName); if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) { if (logger.isDebugEnabled()) { logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef); } } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) { configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); } } // Return immediately if no @Configuration classes were found if (configCandidates.isEmpty()) { return; } // Sort by previously determined @Order value, if applicable configCandidates.sort((bd1, bd2) -&gt; { int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition()); int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition()); return Integer.compare(i1, i2); }); // Detect any custom bean name generation strategy supplied through the enclosing application context SingletonBeanRegistry sbr = null; if (registry instanceof SingletonBeanRegistry) { sbr = (SingletonBeanRegistry) registry; if (!this.localBeanNameGeneratorSet) { BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton( AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR); if (generator != null) { this.componentScanBeanNameGenerator = generator; this.importBeanNameGenerator = generator; } } } if (this.environment == null) { this.environment = new StandardEnvironment(); } // Parse each @Configuration class // 构造处理@Configuration类的解析器 ConfigurationClassParser parser = new ConfigurationClassParser( this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry); Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates); Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size()); do { // 开始解析@Configuration class parser.parse(candidates); parser.validate(); Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses()); configClasses.removeAll(alreadyParsed); // Read the model and create bean definitions based on its content if (this.reader == null) { this.reader = new ConfigurationClassBeanDefinitionReader( registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry()); } // 注册配置类的Bean定义信息 this.reader.loadBeanDefinitions(configClasses); alreadyParsed.addAll(configClasses); candidates.clear(); if (registry.getBeanDefinitionCount() &gt; candidateNames.length) { String[] newCandidateNames = registry.getBeanDefinitionNames(); Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames)); Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;(); for (ConfigurationClass configurationClass : alreadyParsed) { alreadyParsedClasses.add(configurationClass.getMetadata().getClassName()); } for (String candidateName : newCandidateNames) { if (!oldCandidateNames.contains(candidateName)) { BeanDefinition bd = registry.getBeanDefinition(candidateName); if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp; !alreadyParsedClasses.contains(bd.getBeanClassName())) { candidates.add(new BeanDefinitionHolder(bd, candidateName)); } } } candidateNames = newCandidateNames; } } while (!candidates.isEmpty()); // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) { sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry()); } if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) { // Clear cache in externally provided MetadataReaderFactory; this is a no-op // for a shared cache since it&#39;ll be cleared by the ApplicationContext. ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache(); } } 点击进parser.parse(candidates)： public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) { for (BeanDefinitionHolder holder : configCandidates) { BeanDefinition bd = holder.getBeanDefinition(); try { if (bd instanceof AnnotatedBeanDefinition) { // 使用annotation的bean进入这个方法进行解析 parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); } else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) { parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName()); } else { parse(bd.getBeanClassName(), holder.getBeanName()); } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex); } } this.deferredImportSelectorHandler.process(); } 点击进parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName())： protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException { processConfigurationClass(new ConfigurationClass(metadata, beanName)); } 点击进processConfigurationClass(new ConfigurationClass(metadata, beanName))，这个类会被递归调用处理配置类： protected void processConfigurationClass(ConfigurationClass configClass) throws IOException { // 是否需要跳过自动配置，配置的@Conditional就是在这个地方解析的，进去看看怎么解析的 if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) { return; } ConfigurationClass existingClass = this.configurationClasses.get(configClass); if (existingClass != null) { if (configClass.isImported()) { if (existingClass.isImported()) { existingClass.mergeImportedBy(configClass); } // Otherwise ignore new imported config class; existing non-imported class overrides it. return; } else { // Explicit bean definition found, probably replacing an import. // Let&#39;s remove the old one and go with the new one. this.configurationClasses.remove(configClass); this.knownSuperclasses.values().removeIf(configClass::equals); } } // Recursively process the configuration class and its superclass hierarchy. // 递归处理配置类及父类 SourceClass sourceClass = asSourceClass(configClass); do { sourceClass = doProcessConfigurationClass(configClass, sourceClass); } while (sourceClass != null); this.configurationClasses.put(configClass, configClass); } 点击进this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)： public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) { // 跳过不满足@Conditional注解的Bean if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) { return false; } if (phase == null) { if (metadata instanceof AnnotationMetadata &amp;&amp; ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) { return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION); } return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN); } // 获取bean上的conditional注解中的类条件 List&lt;Condition&gt; conditions = new ArrayList&lt;&gt;(); for (String[] conditionClasses : getConditionClasses(metadata)) { for (String conditionClass : conditionClasses) { Condition condition = getCondition(conditionClass, this.context.getClassLoader()); conditions.add(condition); } } AnnotationAwareOrderComparator.sort(conditions); for (Condition condition : conditions) { ConfigurationPhase requiredPhase = null; if (condition instanceof ConfigurationCondition) { requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase(); } if ((requiredPhase == null || requiredPhase == phase) &amp;&amp; !condition.matches(this.context, metadata)) { return true; } } return false; } 点击进getConditionClasses(metadata)去看看： private List&lt;String[]&gt; getConditionClasses(AnnotatedTypeMetadata metadata) { MultiValueMap&lt;String, Object&gt; attributes = metadata.getAllAnnotationAttributes(Conditional.class.getName(), true); Object values = (attributes != null ? attributes.get(&quot;value&quot;) : null); return (List&lt;String[]&gt;) (values != null ? values : Collections.emptyList()); } 点击进metadata.getAllAnnotationAttributes(Conditional.class.getName(), true)里面干了啥： default MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes( String annotationName, boolean classValuesAsString) { Adapt[] adaptations = Adapt.values(classValuesAsString, true); return getAnnotations().stream(annotationName) .filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes)) .map(MergedAnnotation::withNonMergedAttributes) .collect(MergedAnnotationCollectors.toMultiValueMap(map -&gt; map.isEmpty() ? null : map, adaptations)); } 这是AnnotatedTypeMetadata接口的一个默认方法，进入getAnnotations()方法： @Override public MergedAnnotations getAnnotations() { return this.annotations; } 这里返回的就是在xxxAutoConfiguration类上配置的注解信息了，比如说： @Configuration(proxyBeanMethods = false) @ConditionalOnMissingBean(name = &quot;demo&quot;, search = SearchStrategy.CURRENT) @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) @Conditional(Demo1.class) @EnableConfigurationProperties public class MyAutoConfiguration { ... } 那么获取到的就是MyAutoConfiguration类上的注解信息啦。然后在AnnotatedTypeMetadata#getAllAnnotationAttributes里会进行过滤，最终只会过滤出条件注解，这里列子的话就是@ConditionalOnMissingBean和@Conditional这两个。回到shouldSkip()中的getCondition()方法，这个方法干的事情就是对解析出来的条件类进行实例化，比如在MyAutoConfiguration中，就是对Demo.class进行实例化。再看看里面的condition.matches(this.context, metadata)方法，这个地方的matches有三个可选项： ConditionEvaluationReport.AncestorsMatchedCondition#matches 这个是报告condition日志信息的，不用管 ProfileCondition#matches 这个就比较重要了，会匹配@Profile注解，进行环境切换 SpringBootCondition#matches(ConditionContext, AnnotatedTypeMetadata) 重中之重了，这个是使用Spring Boot的所有Condition实现的基础，可以看到类中有个方法public abstract ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata);是个抽象类，实现这个方法，不就可以实现自己的条件注解了吗。而且你会发现对于@ConditionalXXX的注解大部分都会有OnXXXCondition条件类与之对应，那么通过这个对应关系不就可以找到对应的条件类了吗。找不到的就合为一个条件类啦，比如说：ConditionalOnBean和ConditionalOnMissingBean对应的就是OnBeanCondition 以上都实现了Condition接口： @FunctionalInterface public interface Condition { /** * Determine if the condition matches. * @param context the condition context * @param metadata metadata of the {@link org.springframework.core.type.AnnotationMetadata class} * or {@link org.springframework.core.type.MethodMetadata method} being checked * @return {@code true} if the condition matches and the component can be registered, * or {@code false} to veto the annotated component&#39;s registration */ boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata); } 当然啦，这个地方使用的就是SpringBootCondition#matches,进去看看： @Override public final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { String classOrMethodName = getClassOrMethodName(metadata); try { ConditionOutcome outcome = getMatchOutcome(context, metadata); logOutcome(classOrMethodName, outcome); recordEvaluation(context, classOrMethodName, outcome); return outcome.isMatch(); } catch (NoClassDefFoundError ex) { throw new IllegalStateException(&quot;Could not evaluate condition on &quot; + classOrMethodName + &quot; due to &quot; + ex.getMessage() + &quot; not found. Make sure your own configuration does not rely on &quot; + &quot;that class. This can also happen if you are &quot; + &quot;@ComponentScanning a springframework package (e.g. if you &quot; + &quot;put a @ComponentScan in the default package by mistake)&quot;, ex); } catch (RuntimeException ex) { throw new IllegalStateException(&quot;Error processing condition on &quot; + getName(metadata), ex); } } 不符合自动配置条件的就返回false，那么shouldSkip就会跳过，不进行自动配置了。回到ConfigurationClassParser#processConfigurationClass，看看其中的doProcessConfigurationClass(configClass, sourceClass)方法，点进去看看： protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException { if (configClass.getMetadata().isAnnotated(Component.class.getName())) { // Recursively process any member (nested) classes first // 首先递归处理嵌套的配置类 processMemberClasses(configClass, sourceClass); } // Process any @PropertySource annotations for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) { if (this.environment instanceof ConfigurableEnvironment) { processPropertySource(propertySource); } else { logger.info(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() + &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;); } } // Process any @ComponentScan annotations Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) { for (AnnotationAttributes componentScan : componentScans) { // The config class is annotated with @ComponentScan -&gt; perform the scan immediately Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed for (BeanDefinitionHolder holder : scannedBeanDefinitions) { BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition(); if (bdCand == null) { bdCand = holder.getBeanDefinition(); } if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) { parse(bdCand.getBeanClassName(), holder.getBeanName()); } } } } // Process any @Import annotations // 处理@Import，主要来看看这个 processImports(configClass, sourceClass, getImports(sourceClass), true); // Process any @ImportResource annotations AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); if (importResource != null) { String[] resources = importResource.getStringArray(&quot;locations&quot;); Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;); for (String resource : resources) { String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); configClass.addImportedResource(resolvedResource, readerClass); } } // Process individual @Bean methods Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass); for (MethodMetadata methodMetadata : beanMethods) { configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); } // Process default methods on interfaces processInterfaces(configClass, sourceClass); // Process superclass, if any if (sourceClass.getMetadata().hasSuperClass()) { String superclass = sourceClass.getMetadata().getSuperClassName(); if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) { this.knownSuperclasses.put(superclass, configClass); // Superclass found, return its annotation metadata and recurse return sourceClass.getSuperClass(); } } // No superclass -&gt; processing is complete return null; } 看到其中的@PropertySource、@ComponentScan等，惊不惊喜，意不意外！解析都在这里面了！点进processImports(configClass, sourceClass, getImports(sourceClass), true)去看看： private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) { if (importCandidates.isEmpty()) { return; } if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) { this.problemReporter.error(new CircularImportProblem(configClass, this.importStack)); } else { this.importStack.push(configClass); try { for (SourceClass candidate : importCandidates) { if (candidate.isAssignable(ImportSelector.class)) { // Candidate class is an ImportSelector -&gt; delegate to it to determine imports Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); if (selector instanceof DeferredImportSelector) { this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector); } else { // 调用XXXSelector的selectImports方法，点进去 String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames); processImports(configClass, currentSourceClass, importSourceClasses, false); } } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) { // Candidate class is an ImportBeanDefinitionRegistrar -&gt; // delegate to it to register additional bean definitions Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportBeanDefinitionRegistrar registrar = ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry); configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); } else { // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt; // process it as an @Configuration class this.importStack.registerImport( currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); processConfigurationClass(candidate.asConfigClass(configClass)); } } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to process import candidates for configuration class [&quot; + configClass.getMetadata().getClassName() + &quot;]&quot;, ex); } finally { this.importStack.pop(); } } } 点击进去看看，发现会有很多的XXXSelector，因为我们看的是自动配置，所以呢，选择AutoConfigurationImportSelector#selectImports进去看看。 public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); // 主要来看看这个方法干啥的 AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } 我嘞个去，是不是很熟悉，之前讲解@EnableAutoConfiguration是不是说过，再粘下代码： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { ... } 好了，现在来看看getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata);这个方法干啥的： protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } // 加载自动配置类的元数据信息 AnnotationAttributes attributes = getAttributes(annotationMetadata); // 获取自动配置类的全限定名 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } 点进getCandidateConfigurations(annotationMetadata, attributes)去看看： protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { // 加载自动配置类的全限定类名 List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot; + &quot;are using a custom packaging, make sure that file is correct.&quot;); return configurations; } 点进getSpringFactoriesLoaderFactoryClass()看看： protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() { return EnableAutoConfiguration.class; } 这不就是启动自动配置的注解吗？拿这个干什么呢？回到上一步，点进SpringFactoriesLoader.loadFactoryNames去看看： public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) { String factoryTypeName = factoryType.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList()); } private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) { MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) { return result; } try { Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); while (urls.hasMoreElements()) { URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) { String factoryTypeName = ((String) entry.getKey()).trim(); for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) { result.add(factoryTypeName, factoryImplementationName.trim()); } } } cache.put(classLoader, result); return result; } catch (IOException ex) { throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; + FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex); } } 看到下面的loadSpringFactories方法中有一个FACTORIES_RESOURCE_LOCATION： public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;; 这不就是个文件么，干什么的，来看看： org.springframework.boot.autoconfigure.EnableAutoConfiguration这个KEY下的自动配置不止图片的这点，还有很多，可以点进去看看！看到这里呢，是不是就明白了。这个spring.factories就是用来配置自动配置类的。也就是说，只要在项目的META-INF/spring.factories中配置上自定义的自动配置类，那么Spring Boot启动的时候，就可以给你做自动配置的事情了！回到getAutoConfigurationEntry方法： protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); // 获取自动配置类的全限定类名 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); // 去重复的自动配置类 configurations = removeDuplicates(configurations); // 返回需要排除的自动配置类 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); // 检查需要排除的自动配置是否存在 checkExcludedClasses(configurations, exclusions); // 移出自动配置类 configurations.removeAll(exclusions); // 按照自动配置类上配置的@ConditionalXXX条件进行过滤 // 使用spring.factories文件中org.springframework.boot.autoconfigure.AutoConfigurationImportFilter对应的过滤器进行过滤。有三个过滤器： // org.springframework.boot.autoconfigure.condition.OnBeanCondition // org.springframework.boot.autoconfigure.condition.OnClassCondition // org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition // 分别调用过滤器中match方法过滤出符合条件的自动配置类 configurations = filter(configurations, autoConfigurationMetadata); // 发布自动配置事件 // 使用spring.factories文件中org.springframework.boot.autoconfigure.AutoConfigurationImportListener对应的监听器org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener发送AutoConfigurationImportEvent事件 fireAutoConfigurationImportEvents(configurations, exclusions); // 返回包含已创建和已排除的自动配置实体 return new AutoConfigurationEntry(configurations, exclusions); } 回到processImports方法： private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) { if (importCandidates.isEmpty()) { return; } if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) { this.problemReporter.error(new CircularImportProblem(configClass, this.importStack)); } else { this.importStack.push(configClass); try { for (SourceClass candidate : importCandidates) { if (candidate.isAssignable(ImportSelector.class)) { // Candidate class is an ImportSelector -&gt; delegate to it to determine imports Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); if (selector instanceof DeferredImportSelector) { this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector); } else { String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames); processImports(configClass, currentSourceClass, importSourceClasses, false); } } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) { // Candidate class is an ImportBeanDefinitionRegistrar -&gt; // delegate to it to register additional bean definitions Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportBeanDefinitionRegistrar registrar = ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry); configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); } else { // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt; // process it as an @Configuration class this.importStack.registerImport( currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); processConfigurationClass(candidate.asConfigClass(configClass)); } } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to process import candidates for configuration class [&quot; + configClass.getMetadata().getClassName() + &quot;]&quot;, ex); } finally { this.importStack.pop(); } } } processImports方法会被递归调用，直到所有的配置类处理完毕。然后在ConfigurationClassPostProcessor#processConfigBeanDefinitions方法中，就会调用this.reader.loadBeanDefinitions(configClasses)注册Bean的定义信息。最后在refresh()方法中调用finishBeanFactoryInitialization(beanFactory)方法实例化Bean。到此自动配置的源码分析就结束啦，最后来一个图总结一下大概流程：","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"Springboot核心注解","slug":"tech-springboot-annotation","date":"2019-10-21T03:00:00.000Z","updated":"2019-10-23T14:33:42.111Z","comments":true,"path":"2019/10/21/tech-springboot-annotation/","link":"","permalink":"/2019/10/21/tech-springboot-annotation/","excerpt":"","text":"在开始介绍Springboot自动配置之前，来看看Springboot有哪些最核心的注解。继续Springboot开胃菜，打开SpringbootWebApplication类后，发现该类上有且只有一个注解@SpringBootApplication，来看看这个是注解所包含的意思：@SpringBootApplication 这是一个便捷的组合注解，使用该注解意味着： 启用配置@SpringBootConfiguration 触发自动配置@EnableAutoConfiguration 组件扫描@ComponentScan 配置属性扫描@ConfigurationPropertiesScan 一个个来看看都是啥意思： @SpringBootConfiguration 用于加载Springboot应用所需要的配置，并且标注当前类是配置类，将配置类中声明的一个或是多个已@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。该注解在Springboot应用中可以使用来替代@Configuration，这样的话，在自动配置的时候，就可以被自动发现了，该注解本身就组合了@Configuration注解。Springboot应用有且只能包含一个@SpringBootConfiguration注解。 @EnableAutoConfiguration 这个是核心中的核心注解啦！使用该注解表示开启自动配置功能，spring应用上下文就会试着去猜测并且配置你所期望的bean。其实就是将所有符合@Conditional注解的配置类加载到Springboot创建的容器中。自动配置类是基于你的classpath和你定义了什么样的bean而被应用。比如说：在你的类路径下有tomcat-embedded.jar，那就意味着你希望有一个TomcatServletWebServerFactory，除非你自己定义了TomcatServletWebServerFactorybean。使用@SpringBootApplication意味着自动配置自动生效，如果有你不需要的配置，可以使用#excludeName()进行排除。自动配置的类通常都是Spring@Configuration的bean，这些bean通过使用SpringFactoriesLoader机制定位。通常自动配置类都是@Conditional的beans(大多数使用@ConditionalOnClass和@ConditionalOnMissingBean注解)。在注解上包含了两个注解： AutoConfigurationPackage 存储自动配置的包，在该包下的bean都会被注册 @Import(AutoConfigurationPackages.Registrar.class) 通过这个注解去存储基础包及注册bean的定义 @Import(AutoConfigurationImportSelector.class) 这就是自动配置的核心啦，所有的自动配置类通过这个导入进来，那么它是在哪里被调用，以及自动配置bean怎么配置进来的，留待后面分析。 @ComponentScan 这个是组件扫描，可以配置组件扫描的基础包以及过滤器，加载符合条件的组件或Bean的定义，最终将这些Bean加载到容器中。Spring框架默认以Springboot启动类所在的包为basePackage进行扫描，当然也可以通过basePackage等属性自定义扫描范围。 @ConfigurationPropertiesScan 指定扫描@ConfigurationProperties类的基础包 @Import(ConfigurationPropertiesScanRegistrar.class) 通过扫描使用ImportBeanDefinitionRegistrar注册@ConfigurationPropertiebean定义 @EnableConfigurationProperties 对带有@ConfigurationProperties注解的bean都可以使用标准的方式被注册，比如说使用@Bean方式 @Import(EnableConfigurationPropertiesRegistrar.class) 对带有@EnableConfigurationProperties的类使用ImportBeanDefinitionRegistrar进行注册 这些注解在项目里都可以点进去看看，熟悉一下，对自动配置的解析有帮助，要不然会感到有点懵！最后，我们再用一个图来总结下，标红的是核心中的核心，需要重点关注的地方：","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"Springboot开胃菜","slug":"tech-springboot-introduction","date":"2019-10-19T07:00:00.000Z","updated":"2019-10-22T15:09:53.027Z","comments":true,"path":"2019/10/19/tech-springboot-introduction/","link":"","permalink":"/2019/10/19/tech-springboot-introduction/","excerpt":"","text":"我们在学习某一知识之前，总得清楚它是干什么的（What），怎么干（How），为什么这么干（Why），对它发出来自灵魂的三拷问。来看看官网介绍： 一、Introducing Spring BootSpring Boot makes it easy to create stand-alone, production-grade Spring-based Applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. You can use Spring Boot to create Java applications that can be started by using java -jar or more traditional war deployments. We also provide a command line tool that runs “spring scripts”. Our primary goals are: Provide a radically faster and widely accessible getting-started experience for all Spring development. Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults. Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration). Absolutely no code generation and no requirement for XML configuration. 明白没？不明白？那我就用我这三级都没过的英语水平简单的翻译下： Spring boot 使得创建以及运行基于单机版或生产级别得spring应用变得很简单。我们提出了spring平台和第三库的观点，使得你可以以最小得代价去开始干你想干得事情。而且对于大部分Spring Boot应用程序仅仅需要很少的配置就可以运行。 你可以使用Spring Boot去创建Java引用，并且以java -jar或是传统部署war包的方式运行。我们也提供了在命令行以&quot;spring scripts&quot;的方式运行 我们的重要目标是： 对于所有的Spring开发从根本上提供一个更快速且可广泛地容易访问的入门体验 开箱即用 给一系列大型项目提供通用的非功能性特性（例如嵌入式服务器、安全性、指标、运行状况检查和外部化配置） 绝对的无需代码生成和XML配置 还没明白？自行Google去吧！！！下面可以不用翻译了。 二、System RequirementsSpring Boot 2.2.0.RELEASE requires Java 8 and is compatible up to Java 13 (included). Spring Framework 5.2.0.RELEASE or above is also required. Explicit build support is provided for the following build tools: Build Tool Version Maven 3.3+ Gradle 5.x (4.10 is also supported but in a deprecated form) Spring Boot supports the following embedded servlet containers: Name Servlet Version Tomcat 9.0 4.0 Jetty 9.4 3.1 Undertow 2.0 4.0 You can also deploy Spring Boot applications to any Servlet 3.1+ compatible container. 三、Installing Spring Boot1、Installation Instructions for the Java Developer对于开发者来说的话，主要有下面两种方式：a、Maven Installation使用maven前，需要先配置好maven的环境。典型的说，你的Maven POM文件会继承spring-boot-starter-parent project并且会声明一个或者多个starters。一个典型的pom.xml文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; b、Gradle InstallationGradle没用过，自行看文档吧！ 1、Installing the Spring Boot CLIThe Spring Boot CLI (Command Line Interface) is a command line tool that you can use to quickly prototype with Spring. It lets you run Groovy scripts, which means that you have a familiar Java-like syntax without so much boilerplate code. You do not need to use the CLI to work with Spring Boot, but it is definitely the quickest way to get a Spring application off the ground. Spring Boot CLI 是一个命令行工具，在我们使用Spring Boot的工作中并不需要使用CLI。 四、Developing Your First Spring Boot ApplicationThis section describes how to develop a simple “Hello World!” web application that highlights some of Spring Boot’s key features. We use Maven to build this project, since most IDEs support it.这个部分演示怎么使用maven部署一个简单的&quot;Hello World&quot;web应用，大部分IDEs都支持使用maven Before we begin, open a terminal and run the following commands to ensure that you have valid versions of Java and Maven installed:开始之前要确认Java和Maven已安装好 $ java -version java version &quot;1.8.0_102&quot; Java(TM) SE Runtime Environment (build 1.8.0_102-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode) $ mvn -v Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-17T14:33:14-04:00) Maven home: /usr/local/Cellar/maven/3.3.9/libexec Java version: 1.8.0_102, vendor: Oracle Corporation This sample needs to be created in its own folder. Subsequent instructions assume that you have created a suitable folder and that it is your current directory.也就是说，需要创建一个文件夹，并且当前的路径是在你创建的文件下 1、Creating the POMWe need to start by creating a Maven pom.xml file. The pom.xml is the recipe that is used to build your project. Open your favorite text editor and add the following:使用喜爱的编辑工具创建一个pom.xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Additional lines to be added here... --&gt; &lt;/project&gt; 2、Adding Classpath DependenciesSpring Boot提供了很多的”Starters”，让你可以把jars添加到classpath下。我们在POM中的parent部分添加了spring-boot-starter-parent，spring-boot-starter-parent是一个特殊的starter，它提供了dependency-management，因此我们在依赖中可以踢出version标签。这个地方我们以添加spring-boot-starter-web为列： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、Writing the CodeTo finish our application, we need to create a single Java file. By default, Maven compiles sources from src/main/java, so you need to create that folder structure and then add a file named src/main/java/Example.java to contain the following code:maven默认是在src/main/java/下编译源文件的，因此需要将Example.java类文件添加到src/main/java/目录下 import org.springframework.boot.*; import org.springframework.boot.autoconfigure.*; import org.springframework.web.bind.annotation.*; @RestController @EnableAutoConfiguration public class Example { @RequestMapping(&quot;/&quot;) String home() { return &quot;Hello World!&quot;; } public static void main(String[] args) { SpringApplication.run(Example.class, args); } } @RestController和@RequestMapping是SpringMVC的注解！@EnableAutoConfiguration这是一个对于Spring Boot来说，很核心的一个注解，我们后面再说。 4、Running the ExampleAt this point, your application should work. Since you used the spring-boot-starter-parent POM, you have a useful run goal that you can use to start the application. Type mvn spring-boot:run from the root project directory to start the application. You should see output similar to the following:在项目根目录执行mvn spring-boot:run，就可以看到输出日志 $ mvn spring-boot:run . ____ _ __ _ _ /\\\\ / ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) ....... . . . ....... . . . (log output here) ....... . . . ........ Started Example in 2.222 seconds (JVM running for 6.514) If you open a web browser to localhost:8080, you should see the following output: Hello World! To gracefully exit the application, press ctrl-c。 5、Creating an Executable JarTo create an executable jar, we need to add the spring-boot-maven-plugin to our pom.xml. To do so, insert the following lines just below the dependencies section:在pom文件中添加如下依赖 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; Notice：The spring-boot-starter-parent POM includes &lt;executions&gt;configuration to bind the repackage goal. If you do not use the parent POM, you need to declare this configuration yourself. See the plugin documentation for details.spring-boot-starter-parent包含了&lt;executions&gt;并且绑定了repackage构建，因此我们直接加上上面的依赖就可以了。如果你没有使用parent Pom的话呢，就需要自己声明构建配置了 Save your pom.xml and run mvn package from the command line, as follows: $ mvn package [INFO] Scanning for projects... [INFO] [INFO] ------------------------------------------------------------------------ [INFO] Building myproject 0.0.1-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO] .... .. [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject --- [INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar [INFO] [INFO] --- spring-boot-maven-plugin:2.2.0.RELEASE:repackage (default) @ myproject --- [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ If you look in the target directory, you should see myproject-0.0.1-SNAPSHOT.jar. The file should be around 10 MB in size. If you want to peek inside, you can use jar tvf, as follows:在target目录中可以看到myproject-0.0.1-SNAPSHOT.jar文件，使用jar tvf可以查看文件内部的详细信息 $ jar tvf target/myproject-0.0.1-SNAPSHOT.jar You should also see a much smaller file named myproject-0.0.1-SNAPSHOT.jar.original in the target directory. This is the original jar file that Maven created before it was repackaged by Spring Boot.在target目录中还可以看到一个myproject-0.0.1-SNAPSHOT.jar.original文件，它是maven在使用Spring Boot打包之前创建的jar源文件 To run that application, use the java -jar command, as follows: $ java -jar target/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\\\ / ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) ....... . . . ....... . . . (log output here) ....... . . . ........ Started Example in 2.536 seconds (JVM running for 2.864) As before, to exit the application, press ctrl-c. 到此为止呢，Spring Boot的灵魂三问已经清楚了。但是发现一个问题，手动去写POM，然后创建类文件，这么简单工程还好，那么复杂的工程的呢，这个过程就很痛苦了啊。那么我们来看看使用工具怎么创建Spring Boot工程，这里使用Idea为例，其他的IDEs类似，就不用说了哈！ 五、Develop Spring Boot Aplication With IDEA1、初始化Spring Boot项目打开Idea，左上角依次：file -&gt; new -&gt; project在弹出框中左侧菜单中选择Spring Initializr后，在右侧配置SDK版本，下面选择Default就行了，然后next配置project，然后next选择需要整合的web中间件，这里有很多的中间可选，可以都看看，后面将要介绍的一些中间件也在里面（如：eureka），然后next配置项目存储路径，Finish后，来看下目录结构：到这里，你就可以直接启动了： . ____ _ __ _ _ /\\\\ / ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) 2019-10-19 17:27:49.228 INFO 33267 --- [ main] c.s.s.SpringbootWebApplication : Starting SpringbootWebApplication on bogon with PID 33267 (/Users/dingzhongshen/SelfProjects/springblog/springboot-web/target/classes started by dingzhongshen in /Users/dingzhongshen/SelfProjects/springblog/springboot-web) 2019-10-19 17:27:49.232 INFO 33267 --- [ main] c.s.s.SpringbootWebApplication : No active profile set, falling back to default profiles: default 2019-10-19 17:27:50.389 INFO 33267 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 2019-10-19 17:27:50.398 INFO 33267 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2019-10-19 17:27:50.399 INFO 33267 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.27] 2019-10-19 17:27:50.469 INFO 33267 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2019-10-19 17:27:50.469 INFO 33267 --- [ main] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1150 ms 2019-10-19 17:27:50.631 INFO 33267 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService &#39;applicationTaskExecutor&#39; 2019-10-19 17:27:50.816 INFO 33267 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &#39;&#39; 2019-10-19 17:27:50.819 INFO 33267 --- [ main] c.s.s.SpringbootWebApplication : Started SpringbootWebApplication in 2.547 seconds (JVM running for 5.328) 看到上面日志Tomcat started on port(s): 8080，就表示Spring Boot项目已经初始化并启动成功了。是不是很简单，开箱即用嘛！！！当然啦，我们要做的事情，可不止这么多，接下来写个Controller试试。 2、配置Spring Boot在resources目录下，有个application.properties文件，我喜欢改成application.yml。然后就可以在这个文件中配置需要的属性啦，比如将服务端口号改成8081： server: port: 8081 启动应用之后，就可以在日志里看到端口被改成： o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8081 (http) with context path &#39;&#39; context path也是可以进行配置的。在使用spring boot的时候，需要集成一些其他的中间件，它们的属性都配置在这里，那他们有什么样的属性，怎么看呢？别急，后面介绍！ 3、编写逻辑，加入相应的启动注解启动之后，在浏览器流输入http://localhost:8080/，就可以看到效果啦，是不是很酷： Hello World! Bingo！！！恭喜你，已经初步掌握Spring Boot啦！上面已经包含了springboot整合中间件的过程，不知道你发现没，没有？不急，后面再说！现在你就只需要知道，使用Spring Boot无非就这么 三板斧 就行了！","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"博客首篇","slug":"thought-introduction","date":"2019-10-18T10:08:08.000Z","updated":"2019-11-01T14:13:47.243Z","comments":true,"path":"2019/10/18/thought-introduction/","link":"","permalink":"/2019/10/18/thought-introduction/","excerpt":"","text":"前因那是在很久很久以前，总觉得写博客很浪费时间（其实现在也这么觉得，哈哈哈），不需要去写博客，有什么问题或是需要学习什么知识，直接官网或是Google或是度娘不就行了吗，来得多快呢。也总相信自己能够记住自己学习的东西，不需要去记笔记。然后呢，每次学习知识或是遇到问题都去官网或是Google或是度娘，乐此不疲。其实这是一个严重的问题，自己却不以为意或是没有察觉。但是，时间一长，这个问题就会逐渐暴露出来：学习的东西有自己的理解和感悟，但是没有总结出来，很零散，没有自己的知识结构，形成不了自己的知识体系！因为越往后，自己就会觉得自己怎么突然什么都不会了，怎么什么都想不起来了，知识更新迭代那么快，自己怎么跟不上了呢（也许有那么一部分凤毛棱角的人不会这么觉得）？学习的东西，在工作中并不是都会用到，不做笔记，总会有忘记的时候，好记性不如烂笔头（祖先的智慧结晶）。理解的东西或是会的东西忘记了怎么办呢？官网或是Google或是度娘再来几遍？如此往复吗？记不住又不喜欢花点时间总结成自己的东西记下来，越往后，不觉得自己相比与其他人来说，学习新东西的时候越来越慢了吗，不会觉得自己跟不上知识的更新迭代了吗？能找回来最好，但是每次都会花费比较多的时间，可能就要落后咯。一时的感悟或是理解可能就找不回来咯！所以呢，还是要记记笔记滴，杂七杂八的记呗！ 经过先前也看过一些博客，不是很简洁，总会有很多除了博客内容之外的其他的一些东西（不举例了哈），想着自己去搞一个，不过对于只会后端的我来说，挑战性是何其大。然后发现了Hexo和Hugo，两者我选择了Hexo，可能是主题比较多吧（哈哈哈）。正好那段时间正在学习Python，那干脆前端用Hexo的主题（我把Hexo的页面给摘出来了，费着劲自己干），然后后端用Python的web框架Django，DB用MongoDB。然后就开干了，正当快把网站搞好的时候，我就去某大厂了，后面就没有时间再搞。 直到最近总想着把之前的博客搞起来。是选择之前自己搞的网站呢，还是直接使用Hexo搭建呢？从时间就是金钱的角度，我先选择直接使用Hexo搭建起来，后续再做打算也不迟。于是呢，就有了现在的多多博客。 结果通过这个博客，壮着胆子把常用的一些主流框架的学习总结起来，形成自己的知识结构体系。与此同时也可以记录自己生活的点点滴滴，反正就是杂七杂八的呗！","categories":[{"name":"thought","slug":"thought","permalink":"/categories/thought/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"}],"keywords":[{"name":"thought","slug":"thought","permalink":"/categories/thought/"}]}]}