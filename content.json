{"meta":{"title":"DuoDuo","subtitle":null,"description":"好少年光芒万丈","author":"duoduo","url":""},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-10-19T13:56:24.456Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-10-19T13:56:24.456Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[爱思考のduoduo] 与&nbsp; duoduo&nbsp; （ 真情告白 ） 对话中... bot_ui_ini()","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-10-19T13:56:24.456Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-10-19T13:56:24.456Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-10-19T13:56:24.457Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-10-19T13:56:24.457Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-10-19T13:56:24.457Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"自定义Springboot的Starter","slug":"tech-springboot-custstarter","date":"2019-10-24T10:30:00.000Z","updated":"2019-10-25T14:08:08.479Z","comments":true,"path":"2019/10/24/tech-springboot-custstarter/","link":"","permalink":"/2019/10/24/tech-springboot-custstarter/","excerpt":"","text":"理解了Springboot自动配置原理后呢，来看看怎么自定义一个starter。Starter的命名也是有一定的规范的，官方说的是：spring-boot-starter-xxx被官方保留使用啦，第三方自定义就使用xxx-spring-boot-starter。 自定义Springboot Starter怎么初始化一个项目，请看这里吧！1、使用Idea初始化一个没有整合任何中间件的项目，也就是说在使用工具中的Spring Initializr初始化项目的时候，在选择中间件依赖的时候，啥也不选直接next。这里就初始化一个叫hello-spring-boot-starter的项目 2、在初始化出来的项目中，把生成的包及其中的类删掉，然后新建自己的包。 3、新建com.springboot.hello.marker包，这个包用于条件注解用，也就是说，自定义的自动配置必须在有这个类的前提下，自动配置才能生效。 public class Marker { } 4、新建com.springboot.hello.service包，用于写业务逻辑： public class HelloStarterService { public String helloStarter() { return &quot;WOW！Hello starter is working...&quot;; } } 5、新建 com.springboot.hello.autoconfig包，在其中编写自动配置类： @Configuration(proxyBeanMethods = false) @ConditionalOnClass(Marker.class) public class HelloStarterAutoConfiguration { @Bean public HelloStarterService getHelloStarterService() { return new HelloStarterService(); } } 如果业务逻辑中需要属性配置，还可以在类上加上@EnableConfigurationProperties({xxxProperties.class})，也可以在类上使用@EnableConfigurationProperties启用属性配置后，在方法上使用@ConfigurationProperties(prefix = &quot;xxx.xxx&quot;)进行配置，也可以加上其他的条件注解@ConditionalXXX进行更复杂的配置。 6、在resources包下新建META-INF/spring.factories文件，在其中写上自动配置类： # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.springboot.hello.autoconfig.HelloStarterAutoConfiguration 7、在打包之前删除pom.xml中的这段配置，否则回报找不到main类的错误： &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 8、在我们之前的springboot-web项目的pom.xml中引入这个starter： &lt;dependency&gt; &lt;groupId&gt;com.springboot&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 然后我们在项目的application.yml文件中打开debug： server: port: 8081 debug: true 上面的端口号，是之前改的，后面访问的时候就使用这个端口！ 9、在Helloworld.java中加入在自动配置类中写的HelloStarterService，这个地方不需要去实例化，就可以拿到接口HelloStarterService的实例，自动配置已经帮我们搞好了，直接用就行了。 @RestController public class Helloworld { @Autowired private HelloStarterService helloStarterService; @RequestMapping public String helloworld() { return &quot;hello world&quot;; } @RequestMapping(&quot;/helloStarter&quot;) public String helloStarter() { return helloStarterService.helloStarter(); } } 启动一下，见证奇迹的时刻。在启动后的日志中发现，自定义的自动配置类已经生效了： ============================ CONDITIONS EVALUATION REPORT ============================ Positive matches: ----------------- ... ... HelloStarterAutoConfiguration matched: - @ConditionalOnClass found required class &#39;com.springboot.hello.marker.Marker&#39; (OnClassCondition) ... ... Negative matches: ----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class &#39;javax.jms.ConnectionFactory&#39; (OnClassCondition) ... ... Positive matches是自动配置生效的，Negative matches是自动配置没有生效的。如果我们的自动配置没有生效会不会出现在Negative matches中呢，把自动配置中的条件稍微改一下，来看看： @Configuration(proxyBeanMethods = false) @ConditionalOnBean(Marker.class) public class HelloStarterAutoConfiguration { @Bean public HelloStarterService getHelloStarterService() { return new HelloStarterService(); } } 把条件改成了@ConditionalOnBean(Marker.class)，由于在Spring context环境中是不存在Marker类实例的，所以自动配置是不会生效的，重新打包，reimport一下maven依赖，然后启动springboot-web项目后，会看到这样的输出日志： *************************** APPLICATION FAILED TO START *************************** Description: Field helloStarterService in com.springboot.springbootweb.controller.Helloworld required a bean of type &#39;com.springboot.hello.service.HelloStarterService&#39; that could not be found. The injection point has the following annotations: - @org.springframework.beans.factory.annotation.Autowired(required=true) The following candidates were found but could not be injected: - Bean method &#39;getHelloStarterService&#39; in &#39;HelloStarterAutoConfiguration&#39; not loaded because @ConditionalOnBean (types: com.springboot.hello.marker.Marker; SearchStrategy: all) did not find any beans of type com.springboot.hello.marker.Marker Action: Consider revisiting the entries above or defining a bean of type &#39;com.springboot.hello.service.HelloStarterService&#39; in your configuration. 自动配置失效，属性注入失败，应用启动失败！把helloStarterService这个属性注释掉： @RestController public class Helloworld { // @Autowired // private HelloStarterService helloStarterService; @RequestMapping public String helloworld() { return &quot;hello world&quot;; } @RequestMapping(&quot;/helloStarter&quot;) public String helloStarter() { // return helloStarterService.helloStarter(); return null; } } 再启动下，服务正常启动后看看日志： ============================ CONDITIONS EVALUATION REPORT ============================ Positive matches: ----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class &#39;org.springframework.web.servlet.DispatcherServlet&#39; (OnClassCondition) - found &#39;session&#39; scope (OnWebApplicationCondition) ... ... Negative matches: ----------------- ... ... HelloStarterAutoConfiguration: Did not match: - @ConditionalOnBean (types: com.springboot.hello.marker.Marker; SearchStrategy: all) did not find any beans of type com.springboot.hello.marker.Marker (OnBeanCondition) ... ... 预料之中，对吧！通个这个日志就可以知道自定义的自动配置类有没有生效啦！OK！我们去掉helloStarterService属性及方法中的注释，将Starter中的@ConditionalOnBean改回@ConditionalOnClass，重新打包后，在项目中reimport一下项目依赖，让项目重新正常启动起来。 10、在浏览器中输入：http://localhost:8081/helloStarter后，可以看到： WOW！hello starter is working... 到此呢，自定义Springboot Starter就搞定了。再来总结下步骤： 初始化一个starter项目 编写业务逻辑 编写自动配置类及配置相应的配置 将自动配置类加入到META-INF/spring.factories文件中 打包starter 在项目中引用","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"Springboot自动配置原理解析","slug":"tech-springboot-autoconfig","date":"2019-10-23T02:00:00.000Z","updated":"2019-10-24T13:10:49.497Z","comments":true,"path":"2019/10/23/tech-springboot-autoconfig/","link":"","permalink":"/2019/10/23/tech-springboot-autoconfig/","excerpt":"","text":"有了Springboot核心注解的基础之后呢，来看看Springboot是怎么实现自动配置的？首先，来看看启动类： @SpringBootApplication public class SpringbootWebApplication { public static void main(String[] args) { SpringApplication.run(SpringbootWebApplication.class, args); } } 从run方法进去，直到以下代码： public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) { // 资源加载器 this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); // WEB类型推断 // 由于我们在POM里引入了spring-boot-starter-web,所以类型推断后： // this.webApplicationType = WebApplicationType.SERVLET // 也就说会启动一个SERVLET容器 this.webApplicationType = WebApplicationType.deduceFromClasspath(); // 获取并设置应用的初始化器：用于在refresh（ConfigurableApplicationContext#refresh）之前初始化Spring的回调接口(ApplicationContextInitializer#initialize) setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // 获取并设置应用程序监听器：从3.0开始，一个ApplicationListener可以声明感兴趣的事件类型。当事件被注册到Spring ApplicationContext时，事件会被相应地过滤，并且监听器仅调用匹配的监听事件（事件这个地方会花个章节来说一下） setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 推断运行的主类，这个地方就是上面编写的：SpringbootWebApplication this.mainApplicationClass = deduceMainApplicationClass(); } 上面这段代码，就是为后面运行springboot做好准备。接着往下到run方法： // 运行Spring application，创建并且刷新一个新的ApplicationContext public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); // headless属性设置不用管 configureHeadlessProperty(); // 加载SpringApplication运行时的监听器，此时会获得一个：EventPublishingRunListener SpringApplicationRunListeners listeners = getRunListeners(args); // 广播ApplicationStartingEvent事件 listeners.starting(); try { // 默认ApplicationArguments的实现，用于配置环境 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 因为之前的类型推断是SERVLET，所以会准备一个StandardServletEnvironment的环境，然后配置propertySource、profile等，然后会通过EventPublishingRunListener将该事件广播出去后，将环境绑定到SpringApplication ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 设置调用JavaBean的时候让Spring使用Introspector#IGNORE_ALL_BEANINFO模式，这个就不管了 configureIgnoreBeanInfo(environment); // 控制台的banner哪里来的，就是这里打印的啦！ // banner可以自定义，可以是图片或是text，当然两个都有，也可以打印 Banner printedBanner = printBanner(environment); // 因为之前的类型推断是SERVLET，所以会创建一个AnnotationConfigServletWebServerApplicationContext context = createApplicationContext(); // 错误分析的，会得到一个：FailureAnalyzers exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); // context环境设置，转换器和格式化设置，应用Initializers，Bean定义加载等 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 核心方法啦，进去之后呢，你会发现是Spring的refresh方法，顿时是不是就熟悉啦 refreshContext(context); // 这是个空方法 afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); } // 广播ApplicationStartedEvent事件 listeners.started(context); // 没发现有啥用 callRunners(context, applicationArguments); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); } try { // 广播ApplicationReadyEvent事件 listeners.running(context); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); } return context; } 从refreshContext(context)进去，直到refresh(): @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. // 调用在context中注册为Bean的工厂处理器，自动配置的核心所在 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 实例化Bean（非懒加载） finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &#39;active&#39; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring&#39;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } 自动配置的核心方法，下面一步步来，看看这个核心方法里都在干啥： protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } } 点击进PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())： public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) { // Invoke BeanDefinitionRegistryPostProcessors first, if any. Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;(); if (beanFactory instanceof BeanDefinitionRegistry) { BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;(); List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;(); for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) { if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) { BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; registryProcessor.postProcessBeanDefinitionRegistry(registry); registryProcessors.add(registryProcessor); } else { regularPostProcessors.add(postProcessor); } } // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! // Separate between BeanDefinitionRegistryPostProcessors that implement // PriorityOrdered, Ordered, and the rest. List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;(); // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear. boolean reiterate = true; while (reiterate) { reiterate = false; postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (!processedBeans.contains(ppName)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); reiterate = true; } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); } // Now, invoke the postProcessBeanFactory callback of all processors handled so far. invokeBeanFactoryPostProcessors(registryProcessors, beanFactory); invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); } else { // Invoke factory processors registered with the context instance. invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory); } // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); // Separate between BeanFactoryPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;(); for (String ppName : postProcessorNames) { if (processedBeans.contains(ppName)) { // skip - already processed in first phase above } else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { orderedPostProcessorNames.add(ppName); } else { nonOrderedPostProcessorNames.add(ppName); } } // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); // 调用工厂处理器，进入到这个方法 invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory); // Next, invoke the BeanFactoryPostProcessors that implement Ordered. List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size()); for (String postProcessorName : orderedPostProcessorNames) { orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); } sortPostProcessors(orderedPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory); // Finally, invoke all other BeanFactoryPostProcessors. List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size()); for (String postProcessorName : nonOrderedPostProcessorNames) { nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); } invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); // Clear cached merged bean definitions since the post-processors might have // modified the original metadata, e.g. replacing placeholders in values... beanFactory.clearMetadataCache(); } 点击进invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory): private static void invokeBeanFactoryPostProcessors( Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory) { for (BeanFactoryPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeanFactory(beanFactory); } } 点击进postProcessor.postProcessBeanFactory(beanFactory)，这个地方，会发现有很多的xxxProcessor，其他的不用说，我们这里介绍自动配置，所以选择ConfigurationClassPostProcessor#postProcessBeanFactory进去： public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { int factoryId = System.identityHashCode(beanFactory); if (this.factoriesPostProcessed.contains(factoryId)) { throw new IllegalStateException( &quot;postProcessBeanFactory already called on this post-processor against &quot; + beanFactory); } this.factoriesPostProcessed.add(factoryId); if (!this.registriesPostProcessed.contains(factoryId)) { // BeanDefinitionRegistryPostProcessor hook apparently not supported... // Simply call processConfigurationClasses lazily at this point then. processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory); } enhanceConfigurationClasses(beanFactory); beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory)); } 点击进processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);: public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) { List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;(); String[] candidateNames = registry.getBeanDefinitionNames(); // 获取@Configuration class的Bean定义信息 for (String beanName : candidateNames) { BeanDefinition beanDef = registry.getBeanDefinition(beanName); if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) { if (logger.isDebugEnabled()) { logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef); } } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) { configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); } } // Return immediately if no @Configuration classes were found if (configCandidates.isEmpty()) { return; } // Sort by previously determined @Order value, if applicable configCandidates.sort((bd1, bd2) -&gt; { int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition()); int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition()); return Integer.compare(i1, i2); }); // Detect any custom bean name generation strategy supplied through the enclosing application context SingletonBeanRegistry sbr = null; if (registry instanceof SingletonBeanRegistry) { sbr = (SingletonBeanRegistry) registry; if (!this.localBeanNameGeneratorSet) { BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton( AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR); if (generator != null) { this.componentScanBeanNameGenerator = generator; this.importBeanNameGenerator = generator; } } } if (this.environment == null) { this.environment = new StandardEnvironment(); } // Parse each @Configuration class // 构造处理@Configuration类的解析器 ConfigurationClassParser parser = new ConfigurationClassParser( this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry); Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates); Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size()); do { // 开始解析@Configuration class parser.parse(candidates); parser.validate(); Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses()); configClasses.removeAll(alreadyParsed); // Read the model and create bean definitions based on its content if (this.reader == null) { this.reader = new ConfigurationClassBeanDefinitionReader( registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry()); } // 注册配置类的Bean定义信息 this.reader.loadBeanDefinitions(configClasses); alreadyParsed.addAll(configClasses); candidates.clear(); if (registry.getBeanDefinitionCount() &gt; candidateNames.length) { String[] newCandidateNames = registry.getBeanDefinitionNames(); Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames)); Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;(); for (ConfigurationClass configurationClass : alreadyParsed) { alreadyParsedClasses.add(configurationClass.getMetadata().getClassName()); } for (String candidateName : newCandidateNames) { if (!oldCandidateNames.contains(candidateName)) { BeanDefinition bd = registry.getBeanDefinition(candidateName); if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp; !alreadyParsedClasses.contains(bd.getBeanClassName())) { candidates.add(new BeanDefinitionHolder(bd, candidateName)); } } } candidateNames = newCandidateNames; } } while (!candidates.isEmpty()); // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) { sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry()); } if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) { // Clear cache in externally provided MetadataReaderFactory; this is a no-op // for a shared cache since it&#39;ll be cleared by the ApplicationContext. ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache(); } } 点击进parser.parse(candidates)： public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) { for (BeanDefinitionHolder holder : configCandidates) { BeanDefinition bd = holder.getBeanDefinition(); try { if (bd instanceof AnnotatedBeanDefinition) { // 使用annotation的bean进入这个方法进行解析 parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); } else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) { parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName()); } else { parse(bd.getBeanClassName(), holder.getBeanName()); } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex); } } this.deferredImportSelectorHandler.process(); } 点击进parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName())： protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException { processConfigurationClass(new ConfigurationClass(metadata, beanName)); } 点击进processConfigurationClass(new ConfigurationClass(metadata, beanName))，这个类会被递归调用处理配置类： protected void processConfigurationClass(ConfigurationClass configClass) throws IOException { // 是否需要跳过自动配置，配置的@Conditional就是在这个地方解析的，进去看看怎么解析的 if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) { return; } ConfigurationClass existingClass = this.configurationClasses.get(configClass); if (existingClass != null) { if (configClass.isImported()) { if (existingClass.isImported()) { existingClass.mergeImportedBy(configClass); } // Otherwise ignore new imported config class; existing non-imported class overrides it. return; } else { // Explicit bean definition found, probably replacing an import. // Let&#39;s remove the old one and go with the new one. this.configurationClasses.remove(configClass); this.knownSuperclasses.values().removeIf(configClass::equals); } } // Recursively process the configuration class and its superclass hierarchy. // 递归处理配置类及父类 SourceClass sourceClass = asSourceClass(configClass); do { sourceClass = doProcessConfigurationClass(configClass, sourceClass); } while (sourceClass != null); this.configurationClasses.put(configClass, configClass); } 点击进this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)： public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) { // 跳过不满足@Conditional注解的Bean if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) { return false; } if (phase == null) { if (metadata instanceof AnnotationMetadata &amp;&amp; ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) { return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION); } return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN); } // 获取bean上的conditional注解中的类条件 List&lt;Condition&gt; conditions = new ArrayList&lt;&gt;(); for (String[] conditionClasses : getConditionClasses(metadata)) { for (String conditionClass : conditionClasses) { Condition condition = getCondition(conditionClass, this.context.getClassLoader()); conditions.add(condition); } } AnnotationAwareOrderComparator.sort(conditions); for (Condition condition : conditions) { ConfigurationPhase requiredPhase = null; if (condition instanceof ConfigurationCondition) { requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase(); } if ((requiredPhase == null || requiredPhase == phase) &amp;&amp; !condition.matches(this.context, metadata)) { return true; } } return false; } 点击进getConditionClasses(metadata)去看看： private List&lt;String[]&gt; getConditionClasses(AnnotatedTypeMetadata metadata) { MultiValueMap&lt;String, Object&gt; attributes = metadata.getAllAnnotationAttributes(Conditional.class.getName(), true); Object values = (attributes != null ? attributes.get(&quot;value&quot;) : null); return (List&lt;String[]&gt;) (values != null ? values : Collections.emptyList()); } 点击进metadata.getAllAnnotationAttributes(Conditional.class.getName(), true)里面干了啥： default MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes( String annotationName, boolean classValuesAsString) { Adapt[] adaptations = Adapt.values(classValuesAsString, true); return getAnnotations().stream(annotationName) .filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes)) .map(MergedAnnotation::withNonMergedAttributes) .collect(MergedAnnotationCollectors.toMultiValueMap(map -&gt; map.isEmpty() ? null : map, adaptations)); } 这是AnnotatedTypeMetadata接口的一个默认方法，进入getAnnotations()方法： @Override public MergedAnnotations getAnnotations() { return this.annotations; } 这里返回的就是在xxxAutoConfiguration类上配置的注解信息了，比如说： @Configuration(proxyBeanMethods = false) @ConditionalOnMissingBean(name = &quot;demo&quot;, search = SearchStrategy.CURRENT) @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) @Conditional(Demo1.class) @EnableConfigurationProperties public class MyAutoConfiguration { ... } 那么获取到的就是MyAutoConfiguration类上的注解信息啦。然后在AnnotatedTypeMetadata#getAllAnnotationAttributes里会进行过滤，最终只会过滤出条件注解，这里列子的话就是@ConditionalOnMissingBean和@Conditional这两个。回到shouldSkip()中的getCondition()方法，这个方法干的事情就是对解析出来的条件类进行实例化，比如在MyAutoConfiguration中，就是对Demo.class进行实例化。再看看里面的condition.matches(this.context, metadata)方法，这个地方的matches有三个可选项： ConditionEvaluationReport.AncestorsMatchedCondition#matches 这个是报告condition日志信息的，不用管 ProfileCondition#matches 这个就比较重要了，会匹配@Profile注解，进行环境切换 SpringBootCondition#matches(ConditionContext, AnnotatedTypeMetadata) 重中之重了，这个是使用Spring Boot的所有Condition实现的基础，可以看到类中有个方法public abstract ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata);是个抽象类，实现这个方法，不就可以实现自己的条件注解了吗。而且你会发现对于@ConditionalXXX的注解大部分都会有OnXXXCondition条件类与之对应，那么通过这个对应关系不就可以找到对应的条件类了吗。找不到的就合为一个条件类啦，比如说：ConditionalOnBean和ConditionalOnMissingBean对应的就是OnBeanCondition 以上都实现了Condition接口： @FunctionalInterface public interface Condition { /** * Determine if the condition matches. * @param context the condition context * @param metadata metadata of the {@link org.springframework.core.type.AnnotationMetadata class} * or {@link org.springframework.core.type.MethodMetadata method} being checked * @return {@code true} if the condition matches and the component can be registered, * or {@code false} to veto the annotated component&#39;s registration */ boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata); } 当然啦，这个地方使用的就是SpringBootCondition#matches,进去看看： @Override public final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { String classOrMethodName = getClassOrMethodName(metadata); try { ConditionOutcome outcome = getMatchOutcome(context, metadata); logOutcome(classOrMethodName, outcome); recordEvaluation(context, classOrMethodName, outcome); return outcome.isMatch(); } catch (NoClassDefFoundError ex) { throw new IllegalStateException(&quot;Could not evaluate condition on &quot; + classOrMethodName + &quot; due to &quot; + ex.getMessage() + &quot; not found. Make sure your own configuration does not rely on &quot; + &quot;that class. This can also happen if you are &quot; + &quot;@ComponentScanning a springframework package (e.g. if you &quot; + &quot;put a @ComponentScan in the default package by mistake)&quot;, ex); } catch (RuntimeException ex) { throw new IllegalStateException(&quot;Error processing condition on &quot; + getName(metadata), ex); } } 不符合自动配置条件的就返回false，那么shouldSkip就会跳过，不进行自动配置了。回到ConfigurationClassParser#processConfigurationClass，看看其中的doProcessConfigurationClass(configClass, sourceClass)方法，点进去看看： protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException { if (configClass.getMetadata().isAnnotated(Component.class.getName())) { // Recursively process any member (nested) classes first // 首先递归处理嵌套的配置类 processMemberClasses(configClass, sourceClass); } // Process any @PropertySource annotations for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) { if (this.environment instanceof ConfigurableEnvironment) { processPropertySource(propertySource); } else { logger.info(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() + &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;); } } // Process any @ComponentScan annotations Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) { for (AnnotationAttributes componentScan : componentScans) { // The config class is annotated with @ComponentScan -&gt; perform the scan immediately Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed for (BeanDefinitionHolder holder : scannedBeanDefinitions) { BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition(); if (bdCand == null) { bdCand = holder.getBeanDefinition(); } if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) { parse(bdCand.getBeanClassName(), holder.getBeanName()); } } } } // Process any @Import annotations // 处理@Import，主要来看看这个 processImports(configClass, sourceClass, getImports(sourceClass), true); // Process any @ImportResource annotations AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); if (importResource != null) { String[] resources = importResource.getStringArray(&quot;locations&quot;); Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;); for (String resource : resources) { String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); configClass.addImportedResource(resolvedResource, readerClass); } } // Process individual @Bean methods Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass); for (MethodMetadata methodMetadata : beanMethods) { configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); } // Process default methods on interfaces processInterfaces(configClass, sourceClass); // Process superclass, if any if (sourceClass.getMetadata().hasSuperClass()) { String superclass = sourceClass.getMetadata().getSuperClassName(); if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) { this.knownSuperclasses.put(superclass, configClass); // Superclass found, return its annotation metadata and recurse return sourceClass.getSuperClass(); } } // No superclass -&gt; processing is complete return null; } 看到其中的@PropertySource、@ComponentScan等，惊不惊喜，意不意外！解析都在这里面了！点进processImports(configClass, sourceClass, getImports(sourceClass), true)去看看： private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) { if (importCandidates.isEmpty()) { return; } if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) { this.problemReporter.error(new CircularImportProblem(configClass, this.importStack)); } else { this.importStack.push(configClass); try { for (SourceClass candidate : importCandidates) { if (candidate.isAssignable(ImportSelector.class)) { // Candidate class is an ImportSelector -&gt; delegate to it to determine imports Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); if (selector instanceof DeferredImportSelector) { this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector); } else { // 调用XXXSelector的selectImports方法，点进去 String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames); processImports(configClass, currentSourceClass, importSourceClasses, false); } } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) { // Candidate class is an ImportBeanDefinitionRegistrar -&gt; // delegate to it to register additional bean definitions Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportBeanDefinitionRegistrar registrar = ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry); configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); } else { // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt; // process it as an @Configuration class this.importStack.registerImport( currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); processConfigurationClass(candidate.asConfigClass(configClass)); } } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to process import candidates for configuration class [&quot; + configClass.getMetadata().getClassName() + &quot;]&quot;, ex); } finally { this.importStack.pop(); } } } 点击进去看看，发现会有很多的XXXSelector，因为我们看的是自动配置，所以呢，选择AutoConfigurationImportSelector#selectImports进去看看。 public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); // 主要来看看这个方法干啥的 AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } 我嘞个去，是不是很熟悉，之前讲解@EnableAutoConfiguration是不是说过，再粘下代码： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { ... } 好了，现在来看看getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata);这个方法干啥的： protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } // 加载自动配置类的元数据信息 AnnotationAttributes attributes = getAttributes(annotationMetadata); // 获取自动配置类的全限定名 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } 点进getCandidateConfigurations(annotationMetadata, attributes)去看看： protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { // 加载自动配置类的全限定类名 List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot; + &quot;are using a custom packaging, make sure that file is correct.&quot;); return configurations; } 点进getSpringFactoriesLoaderFactoryClass()看看： protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() { return EnableAutoConfiguration.class; } 这不就是启动自动配置的注解吗？拿这个干什么呢？回到上一步，点进SpringFactoriesLoader.loadFactoryNames去看看： public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) { String factoryTypeName = factoryType.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList()); } private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) { MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) { return result; } try { Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); while (urls.hasMoreElements()) { URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) { String factoryTypeName = ((String) entry.getKey()).trim(); for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) { result.add(factoryTypeName, factoryImplementationName.trim()); } } } cache.put(classLoader, result); return result; } catch (IOException ex) { throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; + FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex); } } 看到下面的loadSpringFactories方法中有一个FACTORIES_RESOURCE_LOCATION： public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;; 这不就是个文件么，干什么的，来看看： org.springframework.boot.autoconfigure.EnableAutoConfiguration这个KEY下的自动配置不止图片的这点，还有很多，可以点进去看看！看到这里呢，是不是就明白了。这个spring.factories就是用来配置自动配置类的。也就是说，只要在项目的META-INF/spring.factories中配置上自定义的自动配置类，那么Spring Boot启动的时候，就可以给你做自动配置的事情了！回到getAutoConfigurationEntry方法： protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); // 获取自动配置类的全限定类名 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); // 去重复的自动配置类 configurations = removeDuplicates(configurations); // 返回需要排除的自动配置类 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); // 检查需要排除的自动配置是否存在 checkExcludedClasses(configurations, exclusions); // 移出自动配置类 configurations.removeAll(exclusions); // 按照自动配置类上配置的@ConditionalXXX条件进行过滤 // 使用spring.factories文件中org.springframework.boot.autoconfigure.AutoConfigurationImportFilter对应的过滤器进行过滤。有三个过滤器： // org.springframework.boot.autoconfigure.condition.OnBeanCondition // org.springframework.boot.autoconfigure.condition.OnClassCondition // org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition // 分别调用过滤器中match方法过滤出符合条件的自动配置类 configurations = filter(configurations, autoConfigurationMetadata); // 发布自动配置事件 // 使用spring.factories文件中org.springframework.boot.autoconfigure.AutoConfigurationImportListener对应的监听器org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener发送AutoConfigurationImportEvent事件 fireAutoConfigurationImportEvents(configurations, exclusions); // 返回包含已创建和已排除的自动配置实体 return new AutoConfigurationEntry(configurations, exclusions); } 回到processImports方法： private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) { if (importCandidates.isEmpty()) { return; } if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) { this.problemReporter.error(new CircularImportProblem(configClass, this.importStack)); } else { this.importStack.push(configClass); try { for (SourceClass candidate : importCandidates) { if (candidate.isAssignable(ImportSelector.class)) { // Candidate class is an ImportSelector -&gt; delegate to it to determine imports Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); if (selector instanceof DeferredImportSelector) { this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector); } else { String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames); processImports(configClass, currentSourceClass, importSourceClasses, false); } } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) { // Candidate class is an ImportBeanDefinitionRegistrar -&gt; // delegate to it to register additional bean definitions Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportBeanDefinitionRegistrar registrar = ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry); configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); } else { // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt; // process it as an @Configuration class this.importStack.registerImport( currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); processConfigurationClass(candidate.asConfigClass(configClass)); } } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to process import candidates for configuration class [&quot; + configClass.getMetadata().getClassName() + &quot;]&quot;, ex); } finally { this.importStack.pop(); } } } processImports方法会被递归调用，直到所有的配置类处理完毕。然后在ConfigurationClassPostProcessor#processConfigBeanDefinitions方法中，就会调用this.reader.loadBeanDefinitions(configClasses)注册Bean的定义信息。最后在refresh()方法中调用finishBeanFactoryInitialization(beanFactory)方法实例化Bean。到此自动配置的源码分析就结束啦，最后来一个图总结一下大概流程：","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"Springboot核心注解","slug":"tech-springboot-annotation","date":"2019-10-21T03:00:00.000Z","updated":"2019-10-23T14:33:42.111Z","comments":true,"path":"2019/10/21/tech-springboot-annotation/","link":"","permalink":"/2019/10/21/tech-springboot-annotation/","excerpt":"","text":"在开始介绍Springboot自动配置之前，来看看Springboot有哪些最核心的注解。继续Springboot开胃菜，打开SpringbootWebApplication类后，发现该类上有且只有一个注解@SpringBootApplication，来看看这个是注解所包含的意思：@SpringBootApplication 这是一个便捷的组合注解，使用该注解意味着： 启用配置@SpringBootConfiguration 触发自动配置@EnableAutoConfiguration 组件扫描@ComponentScan 配置属性扫描@ConfigurationPropertiesScan 一个个来看看都是啥意思： @SpringBootConfiguration 用于加载Springboot应用所需要的配置，并且标注当前类是配置类，将配置类中声明的一个或是多个已@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。该注解在Springboot应用中可以使用来替代@Configuration，这样的话，在自动配置的时候，就可以被自动发现了，该注解本身就组合了@Configuration注解。Springboot应用有且只能包含一个@SpringBootConfiguration注解。 @EnableAutoConfiguration 这个是核心中的核心注解啦！使用该注解表示开启自动配置功能，spring应用上下文就会试着去猜测并且配置你所期望的bean。其实就是将所有符合@Conditional注解的配置类加载到Springboot创建的容器中。自动配置类是基于你的classpath和你定义了什么样的bean而被应用。比如说：在你的类路径下有tomcat-embedded.jar，那就意味着你希望有一个TomcatServletWebServerFactory，除非你自己定义了TomcatServletWebServerFactorybean。使用@SpringBootApplication意味着自动配置自动生效，如果有你不需要的配置，可以使用#excludeName()进行排除。自动配置的类通常都是Spring@Configuration的bean，这些bean通过使用SpringFactoriesLoader机制定位。通常自动配置类都是@Conditional的beans(大多数使用@ConditionalOnClass和@ConditionalOnMissingBean注解)。在注解上包含了两个注解： AutoConfigurationPackage 存储自动配置的包，在该包下的bean都会被注册 @Import(AutoConfigurationPackages.Registrar.class) 通过这个注解去存储基础包及注册bean的定义 @Import(AutoConfigurationImportSelector.class) 这就是自动配置的核心啦，所有的自动配置类通过这个导入进来，那么它是在哪里被调用，以及自动配置bean怎么配置进来的，留待后面分析。 @ComponentScan 这个是组件扫描，可以配置组件扫描的基础包以及过滤器，加载符合条件的组件或Bean的定义，最终将这些Bean加载到容器中。Spring框架默认以Springboot启动类所在的包为basePackage进行扫描，当然也可以通过basePackage等属性自定义扫描范围。 @ConfigurationPropertiesScan 指定扫描@ConfigurationProperties类的基础包 @Import(ConfigurationPropertiesScanRegistrar.class) 通过扫描使用ImportBeanDefinitionRegistrar注册@ConfigurationPropertiebean定义 @EnableConfigurationProperties 对带有@ConfigurationProperties注解的bean都可以使用标准的方式被注册，比如说使用@Bean方式 @Import(EnableConfigurationPropertiesRegistrar.class) 对带有@EnableConfigurationProperties的类使用ImportBeanDefinitionRegistrar进行注册 这些注解在项目里都可以点进去看看，熟悉一下，对自动配置的解析有帮助，要不然会感到有点懵！最后，我们再用一个图来总结下，标红的是核心中的核心，需要重点关注的地方：","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"Springboot开胃菜","slug":"tech-springboot-introduction","date":"2019-10-19T07:00:00.000Z","updated":"2019-10-22T15:09:53.027Z","comments":true,"path":"2019/10/19/tech-springboot-introduction/","link":"","permalink":"/2019/10/19/tech-springboot-introduction/","excerpt":"","text":"我们在学习某一知识之前，总得清楚它是干什么的（What），怎么干（How），为什么这么干（Why），对它发出来自灵魂的三拷问。来看看官网介绍： 一、Introducing Spring BootSpring Boot makes it easy to create stand-alone, production-grade Spring-based Applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. You can use Spring Boot to create Java applications that can be started by using java -jar or more traditional war deployments. We also provide a command line tool that runs “spring scripts”. Our primary goals are: Provide a radically faster and widely accessible getting-started experience for all Spring development. Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults. Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration). Absolutely no code generation and no requirement for XML configuration. 明白没？不明白？那我就用我这三级都没过的英语水平简单的翻译下： Spring boot 使得创建以及运行基于单机版或生产级别得spring应用变得很简单。我们提出了spring平台和第三库的观点，使得你可以以最小得代价去开始干你想干得事情。而且对于大部分Spring Boot应用程序仅仅需要很少的配置就可以运行。 你可以使用Spring Boot去创建Java引用，并且以java -jar或是传统部署war包的方式运行。我们也提供了在命令行以&quot;spring scripts&quot;的方式运行 我们的重要目标是： 对于所有的Spring开发从根本上提供一个更快速且可广泛地容易访问的入门体验 开箱即用 给一系列大型项目提供通用的非功能性特性（例如嵌入式服务器、安全性、指标、运行状况检查和外部化配置） 绝对的无需代码生成和XML配置 还没明白？自行Google去吧！！！下面可以不用翻译了。 二、System RequirementsSpring Boot 2.2.0.RELEASE requires Java 8 and is compatible up to Java 13 (included). Spring Framework 5.2.0.RELEASE or above is also required. Explicit build support is provided for the following build tools: Build Tool Version Maven 3.3+ Gradle 5.x (4.10 is also supported but in a deprecated form) Spring Boot supports the following embedded servlet containers: Name Servlet Version Tomcat 9.0 4.0 Jetty 9.4 3.1 Undertow 2.0 4.0 You can also deploy Spring Boot applications to any Servlet 3.1+ compatible container. 三、Installing Spring Boot1、Installation Instructions for the Java Developer对于开发者来说的话，主要有下面两种方式：a、Maven Installation使用maven前，需要先配置好maven的环境。典型的说，你的Maven POM文件会继承spring-boot-starter-parent project并且会声明一个或者多个starters。一个典型的pom.xml文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; b、Gradle InstallationGradle没用过，自行看文档吧！ 1、Installing the Spring Boot CLIThe Spring Boot CLI (Command Line Interface) is a command line tool that you can use to quickly prototype with Spring. It lets you run Groovy scripts, which means that you have a familiar Java-like syntax without so much boilerplate code. You do not need to use the CLI to work with Spring Boot, but it is definitely the quickest way to get a Spring application off the ground. Spring Boot CLI 是一个命令行工具，在我们使用Spring Boot的工作中并不需要使用CLI。 四、Developing Your First Spring Boot ApplicationThis section describes how to develop a simple “Hello World!” web application that highlights some of Spring Boot’s key features. We use Maven to build this project, since most IDEs support it.这个部分演示怎么使用maven部署一个简单的&quot;Hello World&quot;web应用，大部分IDEs都支持使用maven Before we begin, open a terminal and run the following commands to ensure that you have valid versions of Java and Maven installed:开始之前要确认Java和Maven已安装好 $ java -version java version &quot;1.8.0_102&quot; Java(TM) SE Runtime Environment (build 1.8.0_102-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode) $ mvn -v Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-17T14:33:14-04:00) Maven home: /usr/local/Cellar/maven/3.3.9/libexec Java version: 1.8.0_102, vendor: Oracle Corporation This sample needs to be created in its own folder. Subsequent instructions assume that you have created a suitable folder and that it is your current directory.也就是说，需要创建一个文件夹，并且当前的路径是在你创建的文件下 1、Creating the POMWe need to start by creating a Maven pom.xml file. The pom.xml is the recipe that is used to build your project. Open your favorite text editor and add the following:使用喜爱的编辑工具创建一个pom.xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Additional lines to be added here... --&gt; &lt;/project&gt; 2、Adding Classpath DependenciesSpring Boot提供了很多的”Starters”，让你可以把jars添加到classpath下。我们在POM中的parent部分添加了spring-boot-starter-parent，spring-boot-starter-parent是一个特殊的starter，它提供了dependency-management，因此我们在依赖中可以踢出version标签。这个地方我们以添加spring-boot-starter-web为列： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、Writing the CodeTo finish our application, we need to create a single Java file. By default, Maven compiles sources from src/main/java, so you need to create that folder structure and then add a file named src/main/java/Example.java to contain the following code:maven默认是在src/main/java/下编译源文件的，因此需要将Example.java类文件添加到src/main/java/目录下 import org.springframework.boot.*; import org.springframework.boot.autoconfigure.*; import org.springframework.web.bind.annotation.*; @RestController @EnableAutoConfiguration public class Example { @RequestMapping(&quot;/&quot;) String home() { return &quot;Hello World!&quot;; } public static void main(String[] args) { SpringApplication.run(Example.class, args); } } @RestController和@RequestMapping是SpringMVC的注解！@EnableAutoConfiguration这是一个对于Spring Boot来说，很核心的一个注解，我们后面再说。 4、Running the ExampleAt this point, your application should work. Since you used the spring-boot-starter-parent POM, you have a useful run goal that you can use to start the application. Type mvn spring-boot:run from the root project directory to start the application. You should see output similar to the following:在项目根目录执行mvn spring-boot:run，就可以看到输出日志 $ mvn spring-boot:run . ____ _ __ _ _ /\\\\ / ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) ....... . . . ....... . . . (log output here) ....... . . . ........ Started Example in 2.222 seconds (JVM running for 6.514) If you open a web browser to localhost:8080, you should see the following output: Hello World! To gracefully exit the application, press ctrl-c。 5、Creating an Executable JarTo create an executable jar, we need to add the spring-boot-maven-plugin to our pom.xml. To do so, insert the following lines just below the dependencies section:在pom文件中添加如下依赖 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; Notice：The spring-boot-starter-parent POM includes &lt;executions&gt;configuration to bind the repackage goal. If you do not use the parent POM, you need to declare this configuration yourself. See the plugin documentation for details.spring-boot-starter-parent包含了&lt;executions&gt;并且绑定了repackage构建，因此我们直接加上上面的依赖就可以了。如果你没有使用parent Pom的话呢，就需要自己声明构建配置了 Save your pom.xml and run mvn package from the command line, as follows: $ mvn package [INFO] Scanning for projects... [INFO] [INFO] ------------------------------------------------------------------------ [INFO] Building myproject 0.0.1-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO] .... .. [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject --- [INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar [INFO] [INFO] --- spring-boot-maven-plugin:2.2.0.RELEASE:repackage (default) @ myproject --- [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ If you look in the target directory, you should see myproject-0.0.1-SNAPSHOT.jar. The file should be around 10 MB in size. If you want to peek inside, you can use jar tvf, as follows:在target目录中可以看到myproject-0.0.1-SNAPSHOT.jar文件，使用jar tvf可以查看文件内部的详细信息 $ jar tvf target/myproject-0.0.1-SNAPSHOT.jar You should also see a much smaller file named myproject-0.0.1-SNAPSHOT.jar.original in the target directory. This is the original jar file that Maven created before it was repackaged by Spring Boot.在target目录中还可以看到一个myproject-0.0.1-SNAPSHOT.jar.original文件，它是maven在使用Spring Boot打包之前创建的jar源文件 To run that application, use the java -jar command, as follows: $ java -jar target/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\\\ / ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) ....... . . . ....... . . . (log output here) ....... . . . ........ Started Example in 2.536 seconds (JVM running for 2.864) As before, to exit the application, press ctrl-c. 到此为止呢，Spring Boot的灵魂三问已经清楚了。但是发现一个问题，手动去写POM，然后创建类文件，这么简单工程还好，那么复杂的工程的呢，这个过程就很痛苦了啊。那么我们来看看使用工具怎么创建Spring Boot工程，这里使用Idea为例，其他的IDEs类似，就不用说了哈！ 五、Develop Spring Boot Aplication With IDEA1、初始化Spring Boot项目打开Idea，左上角依次：file -&gt; new -&gt; project在弹出框中左侧菜单中选择Spring Initializr后，在右侧配置SDK版本，下面选择Default就行了，然后next配置project，然后next选择需要整合的web中间件，这里有很多的中间可选，可以都看看，后面将要介绍的一些中间件也在里面（如：eureka），然后next配置项目存储路径，Finish后，来看下目录结构：到这里，你就可以直接启动了： . ____ _ __ _ _ /\\\\ / ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) 2019-10-19 17:27:49.228 INFO 33267 --- [ main] c.s.s.SpringbootWebApplication : Starting SpringbootWebApplication on bogon with PID 33267 (/Users/dingzhongshen/SelfProjects/springblog/springboot-web/target/classes started by dingzhongshen in /Users/dingzhongshen/SelfProjects/springblog/springboot-web) 2019-10-19 17:27:49.232 INFO 33267 --- [ main] c.s.s.SpringbootWebApplication : No active profile set, falling back to default profiles: default 2019-10-19 17:27:50.389 INFO 33267 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 2019-10-19 17:27:50.398 INFO 33267 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2019-10-19 17:27:50.399 INFO 33267 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.27] 2019-10-19 17:27:50.469 INFO 33267 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2019-10-19 17:27:50.469 INFO 33267 --- [ main] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1150 ms 2019-10-19 17:27:50.631 INFO 33267 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService &#39;applicationTaskExecutor&#39; 2019-10-19 17:27:50.816 INFO 33267 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &#39;&#39; 2019-10-19 17:27:50.819 INFO 33267 --- [ main] c.s.s.SpringbootWebApplication : Started SpringbootWebApplication in 2.547 seconds (JVM running for 5.328) 看到上面日志Tomcat started on port(s): 8080，就表示Spring Boot项目已经初始化并启动成功了。是不是很简单，开箱即用嘛！！！当然啦，我们要做的事情，可不止这么多，接下来写个Controller试试。 2、配置Spring Boot在resources目录下，有个application.properties文件，我喜欢改成application.yml。然后就可以在这个文件中配置需要的属性啦，比如将服务端口号改成8081： server: port: 8081 启动应用之后，就可以在日志里看到端口被改成： o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8081 (http) with context path &#39;&#39; context path也是可以进行配置的。在使用spring boot的时候，需要集成一些其他的中间件，它们的属性都配置在这里，那他们有什么样的属性，怎么看呢？别急，后面介绍！ 3、编写逻辑，加入相应的启动注解启动之后，在浏览器流输入http://localhost:8080/，就可以看到效果啦，是不是很酷： Hello World! Bingo！！！恭喜你，已经初步掌握Spring Boot啦！上面已经包含了springboot整合中间件的过程，不知道你发现没，没有？不急，后面再说！现在你就只需要知道，使用Spring Boot无非就这么 三板斧 就行了！","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]}]}