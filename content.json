{"meta":{"title":"DuoDuo","subtitle":null,"description":"å¥½å°‘å¹´å…‰èŠ’ä¸‡ä¸ˆ","author":"duoduo","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-10-19T13:56:24.456Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[çˆ±æ€è€ƒã®duoduo] ä¸&nbsp; duoduo&nbsp; ï¼ˆ çœŸæƒ…å‘Šç™½ ï¼‰ å¯¹è¯ä¸­... bot_ui_ini()","keywords":null},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-10-19T13:56:24.456Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-10-19T13:56:24.456Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"å¿µä¸¤å¥è¯— å™åˆ«æ¢¦ã€æ‰¬å·ä¸€è§‰ã€‚ ã€å®‹ä»£ã€‘å´æ–‡è‹±ã€Šå¤œæ¸¸å®«Â·äººå»è¥¿æ¥¼é›æ³ã€‹","keywords":"ç•™è¨€æ¿"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakuraä¸»é¢˜balabala","keywords":"Labå®éªŒå®¤"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-10-19T13:56:24.456Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"è°¢è°¢é¥²ä¸»äº†å–µ~"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-10-19T13:56:24.457Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"å‹äººå¸"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"å–œæ¬¢çš„éŸ³ä¹"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-10-19T13:56:24.457Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-10-19T13:56:24.457Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexoä¸»é¢˜Sakuraä¿®æ”¹è‡ªWordPressä¸»é¢˜Sakuraï¼Œæ„Ÿè°¢åŸä½œè€…Mashiro","keywords":"Hexo ä¸»é¢˜ Sakura ğŸŒ¸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: 'æœèŠ±å¤•èª“â€”â€”äºç¦»åˆ«ä¹‹æœæŸèµ·çº¦å®šä¹‹èŠ±', status: 'å·²è¿½å®Œ', progress: 100, jp: 'ã•ã‚ˆãªã‚‰ã®æœã«ç´„æŸã®èŠ±ã‚’ã‹ã–ã‚ã†', time: 'æ”¾é€æ—¶é—´: 2018-02-24 SUN.', desc: ' ä½åœ¨è¿œç¦»å°˜åš£çš„åœŸåœ°ï¼Œä¸€è¾¹å°†æ¯å¤©çš„äº‹æƒ…ç¼–ç»‡æˆåä¸ºå¸Œæ¯”æ¬§çš„å¸ƒï¼Œä¸€è¾¹é™é™ç”Ÿæ´»çš„ä¼Šæ¬§å¤«äººæ°‘ã€‚åœ¨15å²å·¦å³å¤–è¡¨å°±åœæ­¢æˆé•¿ï¼Œæ‹¥æœ‰æ•°ç™¾å¹´å¯¿å‘½çš„ä»–ä»¬ï¼Œè¢«ç§°ä¸ºâ€œç¦»åˆ«çš„ä¸€æ—â€ï¼Œå¹¶è¢«è§†ä¸ºæ´»ç€çš„ä¼ è¯´ã€‚æ²¡æœ‰åŒäº²çš„ä¼Šæ¬§å¤«å°‘å¥³ç›å¥‡äºšï¼Œè¿‡ç€è¢«ä¼™ä¼´åŒ…å›´çš„å¹³ç¨³æ—¥å­ï¼Œå´æ€»æ„Ÿè§‰â€œå­¤èº«ä¸€äººâ€ã€‚ä»–ä»¬çš„è¿™ç§æ—¥å¸¸ï¼Œä¸€ç¬é—´å°±å´©æºƒæ¶ˆå¤±ã€‚è¿½æ±‚ä¼Šæ¬§å¤«çš„é•¿å¯¿ä¹‹è¡€ï¼Œæ¢…è¨è’‚å†›ä¹˜åç€åä¸ºé›·çº³ç‰¹çš„å¤ä»£å…½å‘åŠ¨äº†è¿›æ”»ã€‚åœ¨ç»æœ›ä¸æ··ä¹±ä¹‹ä¸­ï¼Œä¼Šæ¬§å¤«çš„ç¬¬ä¸€ç¾å¥³è•¾è‰äºšè¢«æ¢…è¨è’‚å¸¦èµ°ï¼Œè€Œç›å¥‡äºšæš—æ‹çš„å°‘å¹´å…‹é‡Œå§†ä¹Ÿå¤±è¸ªäº†ã€‚ç›å¥‡äºšè™½ç„¶æ€»ç®—é€ƒè„±äº†ï¼Œå´å¤±å»äº†ä¼™ä¼´å’Œå½’å»ä¹‹åœ°â€¦â€¦ã€‚' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: 'æœèŠ±å¤•èª“â€”â€”äºç¦»åˆ«ä¹‹æœæŸèµ·çº¦å®šä¹‹èŠ±', status: 'å·²è¿½å®Œ', progress: 100, jp: 'ã•ã‚ˆãªã‚‰ã®æœã«ç´„æŸã®èŠ±ã‚’ã‹ã–ã‚ã†', time: '2018-02-24 SUN.', desc: ' ä½åœ¨è¿œç¦»å°˜åš£çš„åœŸåœ°ï¼Œä¸€è¾¹å°†æ¯å¤©çš„äº‹æƒ…ç¼–ç»‡æˆåä¸ºå¸Œæ¯”æ¬§çš„å¸ƒï¼Œä¸€è¾¹é™é™ç”Ÿæ´»çš„ä¼Šæ¬§å¤«äººæ°‘ã€‚åœ¨15å²å·¦å³å¤–è¡¨å°±åœæ­¢æˆé•¿ï¼Œæ‹¥æœ‰æ•°ç™¾å¹´å¯¿å‘½çš„ä»–ä»¬ï¼Œè¢«ç§°ä¸ºâ€œç¦»åˆ«çš„ä¸€æ—â€ï¼Œå¹¶è¢«è§†ä¸ºæ´»ç€çš„ä¼ è¯´ã€‚æ²¡æœ‰åŒäº²çš„ä¼Šæ¬§å¤«å°‘å¥³ç›å¥‡äºšï¼Œè¿‡ç€è¢«ä¼™ä¼´åŒ…å›´çš„å¹³ç¨³æ—¥å­ï¼Œå´æ€»æ„Ÿè§‰â€œå­¤èº«ä¸€äººâ€ã€‚ä»–ä»¬çš„è¿™ç§æ—¥å¸¸ï¼Œä¸€ç¬é—´å°±å´©æºƒæ¶ˆå¤±ã€‚è¿½æ±‚ä¼Šæ¬§å¤«çš„é•¿å¯¿ä¹‹è¡€ï¼Œæ¢…è¨è’‚å†›ä¹˜åç€åä¸ºé›·çº³ç‰¹çš„å¤ä»£å…½å‘åŠ¨äº†è¿›æ”»ã€‚åœ¨ç»æœ›ä¸æ··ä¹±ä¹‹ä¸­ï¼Œä¼Šæ¬§å¤«çš„ç¬¬ä¸€ç¾å¥³è•¾è‰äºšè¢«æ¢…è¨è’‚å¸¦èµ°ï¼Œè€Œç›å¥‡äºšæš—æ‹çš„å°‘å¹´å…‹é‡Œå§†ä¹Ÿå¤±è¸ªäº†ã€‚ç›å¥‡äºšè™½ç„¶æ€»ç®—é€ƒè„±äº†ï¼Œå´å¤±å»äº†ä¼™ä¼´å’Œå½’å»ä¹‹åœ°â€¦â€¦ã€‚' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} ç•ªç»„è®¡åˆ’ è¿™é‡Œå°†æ˜¯æ°¸è¿œçš„å›å¿† window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} æ”¾é€æ—¶é—´: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"Bç«™"}],"posts":[{"title":"MyBatisæºç åˆ†æä¹‹SqlSessionFactory","slug":"tech-mybatis-sqlSessionFactory","date":"2019-11-03T07:30:10.000Z","updated":"2019-11-03T15:03:05.165Z","comments":true,"path":"2019/11/03/tech-mybatis-sqlSessionFactory/","link":"","permalink":"/2019/11/03/tech-mybatis-sqlSessionFactory/","excerpt":"","text":"æ„é€ SqlSessionFactoryçš„ä¸»æµç¨‹å­¦ä¹ è¿‡åŸºæœ¬ç”¨æ³•ä¹‹åå‘¢ï¼Œæ¥ç€æ¥åˆ†æåˆ†ææºç ï¼Œé¦–å…ˆæ¥çœ‹çœ‹å…¶ä¸­çš„SqlSessionFactoryï¼Œæˆ‘ä»¬æŠŠä¹‹å‰çš„MyBatisTestç²˜ä¸€ä¸‹ï¼š public class MyBatisTest { public static void main(String[] args) throws Exception { String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { UserDAO mapper = session.getMapper(UserDAO.class); User user = mapper.selectUser(1L); System.out.println(user.toString()); } } } å…ˆæ¥çœ‹çœ‹è¿™è¡Œä»£ç å¹²äº†å•¥ï¼š SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); org.apache.ibatis.session.SqlSessionFactoryBuilder#build(java.io.InputStream) å¼€å§‹æ„é€ SqlSessionFactoryï¼š org.apache.ibatis.builder.xml.XMLConfigBuilder#XMLConfigBuilder(java.io.InputStream, java.lang.String, java.util.Properties) é…ç½®æ–‡ä»¶ã€ç¯å¢ƒã€è§£æå™¨åˆå§‹åŒ– org.apache.ibatis.builder.xml.XMLMapperEntityResolver æ„é€ mybatis dtdæ–‡ä»¶è§£æå™¨ org.apache.ibatis.parsing.XPathParser#XPathParser(java.io.InputStream, boolean, java.util.Properties, org.xml.sax.EntityResolver) åˆå§‹åŒ–æ–‡ä»¶è§£æå™¨XPathParserï¼Œæ ¹æ®é…ç½®æ–‡ä»¶ï¼Œæ„é€ æ–‡ä»¶çš„Documentå¯¹è±¡ org.apache.ibatis.session.Configuration æ³¨å†Œé€šç”¨åˆ«åï¼Œæ¯”å¦‚ï¼šJDBC -&gt; JdbcTransactionFactory.classï¼ŒLOG4J -&gt; Log4jImpl.classç­‰ï¼Œè¿™ä¸ªæ˜¯éå¸¸é‡è¦éå¸¸é‡è¦éå¸¸é‡è¦çš„ç±»ï¼Œæˆ‘ä»¬æ‰€æœ‰çš„é…ç½®ä»¥åŠæ“ä½œéƒ½å’Œå®ƒç›¸å…³ public Configuration() { // JDBC typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class); typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class); // JNDI typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class); typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class); // CACHE typeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;, PerpetualCache.class); typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class); typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class); typeAliasRegistry.registerAlias(&quot;SOFT&quot;, SoftCache.class); typeAliasRegistry.registerAlias(&quot;WEAK&quot;, WeakCache.class); // DB_VENDOR typeAliasRegistry.registerAlias(&quot;DB_VENDOR&quot;, VendorDatabaseIdProvider.class); // XML typeAliasRegistry.registerAlias(&quot;XML&quot;, XMLLanguageDriver.class); typeAliasRegistry.registerAlias(&quot;RAW&quot;, RawLanguageDriver.class); // LOG typeAliasRegistry.registerAlias(&quot;SLF4J&quot;, Slf4jImpl.class); typeAliasRegistry.registerAlias(&quot;COMMONS_LOGGING&quot;, JakartaCommonsLoggingImpl.class); typeAliasRegistry.registerAlias(&quot;LOG4J&quot;, Log4jImpl.class); typeAliasRegistry.registerAlias(&quot;LOG4J2&quot;, Log4j2Impl.class); typeAliasRegistry.registerAlias(&quot;JDK_LOGGING&quot;, Jdk14LoggingImpl.class); typeAliasRegistry.registerAlias(&quot;STDOUT_LOGGING&quot;, StdOutImpl.class); typeAliasRegistry.registerAlias(&quot;NO_LOGGING&quot;, NoLoggingImpl.class); // CGLIB typeAliasRegistry.registerAlias(&quot;CGLIB&quot;, CglibProxyFactory.class); typeAliasRegistry.registerAlias(&quot;JAVASSIST&quot;, JavassistProxyFactory.class); // LANGUAGE languageRegistry.setDefaultDriverClass(XMLLanguageDriver.class); languageRegistry.register(RawLanguageDriver.class); } org.apache.ibatis.builder.xml.XMLConfigBuilder#parse é…ç½®æ–‡ä»¶è§£ææ ‡è¯†ï¼Œé¿å…é‡å¤è§£æ org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration è§£æé…ç½®æ–‡ä»¶çš„æ ¸å¿ƒä»£ç ï¼š private void parseConfiguration(XNode root) { try { //issue #117 read properties first propertiesElement(root.evalNode(&quot;properties&quot;)); Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;)); loadCustomVfs(settings); loadCustomLogImpl(settings); typeAliasesElement(root.evalNode(&quot;typeAliases&quot;)); pluginElement(root.evalNode(&quot;plugins&quot;)); objectFactoryElement(root.evalNode(&quot;objectFactory&quot;)); objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;)); reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;)); settingsElement(settings); // read it after objectFactory and objectWrapperFactory issue #631 environmentsElement(root.evalNode(&quot;environments&quot;)); // å¦‚æœé…ç½®äº†æ•°æ®åº“å‚å•†æ ‡è¯†ï¼ˆdatabaseIdProviderï¼‰ï¼ŒMyBatis ä¼šåŠ è½½æ‰€æœ‰çš„ä¸å¸¦ // databaseId æˆ–åŒ¹é…å½“å‰ databaseId çš„è¯­å¥ï¼›å¦‚æœå¸¦æˆ–è€…ä¸å¸¦çš„è¯­å¥éƒ½æœ‰ï¼Œ // åˆ™ä¸å¸¦çš„ä¼šè¢«å¿½ç•¥ã€‚ databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;)); typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;)); mapperElement(root.evalNode(&quot;mappers&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e); } } org.apache.ibatis.session.SqlSessionFactoryBuilder#build(org.apache.ibatis.session.Configuration) æ ¹æ®è§£æå‡ºæ¥çš„é…ç½®æ„é€ SqlSessionFactoryï¼š public SqlSessionFactory build(Configuration config) { return new DefaultSqlSessionFactory(config); } é€šè¿‡ä¸Šé¢çš„ä»£ç åˆ†æçŸ¥é“ï¼Œæˆ‘ä»¬é…ç½®çš„mybatis-config.xmlé…ç½®æ–‡ä»¶ï¼Œæ­£æ˜¯åœ¨new SqlSessionFactoryBuilder().build(inputStream)æ–¹æ³•ä¸‹è¿›è¡Œè§£æçš„ï¼Œä¸»è¦æ¥çœ‹çœ‹typeAliasesã€pluginsã€environmentsã€typeHandlersã€mappersé…ç½®æ€ä¹ˆè§£æçš„ï¼Œè§£æåˆ°å“ªé‡Œå»äº†ã€‚ typeAliasesè§£æç›´æ¥ä¸Šæºç ï¼šorg.apache.ibatis.builder.xml.XMLConfigBuilder#typeAliasesElementï¼š private void typeAliasesElement(XNode parent) { if (parent != null) { // å°†é…ç½®çš„æ•°æ®æ³¨å†Œåˆ°TypeAliasRegistryçš„typeAliaseså±æ€§ä¸­ï¼š // private final Map&lt;String, Class&lt;?&gt;&gt; typeAliases = new HashMap&lt;&gt;(); // key: alise value: type // å¦‚æœaliseä¸ºnullï¼Œåˆ™keyä¸ºï¼štype.getSimpleName() for (XNode child : parent.getChildren()) { if (&quot;package&quot;.equals(child.getName())) { String typeAliasPackage = child.getStringAttribute(&quot;name&quot;); configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage); } else { String alias = child.getStringAttribute(&quot;alias&quot;); String type = child.getStringAttribute(&quot;type&quot;); try { Class&lt;?&gt; clazz = Resources.classForName(type); if (alias == null) { typeAliasRegistry.registerAlias(clazz); } else { typeAliasRegistry.registerAlias(alias, clazz); } } catch (ClassNotFoundException e) { throw new BuilderException(&quot;Error registering typeAlias for &#39;&quot; + alias + &quot;&#39;. Cause: &quot; + e, e); } } } } } pluginsè§£æç›´æ¥ä¸Šæºç ï¼šorg.apache.ibatis.builder.xml.XMLConfigBuilder#pluginElementï¼š private void pluginElement(XNode parent) throws Exception { if (parent != null) { for (XNode child : parent.getChildren()) { String interceptor = child.getStringAttribute(&quot;interceptor&quot;); Properties properties = child.getChildrenAsProperties(); Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance(); interceptorInstance.setProperties(properties); // è§£æå‡ºæ¯ä¸ªpluginï¼Œåå°„å®ä¾‹åŒ–åï¼Œæ³¨å†Œåˆ°configurationçš„interceptorChainå±æ€§ä¸­ï¼Œ // å…¶å®æ˜¯æ”¾åˆ°interceptorChainçš„listé›†åˆorg.apache.ibatis.plugin.InterceptorChain#interceptorsä¸­ï¼š // private final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); // æ¯ä¸ªæ’ä»¶å¤„ç†å™¨éƒ½å®ç°äº†Interceptoræ¥å£ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°Interceptoræ¥å£ï¼Œå®ç°è‡ªå®šä¹‰çš„æ’ä»¶å¤„ç†å™¨ configuration.addInterceptor(interceptorInstance); } } } environmentsè§£æå…ˆçœ‹çœ‹æºç org.apache.ibatis.builder.xml.XMLConfigBuilder#environmentsElementï¼š private void environmentsElement(XNode context) throws Exception { if (context != null) { // æˆ‘ä»¬åœ¨è°ƒç”¨new SqlSessionFactoryBuilder().build(inputStream)çš„æ—¶å€™ï¼Œåªæ˜¯æŠŠé…ç½®æ–‡ä»¶ä¼ è¿›å»ï¼Œæ²¡æœ‰ä¼ æ•°æ®æºIDæˆ–å…¶ä»–çš„å±æ€§é…ç½®ï¼Œæ‰€ä»¥è¿™ä¸ªåœ°æ–¹ä¼šå»è·å–é»˜è®¤çš„æ•°æ®æºé…ç½®ï¼Œåˆšå¥½æˆ‘ä»¬åœ¨é…ç½®çš„æ—¶å€™æŒ‡å®šäº†defaultï¼Œé€šè¿‡ä¼ å…¥æ•°æ®æºIDï¼Œå¯ä»¥è¾¾åˆ°ä½¿ç”¨å¤šæ•°æ®æºçš„ç›®çš„ã€‚æ³¨æ„ï¼šåœ¨ä½¿ç”¨é»˜è®¤ç¯å¢ƒæ•°æ®æºæ—¶ï¼Œä¸€å®šè¦ä¿è¯é»˜è®¤çš„ç¯å¢ƒ ID è¦åŒ¹é…å…¶ä¸­ä¸€ä¸ªç¯å¢ƒ IDã€‚ if (environment == null) { environment = context.getStringAttribute(&quot;default&quot;); } for (XNode child : context.getChildren()) { String id = child.getStringAttribute(&quot;id&quot;); // è¿™ä¸ªåœ°æ–¹å°±æ˜¯ç¯å¢ƒIDæ ¡éªŒäº† if (isSpecifiedEnvironment(id)) { TransactionFactory txFactory = transactionManagerElement(child.evalNode(&quot;transactionManager&quot;)); DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;)); DataSource dataSource = dsFactory.getDataSource(); Environment.Builder environmentBuilder = new Environment.Builder(id) .transactionFactory(txFactory) .dataSource(dataSource); configuration.setEnvironment(environmentBuilder.build()); } } } } æ¥çœ‹çœ‹ç¯å¢ƒIDæ˜¯æ€ä¹ˆæ ¡éªŒçš„ï¼Œå¾ˆå¥½ç†è§£ï¼š private boolean isSpecifiedEnvironment(String id) { if (environment == null) { throw new BuilderException(&quot;No environment specified.&quot;); } else if (id == null) { throw new BuilderException(&quot;Environment requires an id attribute.&quot;); } else if (environment.equals(id)) { return true; } return false; } äº‹ç‰©TransactionFactoryè§£æ private TransactionFactory transactionManagerElement(XNode context) throws Exception { if (context != null) { // äº‹ç‰©ç®¡ç†å™¨ç±»å‹ï¼Œæœ‰ä¸¤ç§[JDBC|MANAGED]ï¼š // JDBCï¼šç›´æ¥ä½¿ç”¨ JDBC çš„æäº¤å’Œå›æ»šè®¾ç½®ï¼Œå®ƒä¾èµ–äºä»æ•°æ®æºå¾—åˆ°çš„è¿æ¥æ¥ç®¡ç†äº‹åŠ¡çš„ä½œç”¨åŸŸã€‚ // MANAGEDï¼šè¿™ä¸ªé…ç½®å‡ ä¹æ²¡åšä»€ä¹ˆï¼Œæ—¢ä¸æäº¤ä¹Ÿä¸ä¼šæ»šï¼Œè®©å®¹å™¨è‡ªå·±å»ç®¡ç†ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒåªä¼šå…³é—­è¿æ¥ï¼Œç„¶è€Œå¹¶ä¸æ˜¯æ‰€æœ‰çš„å®¹å™¨å…è®¸è¿™ä¹ˆåšï¼Œé€šå¸¸éœ€è¦å°† closeConnection å±æ€§è®¾ç½®ä¸º false æ¥é˜»æ­¢å®ƒé»˜è®¤çš„å…³é—­è¡Œä¸ºï¼Œåˆ—å…¥ï¼š // &lt;transactionManager type=&quot;MANAGED&quot;&gt; // &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt; // &lt;/transactionManager&gt; // è¿™ä¸¤ç§äº‹åŠ¡ç®¡ç†å™¨ç±»å‹éƒ½ä¸éœ€è¦è®¾ç½®ä»»ä½•å±æ€§ã€‚å®ƒä»¬å…¶å®æ˜¯ç±»å‹åˆ«åï¼Œæ¢å¥è¯è¯´ï¼Œä½ å¯ä»¥ä½¿ç”¨ TransactionFactory æ¥å£çš„å®ç°ç±»çš„å®Œå…¨é™å®šåæˆ–ç±»å‹åˆ«åä»£æ›¿å®ƒä»¬ã€‚ // å±æ€§é…ç½®ï¼Œå¦‚æœä½¿ç”¨ Spring + MyBatisï¼Œåˆ™æ²¡æœ‰å¿…è¦é…ç½®äº‹åŠ¡ç®¡ç†å™¨ï¼Œ å› ä¸º Spring æ¨¡å—ä¼šä½¿ç”¨è‡ªå¸¦çš„ç®¡ç†å™¨æ¥è¦†ç›–å‰é¢çš„é…ç½®ã€‚ String type = context.getStringAttribute(&quot;type&quot;); // å±æ€§é…ç½® Properties props = context.getChildrenAsProperties(); // åå°„è·å–TransactionFactoryçš„å®ä¾‹ TransactionFactory factory = (TransactionFactory) resolveClass(type).getDeclaredConstructor().newInstance(); // å±æ€§è®¾ç½® factory.setProperties(props); return factory; } throw new BuilderException(&quot;Environment declaration requires a TransactionFactory.&quot;); } æ¥çœ‹çœ‹resolveClass(type)é‡Œéƒ½å¹²äº†å•¥ protected &lt;T&gt; Class&lt;? extends T&gt; resolveClass(String alias) { if (alias == null) { return null; } try { return resolveAlias(alias); } catch (Exception e) { throw new BuilderException(&quot;Error resolving class. Cause: &quot; + e, e); } } protected &lt;T&gt; Class&lt;? extends T&gt; resolveAlias(String alias) { return typeAliasRegistry.resolveAlias(alias); } org.apache.ibatis.type.TypeAliasRegistry#resolveAlias: public &lt;T&gt; Class&lt;T&gt; resolveAlias(String string) { try { if (string == null) { return null; } // issue #748 String key = string.toLowerCase(Locale.ENGLISH); Class&lt;T&gt; value; if (typeAliases.containsKey(key)) { value = (Class&lt;T&gt;) typeAliases.get(key); } else { value = (Class&lt;T&gt;) Resources.classForName(string); } return value; } catch (ClassNotFoundException e) { throw new TypeException(&quot;Could not resolve type alias &#39;&quot; + string + &quot;&#39;. Cause: &quot; + e, e); } } è¿™ä¸ªå°±æ˜¯é€šè¿‡æ³¨å†Œçš„åˆ«åå»è·å–Classï¼Œé€šè¿‡JDBCè·å–åˆ°äº‹ç‰©ç®¡ç†å™¨Classï¼šJdbcTransactionFactory.classï¼Œç„¶ååå°„æ‹¿åˆ°å®ƒçš„å®ä¾‹ï¼Œä¹Ÿå°±æ˜¯TransactionFactoryå•¦ã€‚ DataSourceè§£æè¿™ä¸ªåœ°æ–¹å…¶å®å°±æ˜¯å’ŒTransactionFactoryè§£æä¸€æ ·çš„å•¦ï¼š private DataSourceFactory dataSourceElement(XNode context) throws Exception { if (context != null) { String type = context.getStringAttribute(&quot;type&quot;); Properties props = context.getChildrenAsProperties(); DataSourceFactory factory = (DataSourceFactory) resolveClass(type).getDeclaredConstructor().newInstance(); factory.setProperties(props); return factory; } throw new BuilderException(&quot;Environment declaration requires a DataSourceFactory.&quot;); } æœ€åé€šè¿‡åå°„æ‹¿åˆ°PooledDataSourceFactoryå®ä¾‹ã€‚æ¥çœ‹çœ‹getDeclaredConstructor().newInstance()æ„é€ å™¨é‡Œå¹²äº†å•¥ï¼š public class PooledDataSourceFactory extends UnpooledDataSourceFactory { public PooledDataSourceFactory() { this.dataSource = new PooledDataSource(); } } PooledDataSourceFactoryç»§æ‰¿UnpooledDataSourceFactoryï¼ŒUnpooledDataSourceFactoryå®ç°DataSourceFactoryã€‚new PooledDataSource()é‡Œå¹²äº†å•¥ï¼š public PooledDataSource() { dataSource = new UnpooledDataSource(); } PooledDataSourceã€UnpooledDataSourceå®ç°äº†DataSourceï¼Œæ‰€ä»¥çœ‹åˆ°çš„æ˜¯PooledDataSourceï¼Œå…¶å®ä½¿ç”¨çš„æ˜¯UnpooledDataSourceã€‚çœ‹åˆ°çš„PooledDataSourceFactoryï¼Œå…¶å®ä½¿ç”¨çš„UnpooledDataSourceFactoryï¼Œä¹Ÿå°±æ˜¯è¯´å¹²çš„äº‹æƒ…éƒ½å§”æ‰˜ç»™äº†UnpooledDataSourceå’ŒUnpooledDataSourceFactoryã€‚æ‰€ä»¥æœ€ç»ˆè·å–åˆ°çš„DataSourceæ˜¯UnpooledDataSourceã€‚ æ„å»ºEnvironmentï¼Œé…ç½®ConfigurationenvironmentsElement(XNode context)æ–¹æ³•ä¸­æœ€åçš„å‡ è¡Œä»£ç å°±æ˜¯æŠŠè·å–åˆ°çš„TransactionFactoryã€DataSourceå®ä¾‹æ‰”ç»™Environment.Builderæ„é€ å‡ºEnvironmentå¯¹è±¡ï¼Œç„¶åèµ‹å€¼ç»™Configurationçš„environmentå±æ€§ï¼š public Environment build() { return new Environment(this.id, this.transactionFactory, this.dataSource); } è‡³æ­¤ï¼ŒEnvironmentè§£æå®Œæ¯•ã€‚ typeHandlersè§£æå…ˆçœ‹çœ‹æºç org.apache.ibatis.builder.xml.XMLConfigBuilder#typeHandlerElementï¼š private void typeHandlerElement(XNode parent) { if (parent != null) { // è§£æå‡ºé…ç½®çš„typeHandlerï¼Œå¹¶æ³¨å†Œåˆ°configurationçš„typeHandlerRegistryä¸­ // æ¯ä¸ªç±»å‹å¤„ç†å™¨å‡å®ç°äº†TypeHandleræ¥å£ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°TypeHandleræ¥å£ï¼Œè‡ªå®šä¹‰è‡ªå·±çš„ç±»å‹è§£æå™¨ for (XNode child : parent.getChildren()) { if (&quot;package&quot;.equals(child.getName())) { String typeHandlerPackage = child.getStringAttribute(&quot;name&quot;); typeHandlerRegistry.register(typeHandlerPackage); } else { String javaTypeName = child.getStringAttribute(&quot;javaType&quot;); String jdbcTypeName = child.getStringAttribute(&quot;jdbcType&quot;); String handlerTypeName = child.getStringAttribute(&quot;handler&quot;); Class&lt;?&gt; javaTypeClass = resolveClass(javaTypeName); JdbcType jdbcType = resolveJdbcType(jdbcTypeName); Class&lt;?&gt; typeHandlerClass = resolveClass(handlerTypeName); if (javaTypeClass != null) { if (jdbcType == null) { typeHandlerRegistry.register(javaTypeClass, typeHandlerClass); } else { typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass); } } else { typeHandlerRegistry.register(typeHandlerClass); } } } } } mappersè§£æå…ˆçœ‹çœ‹æºç org.apache.ibatis.builder.xml.XMLConfigBuilder#mapperElementï¼š private void mapperElement(XNode parent) throws Exception { if (parent != null) { for (XNode child : parent.getChildren()) { // è§£æé…ç½®äº†æ‰«æ mappers çš„packageèŠ‚ç‚¹ if (&quot;package&quot;.equals(child.getName())) { String mapperPackage = child.getStringAttribute(&quot;name&quot;); configuration.addMappers(mapperPackage); } else { /** * è§£æé…ç½®äº†æ‰«æ mappers çš„ mapper èŠ‚ç‚¹ * Mapperçš„é…ç½®æ–¹å¼æœ‰ä¸‰ç§ï¼Œæœ‰ä¸”åªèƒ½é…ç½®å…¶ä¸­ä¸€ç§ï¼Œæ¯ç§éƒ½å¯ä»¥é…ç½®å¤šä¸ªï¼š * 1ã€ä½¿ç”¨ç›¸å¯¹äºç±»è·¯å¾„çš„èµ„æºå¼•ç”¨ï¼Œä¾‹å¦‚ï¼š * &lt;mappers&gt; * &lt;mapper resource=&quot;org/mybatis/builder/UserMapper.xml&quot;/&gt; * .... * &lt;/mappers&gt; * * 2ã€ä½¿ç”¨å®Œå…¨é™å®šèµ„æºå®šä½ç¬¦ï¼ˆURLï¼‰ï¼Œä¾‹å¦‚ï¼š * &lt;mappers&gt; * &lt;mapper url=&quot;file:///var/mappers/UserMapper.xml&quot;/&gt; * .... * &lt;/mappers&gt; * * 3ã€ä½¿ç”¨æ˜ å°„å™¨æ¥å£å®ç°ç±»çš„å®Œå…¨é™å®šç±»åï¼Œä¾‹å¦‚ï¼š * &lt;mappers&gt; * &lt;mapper class=&quot;org.mybatis.builder.UserMapper&quot;/&gt; * .... * &lt;/mappers&gt; */ String resource = child.getStringAttribute(&quot;resource&quot;); String url = child.getStringAttribute(&quot;url&quot;); String mapperClass = child.getStringAttribute(&quot;class&quot;); if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) { // Mapperæ–¹å¼è§£æ ErrorContext.instance().resource(resource); InputStream inputStream = Resources.getResourceAsStream(resource); XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); } else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) { // URLæ–¹å¼è§£æ ErrorContext.instance().resource(url); InputStream inputStream = Resources.getUrlAsStream(url); XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments()); mapperParser.parse(); } else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) { // å®Œå…¨é™å®šç±»æ–¹å¼è§£æ Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass); configuration.addMapper(mapperInterface); } else { throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;); } } } } } Packageæ–¹å¼è§£æçœ‹çœ‹configuration.addMappers(mapperPackage)è¿™è¡Œä»£ç é‡Œé¢å¹²äº†å•¥ï¼š public void addMappers(String packageName) { mapperRegistry.addMappers(packageName); } åŸæ¥æ˜¯æŠŠæ‰«æå‡ºçš„Mapperæ¥å£æ³¨å†Œåˆ°mapperRegistryä¸­ï¼Œæ¥ç€æ¥çœ‹ï¼š /** * @since 3.2.2 */ public void addMappers(String packageName, Class&lt;?&gt; superType) { ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;(); resolverUtil.find(new ResolverUtil.IsA(superType), packageName); Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses(); for (Class&lt;?&gt; mapperClass : mapperSet) { addMapper(mapperClass); } } /** * @since 3.2.2 */ public void addMappers(String packageName) { addMappers(packageName, Object.class); } åé¢è°ƒç”¨addMappers(String packageName, Class&lt;?&gt; superType)æ–¹æ³•å¹¶ä¸”æŒ‡å®šæ£€æŸ¥çš„è¶…ç±»æ˜¯Object.classï¼Œè¯¥è¶…ç±»å¯¹è±¡é€šè¿‡new ResolverUtil.IsA(superType)èµ‹å€¼ç»™IsA implements Testç±»ä¸­çš„parentå±æ€§ï¼Œç”¨ä½œåé¢çš„ç±»å‹æ£€æŸ¥ã€‚è°ƒç”¨ResolverUtilå®ä¾‹çš„findæ–¹æ³•ï¼Œå°†åŒ¹é…çš„ç±»çš„Classå¯¹è±¡æ”¾åˆ°ResolverUtilå®ä¾‹çš„matchesé›†åˆä¸­ï¼š public ResolverUtil&lt;T&gt; find(Test test, String packageName) { String path = getPackagePath(packageName); try { List&lt;String&gt; children = VFS.getInstance().list(path); for (String child : children) { if (child.endsWith(&quot;.class&quot;)) { addIfMatching(test, child); } } } catch (IOException ioe) { log.error(&quot;Could not read package: &quot; + packageName, ioe); } return this; } protected void addIfMatching(Test test, String fqn) { try { String externalName = fqn.substring(0, fqn.indexOf(&#39;.&#39;)).replace(&#39;/&#39;, &#39;.&#39;); ClassLoader loader = getClassLoader(); if (log.isDebugEnabled()) { log.debug(&quot;Checking to see if class &quot; + externalName + &quot; matches criteria [&quot; + test + &quot;]&quot;); } Class&lt;?&gt; type = loader.loadClass(externalName); if (test.matches(type)) { matches.add((Class&lt;T&gt;) type); } } catch (Throwable t) { log.warn(&quot;Could not examine class &#39;&quot; + fqn + &quot;&#39;&quot; + &quot; due to a &quot; + t.getClass().getName() + &quot; with message: &quot; + t.getMessage()); } } å›åˆ°addMappers(String packageName, Class&lt;?&gt; superType)ä¸­ï¼Œæœ€ç»ˆæŠŠåŒ¹é…çš„ç±»æ³¨å†Œåˆ°org.apache.ibatis.binding.MapperRegistry#knownMappersMapé›†åˆä¸­ï¼š public &lt;T&gt; void addMapper(Class&lt;T&gt; type) { if (type.isInterface()) { if (hasMapper(type)) { throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;); } boolean loadCompleted = false; try { knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type)); // It&#39;s important that the type is added before the parser is run // otherwise the binding may automatically be attempted by the // mapper parser. If the type is already known, it won&#39;t try. MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type); parser.parse(); loadCompleted = true; } finally { if (!loadCompleted) { knownMappers.remove(type); } } } } Mapperæ–¹å¼è§£ææ¥çœ‹çœ‹new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments())é‡Œé¢å¹²äº†å•¥ï¼š public XMLMapperBuilder(InputStream inputStream, Configuration configuration, String resource, Map&lt;String, XNode&gt; sqlFragments) { // è¿™ä¸ªåœ°æ–¹å’Œè§£æ Configuration æ—¶æ˜¯å·®ä¸å¤šçš„ // ç„¶ååˆ›å»ºxxxMapper.xmlçš„Documentå¯¹è±¡ this(new XPathParser(inputStream, true, configuration.getVariables(), new XMLMapperEntityResolver()), configuration, resource, sqlFragments); } private XMLMapperBuilder(XPathParser parser, Configuration configuration, String resource, Map&lt;String, XNode&gt; sqlFragments) { super(configuration); this.builderAssistant = new MapperBuilderAssistant(configuration, resource); this.parser = parser; this.sqlFragments = sqlFragments; this.resource = resource; } å› ä¸ºXMLMapperBuilder extends BaseBuilderï¼Œæ‰€ä»¥çœ‹çœ‹super(configuration)é‡Œå¹²äº†å•¥ï¼š public BaseBuilder(Configuration configuration) { this.configuration = configuration; this.typeAliasRegistry = this.configuration.getTypeAliasRegistry(); this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry(); } ä»configurationé‡ŒæŠŠtypeAliasRegistryã€typeHandlerRegistryæ‹¿å‡ºæ¥èµ‹å€¼ç»™BaseBuilderä¸­çš„typeAliasRegistryã€typeHandlerRegistryã€‚MapperBuilderAssistant extends BaseBuilderï¼Œçœ‹çœ‹æ„é€ æ–¹æ³•ï¼š public MapperBuilderAssistant(Configuration configuration, String resource) { // è¿™é‡Œçš„superå’Œä¸Šé¢æ˜¯ä¸€æ ·çš„ super(configuration); ErrorContext.instance().resource(resource); this.resource = resource; } æœ€åæ‹¿åˆ°XMLMapperBuilderå®ä¾‹åï¼Œè°ƒç”¨å®ƒçš„parse()æ–¹æ³•ï¼š public void parse() { // æ£€æŸ¥configurationçš„Seté›†åˆloadedResourcesä¸­æ˜¯å¦åŒ…å«å½“å‰çš„resource if (!configuration.isResourceLoaded(resource)) { // å¼€å§‹å»è§£æMapperï¼Œå°†æœ€ç»ˆçš„ç»“æœé›†å­˜å…¥configurationä¸­ configurationElement(parser.evalNode(&quot;/mapper&quot;)); // ä¿å­˜å·²è§£æè¿‡çš„mapper configuration.addLoadedResource(resource); // å°†å·²åŠ è½½è¿‡çš„Mapperçš„namespaceæ³¨å†Œåˆ°configurationçš„mapperRegistryå±æ€§ä¸­çš„ // knownMappersé›†åˆä¸­ï¼š // private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;(); bindMapperForNamespace(); } // å°†æœªå®Œæˆè§£æçš„ResultMapsè§£æåˆ°configurationçš„resultMapsé›†åˆä¸­ parsePendingResultMaps(); /** * private void parsePendingResultMaps() { * Collection&lt;ResultMapResolver&gt; incompleteResultMaps = configuration.getIncompleteResultMaps(); * synchronized (incompleteResultMaps) { * Iterator&lt;ResultMapResolver&gt; iter = incompleteResultMaps.iterator(); * while (iter.hasNext()) { * try { * // org.apache.ibatis.builder.ResultMapResolver#resolve * iter.next().resolve(); * iter.remove(); * } catch (IncompleteElementException e) { * // ResultMap is still missing a resource... * } * } * } * } */ // ç¼“å­˜è§£æ parsePendingCacheRefs(); // SQLè§£æï¼šselect | insert | update | delete // å°†æœªå®Œæˆè§£æçš„SQLStatementsè§£æåˆ°configurationçš„mappedStatementsé›†åˆä¸­ parsePendingStatements(); /** * private void parsePendingStatements() { * Collection&lt;XMLStatementBuilder&gt; incompleteStatements = configuration.getIncompleteStatements(); * synchronized (incompleteStatements) { * Iterator&lt;XMLStatementBuilder&gt; iter = incompleteStatements.iterator(); * while (iter.hasNext()) { * try { * // org.apache.ibatis.builder.xml.XMLStatementBuilder#parseStatementNode * iter.next().parseStatementNode(); * iter.remove(); * } catch (IncompleteElementException e) { * // Statement is still missing a resource... * } * } * } * } */ } configurationElement(parser.evalNode(â€œ/mapperâ€))org.apache.ibatis.builder.xml.XMLMapperBuilder#configurationElementæºç ï¼š private void configurationElement(XNode context) { try { // namespaceæ£€æŸ¥ä¸è®¾ç½® String namespace = context.getStringAttribute(&quot;namespace&quot;); if (namespace == null || namespace.equals(&quot;&quot;)) { throw new BuilderException(&quot;Mapper&#39;s namespace cannot be empty&quot;); } builderAssistant.setCurrentNamespace(namespace); // äºŒçº§ç¼“å­˜é…ç½®ï¼šå¯ä»¥åœ¨å½“å‰namespaceä¸­ä½¿ç”¨&lt;cache/&gt;å¼€å¯äºŒçº§ç¼“å­˜ï¼Œ // å½“å‰ç©ºé—´çš„ç¼“å­˜åªåœ¨å½“å‰ç©ºé—´æœ‰æ•ˆï¼Œå¦‚æœéœ€è¦å¼•ç”¨å…¶ä»–ç©ºé—´çš„ç¼“å­˜ï¼Œåˆ™éœ€è¦é…ç½®&lt;cache-ref/&gt; cacheRefElement(context.evalNode(&quot;cache-ref&quot;)); cacheElement(context.evalNode(&quot;cache&quot;)); // è§£æå¼•ç”¨å¤–éƒ¨çš„å‚æ•°parameterMapï¼Œå·²ç»åºŸå¼ƒ parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;)); // resultMap èŠ‚ç‚¹æ•°æ®è§£æï¼ŒresultMapèŠ‚ç‚¹å¯ä»¥é…ç½®å¤šä¸ªï¼ŒidåŒºåˆ†ï¼Œå°†æœ€ç»ˆçš„è§£æç»“æœå·² // resultMapçš„idä¸ºkeyï¼ŒresultMapä¸ºvalueå­˜å…¥configurationçš„resultMapsé›†åˆä¸­ resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;)); // sqlèŠ‚ç‚¹è§£æ sqlElement(context.evalNodes(&quot;/mapper/sql&quot;)); // select|insert|update|delete èŠ‚ç‚¹è§£æ buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;)); } catch (Exception e) { throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#39;&quot; + resource + &quot;&#39;. Cause: &quot; + e, e); } } è§£æResultMaporg.apache.ibatis.builder.xml.XMLMapperBuilder#resultMapElementsï¼š private void resultMapElements(List&lt;XNode&gt; list) throws Exception { for (XNode resultMapNode : list) { try { resultMapElement(resultMapNode); } catch (IncompleteElementException e) { // ignore, it will be retried } } } private ResultMap resultMapElement(XNode resultMapNode) throws Exception { return resultMapElement(resultMapNode, Collections.emptyList(), null); } private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings, Class&lt;?&gt; enclosingType) throws Exception { ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier()); // è·å–ResultMapçš„ç±»å‹ï¼Œæˆ‘ä»¬é€šå¸¸é…ç½®çš„éƒ½æ˜¯typeï¼Œä¹Ÿå³æ˜¯ï¼šJAVAå®ä½“ç±»çš„ç±»å‹ String type = resultMapNode.getStringAttribute(&quot;type&quot;, resultMapNode.getStringAttribute(&quot;ofType&quot;, resultMapNode.getStringAttribute(&quot;resultType&quot;, resultMapNode.getStringAttribute(&quot;javaType&quot;)))); // é€šè¿‡åˆ«åæˆ–æ˜¯å…¨é™å®šåè·å–typeçš„Classå¯¹è±¡ Class&lt;?&gt; typeClass = resolveClass(type); if (typeClass == null) { // typeä¸é…æˆ–æ˜¯é…ä¸æ­£ç¡®ï¼ŒresolveClasséƒ½ä¼šæŠ¥é”™ï¼Œæ‰€ä»¥åˆ°ä¸äº†è¿™ä¸ªåœ°æ–¹ï¼Œæš‚ä¸ç ”ç©¶ typeClass = inheritEnclosingType(resultMapNode, enclosingType); } Discriminator discriminator = null; List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;&gt;(); resultMappings.addAll(additionalResultMappings); List&lt;XNode&gt; resultChildren = resultMapNode.getChildren(); for (XNode resultChild : resultChildren) { if (&quot;constructor&quot;.equals(resultChild.getName())) { /** è§£æåœ¨ResultMapä¸­é…ç½®çš„javaå®ä½“æ„é€ å™¨èŠ‚ç‚¹ï¼Œä¾‹å¦‚ï¼š * &lt;constructor&gt; * &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&gt; * &lt;arg column=&quot;username&quot; javaType=&quot;String&quot;/&gt; * ...... * &lt;/constructor&gt; * ä½¿ç”¨ç±»ä¼¼String column = context.getStringAttribute(&quot;column&quot;);æ–¹å¼è·å–èŠ‚ç‚¹æ•°æ® * å°†è§£æå‡ºæ¥çš„èŠ‚ç‚¹æ•°æ®æ”¾å…¥ResultMappingä¸­ */ processConstructorElement(resultChild, typeClass, resultMappings); } else if (&quot;discriminator&quot;.equals(resultChild.getName())) { /** * ä½¿ç”¨ç»“æœå€¼æ¥å†³å®šä½¿ç”¨å“ªä¸ª resultMap * åŒæ ·çš„å°†èŠ‚ç‚¹çš„æ•°æ®æ”¾å…¥ResultMappingä¸­ï¼Œå¹¶å°†ResultMappingç»“æœé›†å­˜å…¥Discriminatorçš„resultMappingå±æ€§ä¸­ */ discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings); } else { /** * ä¸»è¦æ¥çœ‹çœ‹è¿™ä¸ªbuildResultMappingFromContext(resultChild, typeClass, flags)æ–¹æ³•ï¼Œä»æ–¹æ³•å°±å¯ä»¥çœ‹å‡ºï¼Œæ˜¯ç”¨äºæ„é€ ResultMappingï¼Œä¸€ä¸ªresultå¯¹åº”å°±å¯¹åº”ä¸€ä¸ªresultMapping */ List&lt;ResultFlag&gt; flags = new ArrayList&lt;&gt;(); if (&quot;id&quot;.equals(resultChild.getName())) { flags.add(ResultFlag.ID); } resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags)); } } // resultMapçš„id String id = resultMapNode.getStringAttribute(&quot;id&quot;, resultMapNode.getValueBasedIdentifier()); // ç»§æ‰¿äºå…¶ä»–resultMapçš„id String extend = resultMapNode.getStringAttribute(&quot;extends&quot;); // æ˜¯å¦å¼€å¯/å…³é—­è‡ªåŠ¨æ˜ å°„ Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;); ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping); try { // è·å–ResultMap return resultMapResolver.resolve(); } catch (IncompleteElementException e) { configuration.addIncompleteResultMap(resultMapResolver); throw e; } } private ResultMapping buildResultMappingFromContext(XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags) throws Exception { // è·å–é…ç½®çš„å„ç§å±æ€§å€¼ String property; if (flags.contains(ResultFlag.CONSTRUCTOR)) { property = context.getStringAttribute(&quot;name&quot;); } else { property = context.getStringAttribute(&quot;property&quot;); } String column = context.getStringAttribute(&quot;column&quot;); String javaType = context.getStringAttribute(&quot;javaType&quot;); String jdbcType = context.getStringAttribute(&quot;jdbcType&quot;); String nestedSelect = context.getStringAttribute(&quot;select&quot;); String nestedResultMap = context.getStringAttribute(&quot;resultMap&quot;, processNestedResultMappings(context, Collections.emptyList(), resultType)); String notNullColumn = context.getStringAttribute(&quot;notNullColumn&quot;); String columnPrefix = context.getStringAttribute(&quot;columnPrefix&quot;); String typeHandler = context.getStringAttribute(&quot;typeHandler&quot;); String resultSet = context.getStringAttribute(&quot;resultSet&quot;); String foreignColumn = context.getStringAttribute(&quot;foreignColumn&quot;); boolean lazy = &quot;lazy&quot;.equals(context.getStringAttribute(&quot;fetchType&quot;, configuration.isLazyLoadingEnabled() ? &quot;lazy&quot; : &quot;eager&quot;)); // é€šè¿‡åˆ«åæˆ–å…¨é™å®šåè§£æjavaå®ä½“ç±»çš„ç±»å‹ Class&lt;?&gt; javaTypeClass = resolveClass(javaType); // é€šè¿‡åˆ«åæˆ–å…¨é™å®šåè§£æç±»å‹å¤„ç†å™¨çš„ç±»å‹ Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = resolveClass(typeHandler); // é€šè¿‡åˆ«åè·å–jdbcçš„ç±»å‹ JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType); // æ ¹æ®è§£æå‡ºæ¥çš„å±æ€§å€¼æ„é€ ResultMapping return builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy); } org.apache.ibatis.builder.MapperBuilderAssistant#buildResultMappingï¼š public ResultMapping buildResultMapping( Class&lt;?&gt; resultType, String property, String column, Class&lt;?&gt; javaType, JdbcType jdbcType, String nestedSelect, String nestedResultMap, String notNullColumn, String columnPrefix, Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler, List&lt;ResultFlag&gt; flags, String resultSet, String foreignColumn, boolean lazy) { // è§£æpropertyå¯¹åº”çš„javaç±»å‹ Class&lt;?&gt; javaTypeClass = resolveResultJavaType(resultType, property, javaType); // æ ¹æ®typeHandlerTypeæˆ–javaTypeClasså’ŒtypeHandlerTypeä»typeHandlerRegistryä¸­è·å–TypeHandler TypeHandler&lt;?&gt; typeHandlerInstance = resolveTypeHandler(javaTypeClass, typeHandler); List&lt;ResultMapping&gt; composites; if ((nestedSelect == null || nestedSelect.isEmpty()) &amp;&amp; (foreignColumn == null || foreignColumn.isEmpty())) { composites = Collections.emptyList(); } else { composites = parseCompositeColumnName(column); } return new ResultMapping.Builder(configuration, property, column, javaTypeClass) .jdbcType(jdbcType) .nestedQueryId(applyCurrentNamespace(nestedSelect, true)) .nestedResultMapId(applyCurrentNamespace(nestedResultMap, true)) .resultSet(resultSet) .typeHandler(typeHandlerInstance) .flags(flags == null ? new ArrayList&lt;&gt;() : flags) .composites(composites) .notNullColumns(parseMultipleColumnNames(notNullColumn)) .columnPrefix(columnPrefix) .foreignColumn(foreignColumn) .lazy(lazy) .build(); } private Class&lt;?&gt; resolveResultJavaType(Class&lt;?&gt; resultType, String property, Class&lt;?&gt; javaType) { if (javaType == null &amp;&amp; property != null) { try { /** * MetaClass.forClass(resultType,configuration.getReflectorFactory()) * å°±æ˜¯é€šè¿‡resultTypeã€reflectorFactoryæ„é€ MetaClassï¼Œæ„é€ æ–¹æ³•ï¼š * private MetaClass(Class&lt;?&gt; type, ReflectorFactory reflectorFactory) { * this.reflectorFactory = reflectorFactory; * this.reflector = reflectorFactory.findForClass(type); * } * * org.apache.ibatis.reflection.DefaultReflectorFactory#findForClassæ–¹æ³• * public Reflector findForClass(Class&lt;?&gt; type) { * if (classCacheEnabled) { * // synchronized (type) removed see issue #461 * // private final ConcurrentMap&lt;Class&lt;?&gt;, Reflector&gt; reflectorMap = new ConcurrentHashMap&lt;&gt;(); * return reflectorMap.computeIfAbsent(type,Reflector::new); * } else { * return new Reflector(type); * } * } * * public class Reflector { * * private final Class&lt;?&gt; type; * private final String[] readablePropertyNames; * private final String[] writablePropertyNames; * private final Map&lt;String, Invoker&gt; setMethods = new HashMap&lt;&gt;(); * private final Map&lt;String, Invoker&gt; getMethods = new HashMap&lt;&gt;(); * private final Map&lt;String, Class&lt;?&gt;&gt; setTypes = new HashMap&lt;&gt;(); * private final Map&lt;String, Class&lt;?&gt;&gt; getTypes = new HashMap&lt;&gt;(); * private Constructor&lt;?&gt; defaultConstructor; * * private Map&lt;String, String&gt; caseInsensitivePropertyMap = new HashMap&lt;&gt;(); * * public Reflector(Class&lt;?&gt; clazz) { * type = clazz; * // æ·»åŠ é»˜è®¤æ„é€ å™¨ * addDefaultConstructor(clazz); * // clazzçš„æ‰€æœ‰Getæ–¹æ³• * addGetMethods(clazz); * // clazzçš„æ‰€æœ‰Setæ–¹æ³• * addSetMethods(clazz); * // clazzçš„æ‰€æœ‰å±æ€§ * addFields(clazz); * readablePropertyNames = getMethods.keySet().toArray(new String[0]); * writablePropertyNames = setMethods.keySet().toArray(new String[0]); * for (String propName : readablePropertyNames) { * caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName); * } * for (String propName : writablePropertyNames) { * caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName); * } * } * ....... * } * */ MetaClass metaResultType = MetaClass.forClass(resultType, configuration.getReflectorFactory()); // é€šè¿‡Reflectorè·å–å±æ€§Setteræ–¹æ³•çš„ç±»å‹ï¼Œå› ä¸ºä»æ•°æ®åº“è·å–åˆ°å€¼çš„æ—¶å€™ï¼Œ // ä¼šé€šè¿‡typeHandlerè½¬æˆpropertyå¯¹åº”çš„SetterTypeï¼Œå°†å€¼setè¿›å» javaType = metaResultType.getSetterType(property); } catch (Exception e) { //ignore, following null check statement will deal with the situation } } if (javaType == null) { javaType = Object.class; } return javaType; } public ResultMapping build() { // lock down collections resultMapping.flags = Collections.unmodifiableList(resultMapping.flags); resultMapping.composites = Collections.unmodifiableList(resultMapping.composites); // TypeHandlerè§£æ resolveTypeHandler(); // å®‰å…¨æ€§éªŒè¯ validate(); return resultMapping; } private void resolveTypeHandler() { if (resultMapping.typeHandler == null &amp;&amp; resultMapping.javaType != null) { Configuration configuration = resultMapping.configuration; TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry(); resultMapping.typeHandler = typeHandlerRegistry.getTypeHandler(resultMapping.javaType, resultMapping.jdbcType); } } private void validate() { // Issue #697: cannot define both nestedQueryId and nestedResultMapId if (resultMapping.nestedQueryId != null &amp;&amp; resultMapping.nestedResultMapId != null) { throw new IllegalStateException(&quot;Cannot define both nestedQueryId and nestedResultMapId in property &quot; + resultMapping.property); } // Issue #5: there should be no mappings without typehandler if (resultMapping.nestedQueryId == null &amp;&amp; resultMapping.nestedResultMapId == null &amp;&amp; resultMapping.typeHandler == null) { throw new IllegalStateException(&quot;No typehandler found for property &quot; + resultMapping.property); } // Issue #4 and GH #39: column is optional only in nested resultmaps but not in the rest if (resultMapping.nestedResultMapId == null &amp;&amp; resultMapping.column == null &amp;&amp; resultMapping.composites.isEmpty()) { throw new IllegalStateException(&quot;Mapping is missing column attribute for property &quot; + resultMapping.property); } if (resultMapping.getResultSet() != null) { int numColumns = 0; if (resultMapping.column != null) { numColumns = resultMapping.column.split(&quot;,&quot;).length; } int numForeignColumns = 0; if (resultMapping.foreignColumn != null) { numForeignColumns = resultMapping.foreignColumn.split(&quot;,&quot;).length; } if (numColumns != numForeignColumns) { throw new IllegalStateException(&quot;There should be the same number of columns and foreignColumns in property &quot; + resultMapping.property); } } } æœ€åæ¥çœ‹çœ‹org.apache.ibatis.builder.ResultMapResolver#resolveï¼š public ResultMap resolve() { return assistant.addResultMap(this.id, this.type, this.extend, this.discriminator, this.resultMappings, this.autoMapping); } org.apache.ibatis.builder.MapperBuilderAssistant#addResultMapï¼š public ResultMap addResultMap( String id, Class&lt;?&gt; type, String extend, Discriminator discriminator, List&lt;ResultMapping&gt; resultMappings, Boolean autoMapping) { // å‘½åç©ºé—´è®¾ç½® id = applyCurrentNamespace(id, false); extend = applyCurrentNamespace(extend, true); // è§£æç»§æ‰¿çš„result if (extend != null) { if (!configuration.hasResultMap(extend)) { throw new IncompleteElementException(&quot;Could not find a parent resultmap with id &#39;&quot; + extend + &quot;&#39;&quot;); } ResultMap resultMap = configuration.getResultMap(extend); List&lt;ResultMapping&gt; extendedResultMappings = new ArrayList&lt;&gt;(resultMap.getResultMappings()); extendedResultMappings.removeAll(resultMappings); // Remove parent constructor if this resultMap declares a constructor. boolean declaresConstructor = false; for (ResultMapping resultMapping : resultMappings) { if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) { declaresConstructor = true; break; } } if (declaresConstructor) { extendedResultMappings.removeIf(resultMapping -&gt; resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)); } resultMappings.addAll(extendedResultMappings); } // é€šè¿‡è§£æå‡ºæ¥çš„æ•°æ®æ„é€ resultMap ResultMap resultMap = new ResultMap.Builder(configuration, id, type, resultMappings, autoMapping) .discriminator(discriminator) .build(); // å°†resultMapçš„idä½œä¸ºkeyï¼ŒresultMapä½œä¸ºvalueä¿å­˜åˆ°Configurationçš„resultMapså±æ€§ä¸­ configuration.addResultMap(resultMap); return resultMap; } public ResultMap build() { if (resultMap.id == null) { throw new IllegalArgumentException(&quot;ResultMaps must have an id&quot;); } // å­˜æ”¾column resultMap.mappedColumns = new HashSet&lt;&gt;(); // å­˜æ”¾property resultMap.mappedProperties = new HashSet&lt;&gt;(); // å­˜æ”¾id resultMap.idResultMappings = new ArrayList&lt;&gt;(); // å­˜æ”¾æ„é€ å™¨ resultMap.constructorResultMappings = new ArrayList&lt;&gt;(); // å­˜æ”¾æ•´ä¸ªresultç»“æœé›† resultMap.propertyResultMappings = new ArrayList&lt;&gt;(); // å­˜æ”¾æ„é€ å™¨å‚æ•° final List&lt;String&gt; constructorArgNames = new ArrayList&lt;&gt;(); // è§£æè·å–åˆ°çš„resultMap.resultMappings for (ResultMapping resultMapping : resultMap.resultMappings) { resultMap.hasNestedQueries = resultMap.hasNestedQueries || resultMapping.getNestedQueryId() != null; resultMap.hasNestedResultMaps = resultMap.hasNestedResultMaps || (resultMapping.getNestedResultMapId() != null &amp;&amp; resultMapping.getResultSet() == null); final String column = resultMapping.getColumn(); if (column != null) { resultMap.mappedColumns.add(column.toUpperCase(Locale.ENGLISH)); } else if (resultMapping.isCompositeResult()) { for (ResultMapping compositeResultMapping : resultMapping.getComposites()) { final String compositeColumn = compositeResultMapping.getColumn(); if (compositeColumn != null) { resultMap.mappedColumns.add(compositeColumn.toUpperCase(Locale.ENGLISH)); } } } final String property = resultMapping.getProperty(); if (property != null) { resultMap.mappedProperties.add(property); } if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) { resultMap.constructorResultMappings.add(resultMapping); if (resultMapping.getProperty() != null) { constructorArgNames.add(resultMapping.getProperty()); } } else { // æ²¡æœ‰æ„é€ å™¨å°±æŠŠæ•´ä¸ªresultç»“æœé›†å­˜èµ·æ¥ resultMap.propertyResultMappings.add(resultMapping); } if (resultMapping.getFlags().contains(ResultFlag.ID)) { resultMap.idResultMappings.add(resultMapping); } } if (resultMap.idResultMappings.isEmpty()) { resultMap.idResultMappings.addAll(resultMap.resultMappings); } // è§£æå®é™…çš„æ„é€ å‚æ•° if (!constructorArgNames.isEmpty()) { final List&lt;String&gt; actualArgNames = argNamesOfMatchingConstructor(constructorArgNames); if (actualArgNames == null) { throw new BuilderException(&quot;Error in result map &#39;&quot; + resultMap.id + &quot;&#39;. Failed to find a constructor in &#39;&quot; + resultMap.getType().getName() + &quot;&#39; by arg names &quot; + constructorArgNames + &quot;. There might be more info in debug log.&quot;); } resultMap.constructorResultMappings.sort((o1, o2) -&gt; { int paramIdx1 = actualArgNames.indexOf(o1.getProperty()); int paramIdx2 = actualArgNames.indexOf(o2.getProperty()); return paramIdx1 - paramIdx2; }); } // å·²è§£æè¿‡çš„æ•°æ®ä¸å¯å˜ // lock down collections resultMap.resultMappings = Collections.unmodifiableList(resultMap.resultMappings); resultMap.idResultMappings = Collections.unmodifiableList(resultMap.idResultMappings); resultMap.constructorResultMappings = Collections.unmodifiableList(resultMap.constructorResultMappings); resultMap.propertyResultMappings = Collections.unmodifiableList(resultMap.propertyResultMappings); resultMap.mappedColumns = Collections.unmodifiableSet(resultMap.mappedColumns); return resultMap; } è§£æsqlElementorg.apache.ibatis.builder.xml.XMLMapperBuilder#sqlElementï¼š private void sqlElement(List&lt;XNode&gt; list) { if (configuration.getDatabaseId() != null) { sqlElement(list, configuration.getDatabaseId()); } sqlElement(list, null); } private void sqlElement(List&lt;XNode&gt; list, String requiredDatabaseId) { for (XNode context : list) { String databaseId = context.getStringAttribute(&quot;databaseId&quot;); String id = context.getStringAttribute(&quot;id&quot;); id = builderAssistant.applyCurrentNamespace(id, false); if (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) { // å°†sqlElementä¿å­˜åˆ°org.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments é›†åˆä¸­ // private final Map&lt;String, XNode&gt; sqlFragments sqlFragments.put(id, context); } } } è§£æselect | insert | update | delete private void buildStatementFromContext(List&lt;XNode&gt; list) { if (configuration.getDatabaseId() != null) { buildStatementFromContext(list, configuration.getDatabaseId()); } buildStatementFromContext(list, null); } private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) { for (XNode context : list) { // org.apache.ibatis.builder.xml.XMLStatementBuilder final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId); try { statementParser.parseStatementNode(); } catch (IncompleteElementException e) { configuration.addIncompleteStatement(statementParser); } } } // å¼€å§‹è§£æ public void parseStatementNode() { String id = context.getStringAttribute(&quot;id&quot;); String databaseId = context.getStringAttribute(&quot;databaseId&quot;); if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) { return; } // è·å–èŠ‚ç‚¹ç±»å‹ // SqlCommandTypeï¼šUNKNOWN, INSERT, UPDATE, DELETE, SELECT, FLUSH String nodeName = context.getNode().getNodeName(); SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH)); boolean isSelect = sqlCommandType == SqlCommandType.SELECT; boolean flushCache = context.getBooleanAttribute(&quot;flushCache&quot;, !isSelect); boolean useCache = context.getBooleanAttribute(&quot;useCache&quot;, isSelect); boolean resultOrdered = context.getBooleanAttribute(&quot;resultOrdered&quot;, false); // Include Fragments before parsing // è§£æåŒ…å«çš„&lt;include/&gt;èŠ‚ç‚¹ XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant); includeParser.applyIncludes(context.getNode()); // è§£æå‚æ•°ç±»å‹ String parameterType = context.getStringAttribute(&quot;parameterType&quot;); Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType); // è§£ææ•°æ®åº“è¯­è¨€é©±åŠ¨LanguageDriverï¼šXMLLanguageDriver String lang = context.getStringAttribute(&quot;lang&quot;); LanguageDriver langDriver = getLanguageDriver(lang); // è§£æselectKeyï¼Œé€šå¸¸æ˜¯é…ç½®çš„éœ€è¦è‡ªåŠ¨ç”Ÿæˆå€¼çš„é”® // Parse selectKey after includes and remove them. processSelectKeyNodes(id, parameterTypeClass, langDriver); // Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed) KeyGenerator keyGenerator; String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX; keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true); if (configuration.hasKeyGenerator(keyStatementId)) { keyGenerator = configuration.getKeyGenerator(keyStatementId); } else { keyGenerator = context.getBooleanAttribute(&quot;useGeneratedKeys&quot;, configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType)) ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE; } /** * è§£æSQL * langDriver.createSqlSource(configuration, context, parameterTypeClass) * æ¥åˆ†æä¸‹ï¼š * org.apache.ibatis.scripting.xmltags.XMLLanguageDriver#createSqlSource * public SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType) { * XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script, parameterType); * return builder.parseScriptNode(); * } * * org.apache.ibatis.scripting.xmltags.XMLScriptBuilder#XMLScriptBuilder * public XMLScriptBuilder(Configuration configuration, XNode context, Class&lt;?&gt; parameterType) { * /** * * super(configuration) * * é…ç½®èµ‹å€¼ XMLScriptBuilder extends org.apache.ibatis.builder.BaseBuilder#BaseBuilder * * public BaseBuilder(Configuration configuration) { * * this.configuration = configuration; * * this.typeAliasRegistry = this.configuration.getTypeAliasRegistry(); * * this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry(); * * } * */ * super(configuration); * this.context = context; * this.parameterType = parameterType; * initNodeHandlerMap(); * } * åŠ¨æ€SQLå¤„ç†åˆå§‹åŒ– * private void initNodeHandlerMap() { * nodeHandlerMap.put(&quot;trim&quot;, new TrimHandler()); * nodeHandlerMap.put(&quot;where&quot;, new WhereHandler()); * nodeHandlerMap.put(&quot;set&quot;, new SetHandler()); * nodeHandlerMap.put(&quot;foreach&quot;, new ForEachHandler()); * nodeHandlerMap.put(&quot;if&quot;, new IfHandler()); * nodeHandlerMap.put(&quot;choose&quot;, new ChooseHandler()); * nodeHandlerMap.put(&quot;when&quot;, new IfHandler()); * nodeHandlerMap.put(&quot;otherwise&quot;, new OtherwiseHandler()); * nodeHandlerMap.put(&quot;bind&quot;, new BindHandler()); * } * * org.apache.ibatis.scripting.xmltags.XMLScriptBuilder#parseScriptNode * public SqlSource parseScriptNode() { * MixedSqlNode rootSqlNode = parseDynamicTags(context); * SqlSource sqlSource; * // DynamicSqlSourceã€RawSqlSourcã€StaticSqlSourceå‡å®ç°äº†SqlSourceæ¥å£ * if (isDynamic) { * // ç›´æ¥æ„é€ ä¸€ä¸ªDynamicSqlSourceå¯¹è±¡ï¼Œå¯¹äº&quot;${}&quot;çš„åŠ¨æ€SQLç›´æ¥æ„é€ è¿”å›ï¼Œ * // ä¸ä¼šå¯¹å…¶è¿›è¡Œè§£æï¼Œå› æ­¤å®¹æ˜“é€ æˆSQLæ³¨å…¥æ”»å‡» * sqlSource = new DynamicSqlSource(configuration, rootSqlNode); * /** * * public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) { * * this.configuration = configuration; * * this.rootSqlNode = rootSqlNode; * * } * */ * } else { * // åœ¨RawSqlSourceä¸­å¯¹sqlè¿›è¡Œè§£æï¼Œå¯¹äº&quot;#{}&quot;æ¯æ¬¡éƒ½ä¼šè¿›è¡Œè§£æï¼Œå¯ä»¥é¢„é˜²SQLæ³¨å…¥æ”»å‡» * sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType); * /** * * org.apache.ibatis.scripting.defaults.RawSqlSource#RawSqlSource * * public RawSqlSource(Configuration configuration, SqlNode rootSqlNode, Class&lt;?&gt; parameterType) { * * this(configuration, getSql(configuration, rootSqlNode), parameterType); * * } * * public RawSqlSource(Configuration configuration, String sql, Class&lt;?&gt; parameterType) { * * SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); * * Class&lt;?&gt; clazz = parameterType == null ? Object.class : parameterType; * * this.sqlSource = sqlSourceParser.parse(sql, clazz, new HashMap()); * * } * * * * org.apache.ibatis.builder.SqlSourceBuilder#parse * * public SqlSourceBuilder(Configuration configuration) { * * // åˆå§‹åŒ–configurationã€typeAliasRegistryã€typeHandlerRegistry * * super(configuration); * * } * * * * public SqlSource parse(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters) { * * SqlSourceBuilder.ParameterMappingTokenHandler handler = new SqlSourceBuilder.ParameterMappingTokenHandler(this.configuration, parameterType, additionalParameters); * * GenericTokenParser parser = new GenericTokenParser(&quot;#{&quot;, &quot;}&quot;, handler); * * // è§£æå ä½ç¬¦&quot;#{}&quot;ï¼Œæ„é€ SQL * * String sql = parser.parse(originalSql); * * // è¿”å›è§£æå‡ºçš„é™æ€SQL * * return new StaticSqlSource(this.configuration, sql, handler.getParameterMappings()); * * } * */ * } * return sqlSource; * } * * parseDynamicTags(context) * è§£æSQLæ”¾å…¥contentsé›†åˆ * SQLä¼šè¢«è§£ææˆ3ä¸ªéƒ¨åˆ†ï¼šselectã€æŸ¥è¯¢çš„å±æ€§ã€å‰©ä½™çš„ä¸€æ®µï¼Œä¾‹å¦‚ï¼š * select id,name,email from user where id = 1 * è§£æå‡ºæ¥åå°±æ˜¯ï¼š * 1ã€select * 2ã€id,name,email * 3ã€from user where id = 1 * * protected MixedSqlNode parseDynamicTags(XNode node) { * List&lt;SqlNode&gt; contents = new ArrayList&lt;&gt;(); * NodeList children = node.getNode().getChildNodes(); * for (int i = 0; i &lt; children.getLength(); i++) { * XNode child = node.newXNode(children.item(i)); * // èŠ‚ç‚¹ç±»å‹ï¼šorg.w3c.dom.Node * if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) { * String data = child.getStringBody(&quot;&quot;); * TextSqlNode textSqlNode = new TextSqlNode(data); * // æ ¹æ®æ˜¯å¦åŒ…å«&quot;${}&quot;åˆ¤æ–­æ˜¯å¦æ˜¯åŠ¨æ€SQL * if (textSqlNode.isDynamic()) { * contents.add(textSqlNode); * isDynamic = true; * } else { * contents.add(new StaticTextSqlNode(data)); * } * } else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) { // issue #628 * String nodeName = child.getNode().getNodeName(); * // æ ¹æ®èŠ‚ç‚¹åç§°ä»initNodeHandlerMap()ä¸­è·å–ç›¸åº”çš„SQLåŠ¨æ€å¤„ç†å™¨ * NodeHandler handler = nodeHandlerMap.get(nodeName); * if (handler == null) { * throw new BuilderException(&quot;Unknown element &lt;&quot; + nodeName + &quot;&gt; in SQL statement.&quot;); * } * // ä½¿ç”¨è·å–åˆ°çš„å¤„ç†å™¨å¤„ç†åŠ¨æ€SQL * handler.handleNode(child, contents); * // å¦‚æœèŠ‚ç‚¹ç±»å‹æ˜¯ï¼šNode.ELEMENT_NODEï¼Œä¹Ÿä¼šåˆ¤å®šä¸ºåŠ¨æ€SQL * isDynamic = true; * } * } * // å°†contentsæ”¾å…¥MixedSqlNodeçš„contentsé›†åˆä¸­ * /** * * org.apache.ibatis.scripting.xmltags.MixedSqlNode#MixedSqlNode * * public class MixedSqlNode implements SqlNode { * * private final List&lt;SqlNode&gt; contents; * * public MixedSqlNode(List&lt;SqlNode&gt; contents) { * * this.contents = contents; * * } * * * * @Override * * public boolean apply(DynamicContext context) { * * contents.forEach(node -&gt; node.apply(context)); * * return true; * * } * * } * */ * return new MixedSqlNode(contents); * } * */ SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass); // è·å–å£°æ˜ç±»å‹StatementTypeï¼šSTATEMENT, PREPARED, CALLABLE StatementType statementType = StatementType.valueOf(context.getStringAttribute(&quot;statementType&quot;, StatementType.PREPARED.toString())); // è·å–è®¾ç½®çš„å…¶ä»–çš„å±æ€§ Integer fetchSize = context.getIntAttribute(&quot;fetchSize&quot;); Integer timeout = context.getIntAttribute(&quot;timeout&quot;); String parameterMap = context.getStringAttribute(&quot;parameterMap&quot;); String resultType = context.getStringAttribute(&quot;resultType&quot;); Class&lt;?&gt; resultTypeClass = resolveClass(resultType); String resultMap = context.getStringAttribute(&quot;resultMap&quot;); String resultSetType = context.getStringAttribute(&quot;resultSetType&quot;); ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType); if (resultSetTypeEnum == null) { resultSetTypeEnum = configuration.getDefaultResultSetType(); } String keyProperty = context.getStringAttribute(&quot;keyProperty&quot;); String keyColumn = context.getStringAttribute(&quot;keyColumn&quot;); String resultSets = context.getStringAttribute(&quot;resultSets&quot;); // æ„é€ SQLçš„MappedStatementï¼ŒMappedStatementæ˜¯å•¥å‘¢ï¼Œå¾€ä¸‹çœ‹ builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum, flushCache, useCache, resultOrdered, keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets); } /** * org.apache.ibatis.builder.MapperBuilderAssistant#addMappedStatement * // MappedStatementå°±æ˜¯ç”¨äºå­˜æ”¾è§£æå‡ºæ¥çš„æ¯ä¸ªSQLçš„å…ƒæ•°æ®ä¿¡æ¯ï¼Œçœ‹çœ‹æ„é€ å‚æ•°å°±çŸ¥é“äº†å“ˆ * public MappedStatement addMappedStatement( * String id, * SqlSource sqlSource, * StatementType statementType, * SqlCommandType sqlCommandType, * Integer fetchSize, * Integer timeout, * String parameterMap, * Class&lt;?&gt; parameterType, * String resultMap, * Class&lt;?&gt; resultType, * ResultSetType resultSetType, * boolean flushCache, * boolean useCache, * boolean resultOrdered, * KeyGenerator keyGenerator, * String keyProperty, * String keyColumn, * String databaseId, * LanguageDriver lang, * String resultSets) { * * if (unresolvedCacheRef) { * throw new IncompleteElementException(&quot;Cache-ref not yet resolved&quot;); * } * * id = applyCurrentNamespace(id, false); * boolean isSelect = sqlCommandType == SqlCommandType.SELECT; * * MappedStatement.Builder statementBuilder = new MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType) * .resource(resource) * .fetchSize(fetchSize) * .timeout(timeout) * .statementType(statementType) * .keyGenerator(keyGenerator) * .keyProperty(keyProperty) * .keyColumn(keyColumn) * .databaseId(databaseId) * .lang(lang) * .resultOrdered(resultOrdered) * .resultSets(resultSets) * .resultMaps(getStatementResultMaps(resultMap, resultType, id)) * .resultSetType(resultSetType) * .flushCacheRequired(valueOrDefault(flushCache, !isSelect)) * .useCache(valueOrDefault(useCache, isSelect)) * .cache(currentCache); * * ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id); * /** * * private ParameterMap getStatementParameterMap( * * String parameterMapName, * * Class&lt;?&gt; parameterTypeClass, * * String statementId) { * * parameterMapName = applyCurrentNamespace(parameterMapName, true); * * ParameterMap parameterMap = null; * * if (parameterMapName != null) { * * try { * * parameterMap = configuration.getParameterMap(parameterMapName); * * } catch (IllegalArgumentException e) { * * throw new IncompleteElementException(&quot;Could not find parameter map &quot; + parameterMapName, e); * * } * * } else if (parameterTypeClass != null) { * * List&lt;ParameterMapping&gt; parameterMappings = new ArrayList&lt;&gt;(); * * parameterMap = new ParameterMap.Builder(configuration, statementId + &quot;-Inline&quot;, parameterTypeClass, parameterMappings).build(); * * } * * return parameterMap; * * } * */ * if (statementParameterMap != null) { * statementBuilder.parameterMap(statementParameterMap); * } * * MappedStatement statement = statementBuilder.build(); * /** * * org.apache.ibatis.mapping.MappedStatement.Builder#build * * public MappedStatement build() { * * assert mappedStatement.configuration != null; * * assert mappedStatement.id != null; * * assert mappedStatement.sqlSource != null; * * assert mappedStatement.lang != null; * * // è§£æå‡ºæ¥çš„ç»“æœå°±ä¸å…è®¸æ”¹å˜äº†ï¼Œå¦åˆ™ä¼šå¯¼è‡´æ•°æ®ä¸€è‡´æ€§é—®é¢˜ * * mappedStatement.resultMaps = Collections.unmodifiableList(mappedStatement.resultMaps); * * return mappedStatement; * * } * */ * // æœ€ç»ˆæŠŠæ•°æ®æ”¾åˆ°configurationçš„mappedStatementså±æ€§ä¸­ï¼š * // protected final Map&lt;String, MappedStatement&gt; mappedStatements = new StrictMap&lt;MappedStatement&gt;(...) * configuration.addMappedStatement(statement); * return statement; * } * */ èµ„æºé™å®šç¬¦ï¼ˆURLï¼‰æ–¹å¼è§£æè¿™ç§æ–¹å¼å…¶å®å°±æ˜¯å’ŒMapperæ–¹å¼è§£ææ˜¯ä¸€æ ·çš„å•¦ï¼Œå°±æ˜¯æ•°æ®çš„æ¥æºä¸ä¸€æ ·è€Œå·²ï¼ å…¨é™å®šç±»åæ–¹å¼è§£æè¿™ç§æ–¹å¼ä¹Ÿå¾ˆç®€å•ï¼Œç›´æ¥æŠŠç±»åŠ è½½å‡ºæ¥æ³¨å†Œåˆ°configurationçš„å±æ€§mapperRegistryä¸­çš„org.apache.ibatis.binding.MapperRegistry#knownMapperså±æ€§ä¸­ å°æ€»ç»“æ„é€ SqlSessionFactoryçš„è¿‡ç¨‹å°±æ˜¯å¯¹é…ç½®æ–‡ä»¶è¿›è¡Œè§£æçš„è¿‡ç¨‹ï¼Œç„¶åæ ¹æ®é…ç½®æ–‡ä»¶è¿”å›ä¸€ä¸ªDefaultSqlSessionFactoryã€‚é…ç½®æ–‡ä»¶çš„è§£æä¸»è¦æ¶‰åŠï¼š typeAliasesçš„è§£æç»“æœæ³¨å†Œåˆ°ï¼šorg.apache.ibatis.type.TypeAliasRegistry#typeAliases pluginsçš„è§£æç»“æœæ³¨å†Œåˆ°ï¼šorg.apache.ibatis.plugin.InterceptorChain#interceptors environmentsçš„è§£æï¼š å¤šæ•°æ®æºçš„è§£æ ç»“æœæ³¨å†Œåˆ°ï¼šorg.apache.ibatis.session.Configuration#environment typeHandlersçš„è§£æ å¦‚æœJavaTypeä¸ä¸ºnullï¼Œå…¶ä¸­keyä¸ºjavatypeæ³¨å†Œåˆ°org.apache.ibatis.type.TypeHandlerRegistry#typeHandlerMap(private final Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = new ConcurrentHashMap&lt;&gt;()) å¦‚æœJavaTypeä¸ºnullï¼Œå…¶ä¸­keyä¸ºhandleçš„typeæ³¨å†Œåˆ°org.apache.ibatis.type.TypeHandlerRegistry#allTypeHandlersMap(private final Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; allTypeHandlersMap = new HashMap&lt;&gt;()) mappersçš„è§£æ parameterMapsçš„è§£æç»“æœæ³¨å†Œåˆ°ï¼šorg.apache.ibatis.session.Configuration#parameterMaps resultMapçš„è§£æç»“æœæ³¨å†Œåˆ°ï¼šorg.apache.ibatis.session.Configuration#resultMaps sqlèŠ‚ç‚¹çš„è§£æç»“æœæ³¨å†Œåˆ°ï¼šorg.apache.ibatis.builder.xml.XMLMapperBuilder#sqlFragments select | insert | update | deleteçš„è§£æ åŠ¨æ€SQLä¸é™æ€SQLçš„è§£æ åŒºåˆ«${} å’Œ #{}çš„è§£æ ç»“æœæ³¨å†Œåˆ°ï¼šorg.apache.ibatis.session.Configuration#mappedStatements ä»¥ä¸Šæ•°æ®è§£æå‡ºæ¥ä¹‹åï¼Œæœ€ç»ˆçš„ç»“æœéƒ½ä¼šæ±‡æ€»åˆ°configurationä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´ä»¥ä¸Šè§£æå‡ºæ¥çš„ç»“æœåœ¨configurationä¸­éƒ½æœ‰ä¸€ä¸ªå±æ€§ä¸ä¹‹å¯¹åº”ã€‚","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"/tags/mybatis/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"MyBatisä»‹ç»åŠåŸºæœ¬ç”¨æ³•","slug":"tech-mybatis-introduction","date":"2019-10-29T07:30:10.000Z","updated":"2019-11-03T14:54:26.096Z","comments":true,"path":"2019/10/29/tech-mybatis-introduction/","link":"","permalink":"/2019/10/29/tech-mybatis-introduction/","excerpt":"","text":"ä»€ä¹ˆæ˜¯MyBatisMyBatiså®˜ç½‘ç»™å‡ºçš„å®šä¹‰å¦‚ä¸‹ï¼š MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings. MyBatis eliminates almost all of the JDBC code and manual setting of parameters and retrieval of results. MyBatis can use simple XML or Annotations for configuration and map primitives, Map interfaces and Java POJOs (Plain Old Java Objects) to database records. è‹±æ–‡ä¸å¥½ï¼Ÿæ²¡å…³ç³»ï¼ŒMyBatisç»™å‡ºäº†å¤šç§è¯­è¨€ï¼Œå…¶ä¸­å°±åŒ…æ‹¬äº†ä¸­æ–‡ç‰ˆå®˜æ–¹ç¿»è¯‘ï¼Œæ¥çœ‹çœ‹ï¼š MyBatis æ˜¯ä¸€æ¬¾ä¼˜ç§€çš„æŒä¹…å±‚æ¡†æ¶ï¼Œå®ƒæ”¯æŒå®šåˆ¶åŒ– SQLã€å­˜å‚¨è¿‡ç¨‹ä»¥åŠé«˜çº§æ˜ å°„ã€‚MyBatis é¿å…äº†å‡ ä¹æ‰€æœ‰çš„ JDBC ä»£ç å’Œæ‰‹åŠ¨è®¾ç½®å‚æ•°ä»¥åŠè·å–ç»“æœé›†ã€‚MyBatis å¯ä»¥ä½¿ç”¨ç®€å•çš„ XML æˆ–æ³¨è§£æ¥é…ç½®å’Œæ˜ å°„åŸç”Ÿç±»å‹ã€æ¥å£å’Œ Java çš„ POJOï¼ˆPlain Old Java Objectsï¼Œæ™®é€šè€å¼ Java å¯¹è±¡ï¼‰ä¸ºæ•°æ®åº“ä¸­çš„è®°å½•ã€‚ æ€ä¹ˆä½¿ç”¨å‘¢æˆ‘ä»¬å°±ä¸æŒ‰ç…§å®˜ç½‘é‚£æ ·ï¼Œåˆå§‹åŒ–ä¸€ä¸ªmavené¡¹ç›®ï¼Œç„¶åå†æ‰‹åŠ¨å¼•å…¥jaråŒ…çš„æ–¹å¼æ¥æ„å»ºé¡¹ç›®äº†ã€‚æˆ‘ä»¬ç›´æ¥ä½¿ç”¨Ideaæ¥åˆå§‹åŒ–ä¸€ä¸ªSpringbooté¡¹ç›®(ç›®å‰å¤§å®¶éƒ½å·²åœ¨ç”¨Springbootå¼€å‘é¡¹ç›®ï¼Œæ‰€ä»¥ç›´æ¥ä½¿ç”¨Spring Initializråˆå§‹åŒ–é¡¹ç›®å°±OKã€‚å®åœ¨ä¸æƒ³ç”¨ï¼Œé‚£å°±æ²¡åŠæ³•å’¯ï¼)ï¼Œç†Ÿæ‚‰ä¸€ä¸‹Springbootæ•´åˆä¸­é—´ä»¶çš„æµç¨‹ã€‚æ‰“å¼€Ideaï¼Œä¾æ¬¡File -&gt; new -&gt; Project... ï¼Œ é€‰æ‹©Spring Initializrï¼Œé…ç½®å¥½JDKï¼Œç„¶åNextï¼Œé…ç½®å¥½Project Metadataï¼Œç„¶ånextï¼Œå¯ä»¥é€‰æ‹©Web -&gt; Spring Webæ–¹ä¾¿åç»­åšæµ‹è¯•ï¼Œé‡è¦çš„æ˜¯é€‰æ‹©SQL -&gt; MyBatis Framework ã€MySQL Driverè¿™ä¸¤é¡¹ï¼Œç„¶ånexté…ç½®é¡¹ç›®åç§°åŠå­˜å‚¨è·¯å¾„ï¼ŒFinishåå‘¢ï¼Œé¡¹ç›®å°±å»ºå¥½äº†ï¼Œé¡ºå¸¦æ‰€éœ€è¦çš„ä¾èµ–åŒ…ä¹Ÿå¼•å…¥åˆ°é¡¹ç›®äº†ã€‚åœ¨å¼€å§‹ä¹‹å‰å‘¢ï¼Œéœ€è¦å‡†å¤‡ä¸€ä¸ªæµ‹è¯•åº“ï¼ˆåº“åæŒ‰ä½ å–œæ¬¢çš„æ–¹å¼å‘½åå°±å¥½ï¼‰ä»¥åŠä¸€ä¸ªæµ‹è¯•è¡¨ï¼ˆä»¥ä¸‹æµ‹è¯•è¡¨ä¸ºUSERï¼‰ï¼Œå‡†å¤‡å¥½ä¹‹åå‘¢ï¼Œå°±å¯ä»¥å¼€å§‹ä»¥ä¸‹éªšæ“ä½œäº†ã€‚ ç¼–ç¨‹å¼1ã€æ·»åŠ é…ç½®åœ¨resourcesåŒ…ä¸‹æ–°å»ºmybatis-config.xmlï¼Œç„¶ååŠ å…¥ä¸‹é¢æ¨¡æ¿å†…å®¹ï¼š &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; // ç¯å¢ƒçš„åç§°ï¼Œå¯ä»¥é…ç½®å¤šä¸ªç¯å¢ƒ &lt;environments default=&quot;development&quot;&gt; // ç¯å¢ƒIDæˆ–æ•°æ®æºIDï¼Œé€šè¿‡IDå¯ä»¥é…ç½®å¤šä¸ªæ•°æ®æº &lt;environment id=&quot;development&quot;&gt; // å¯ç”¨äº‹ç‰© &lt;transactionManager type=&quot;JDBC&quot;/&gt; // æ„å»ºè¿æ¥æ±  &lt;dataSource type=&quot;POOLED&quot;&gt; // MySQLé©±åŠ¨ &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; // MySQLæ•°æ®åº“é“¾æ¥åœ°å€ &lt;property name=&quot;url&quot; value=&quot;xxx&quot;/&gt; // ç”¨æˆ·å &lt;property name=&quot;username&quot; value=&quot;test&quot;/&gt; // å¯†ç  &lt;property name=&quot;password&quot; value=&quot;test&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; // SQLæŸ¥è¯¢è¯­å¥é…ç½® // SQLçš„é…ç½®æ–¹å¼æœ‰ä¸¤ç§ï¼š // ç¬¬ä¸€ç§ï¼šé‡‡ç”¨è¿™ç§XMLçš„é…ç½®æ–¹å¼ // ç¬¬äºŒç§ï¼šä½¿ç”¨æ³¨è§£çš„æ–¹å¼ï¼Œç›´æ¥åœ¨æ¥å£æ–¹æ³•ä¸Šä½¿ç”¨@Selectç­‰æ³¨è§£ï¼Œä¾‹å¦‚ï¼š // public interface UserMapper { // @Select(&quot;SELECT * FROM USER WHERE id = #{id}&quot;) // User selectUser(Long id); // } // ä¸¤ç§æ–¹å¼å„æœ‰ä¼˜åŠ£ï¼Œä½¿ç”¨å“ªä¸€ç§å®Œå…¨å–å†³äºè‡ªå·±æˆ–æ˜¯å¼€å‘å›¢é˜Ÿ &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; ä¾æ¬¡å¡«ä¸Šä½ MySQLçš„ç›¸å…³ä¿¡æ¯å³å¯ã€‚&lt;configuration&gt;èŠ‚ç‚¹ä¸­è¿˜å¯ä»¥é…ç½®&lt;typeHandlers&gt;ï¼Œ&lt;typeHandlers&gt;ä¼šå¯¹å®ä½“ç±»çš„å±æ€§ç±»å‹å’Œæ•°æ®åº“ä¸­çš„å­—æ®µç±»å‹è¿›è¡Œè½¬æ¢ï¼ŒMyBatisé»˜è®¤æ”¯æŒå·²å¾ˆå¤šçš„ç±»å‹è½¬æ¢ï¼Œæ¯”å¦‚ï¼šStringå’Œcharã€varcharäº’è½¬ï¼ŒDateå’ŒTIMESTAMPäº’è½¬ç­‰ã€‚è¿˜å¯ä»¥é…ç½®&lt;plugins&gt;ï¼Œç”¨äºåœ¨å¤„ç†æ•°æ®å‰ååšä¸€äº›äº‹æƒ…ï¼Œæ¯”å¦‚å¸¸ç”¨çš„åˆ†é¡µæ’ä»¶ï¼Œç”¨äºå¯¹åˆ†é¡µè¿›è¡Œå¤„ç†ã€‚è¿˜æœ‰å…¶ä»–çš„ä¸€äº›é…ç½®å¯ä»¥ç›´æ¥åœ¨å®˜ç½‘çš„configurationé…ç½®æ–‡æ¡£ä¸­æŸ¥çœ‹ã€‚MySQLé“¾æ¥çš„é€šå¸¸å†™æ³•ï¼š jdbc:mysql://ipæˆ–domain:port/åº“å?characterEncoding=utf-8&amp;amp;autoReconnect=true&amp;amp;failOverReadOnly=false&amp;amp;serverTimezone=Asia/Shanghai åœ¨xmlä¸­é…ç½®çš„æ—¶å€™ï¼Œéœ€è¦æŠŠ&amp;è¿›è¡Œè½¬ä¹‰ä¸º&amp;amp;å¦åˆ™ä¼šæŠ¥é”™ï¼š Exception in thread &quot;main&quot; org.apache.ibatis.exceptions.PersistenceException: ### Error building SqlSession. ### Cause: org.apache.ibatis.builder.BuilderException: Error creating document instance. Cause: org.xml.sax.SAXParseException; lineNumber: 11; columnNumber: 126; å¯¹å®ä½“ &quot;autoReconnect&quot; çš„å¼•ç”¨å¿…é¡»ä»¥ &#39;;&#39; åˆ†éš”ç¬¦ç»“å°¾ã€‚ at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) at org.apache.ibatis.session.SqlSessionFactoryBuilder.build(SqlSessionFactoryBuilder.java:80) at org.apache.ibatis.session.SqlSessionFactoryBuilder.build(SqlSessionFactoryBuilder.java:64) at com.springboot.mybatis.MyBatisTest.main(MyBatisTest.java:22) 2ã€æ„å»ºUserå®ä½“ç±»æ–°å»ºåŒ…com.springboot.springbootmybatis.modelï¼Œç¼–å†™å®ä½“ç±»Userï¼š public class User { /** * ä¸»é”® */ private Long id; /** * ç”¨æˆ·ID */ private Long userId; /** * ç”¨æˆ·å */ private String name; /** * ç”¨æˆ·çš„é‚®ç®± */ private String email; /** * åˆ›å»ºæ—¶é—´ */ private Date createdTime; /** * ä¿®æ”¹æ—¶é—´ */ private Date modifiedTime; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public Long getUserId() { return userId; } public void setUserId(Long userId) { this.userId = userId; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Date getCreatedTime() { return createdTime; } public void setCreatedTime(Date createdTime) { this.createdTime = createdTime; } public Date getModifiedTime() { return modifiedTime; } public void setModifiedTime(Date modifiedTime) { this.modifiedTime = modifiedTime; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, userId=&quot; + userId + &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, email=&#39;&quot; + email + &#39;\\&#39;&#39; + &quot;, createdTime=&quot; + createdTime + &quot;, modifiedTime=&quot; + modifiedTime + &#39;}&#39;; } } 3ã€æ„å»ºUserDAOæ¥å£æ–°å»ºåŒ…com.springboot.springbootmybatis.daoï¼Œæ–°å»ºæ¥å£UserDAOï¼š @Repository public interface UserDAO { /** * æ ¹æ®ä¸»é”®æŸ¥è¯¢Userä¿¡æ¯ * @param id * @return */ User selectUser(Long id); } 4ã€æ„å»ºuserMapper.xmlæ–‡ä»¶åœ¨resourcesä¸‹æ–°å»ºmapperæ–‡ä»¶å¤¹ï¼Œç„¶åæ–°å»ºuserMapper.xmlï¼š &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.springboot.dao.UserDAO&quot;&gt; &lt;resultMap id=&quot;baseResultMap&quot; type=&quot;com.springboot.model.User&quot;&gt; &lt;id column=&quot;ID&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;USER_ID&quot; jdbcType=&quot;BIGINT&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;NAME&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;EMAIL&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;CREATED_TIME&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createdTime&quot;/&gt; &lt;result column=&quot;MODIFIED_TIME&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;modifiedTime&quot;/&gt; &lt;/resultMap&gt; &lt;sql id=&quot;columns&quot;&gt; ID, USER_ID, NAME, EMAIL, CREATED_TIME, MODIFIED_TIME &lt;/sql&gt; &lt;select id=&quot;selectUser&quot; resultMap=&quot;baseResultMap&quot;&gt; select &lt;include refid=&quot;columns&quot;/&gt; from USER where id = #{id} &lt;/select&gt; &lt;/mapper&gt; ä»¥ä¸Šå·¥ä½œå‡†å¤‡å¥½ä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹æµ‹è¯•äº†ã€‚æ–°å»ºåŒ…com.springboot.springbootmybatis.mybatisï¼Œç„¶åæ–°å»ºç±»MyBatisTestï¼Œåœ¨mainæ–¹æ³•ä¸­ï¼Œå¼•å…¥ï¼š public class MyBatisTest { public static void main(String[] args) throws Exception { String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { UserDAO mapper = session.getMapper(UserDAO.class); User user = mapper.selectUser(1L); System.out.println(user.toString()); } } } æ¥çœ‹çœ‹å…¶ä¸­å‡ ä¸ªé‡è¦ç±»çš„å®˜æ–¹è§£é‡Šï¼š SqlSessionFactoryBuilderï¼šè¿™ä¸ªç±»å¯ä»¥è¢«å®ä¾‹åŒ–ã€ä½¿ç”¨å’Œä¸¢å¼ƒï¼Œä¸€æ—¦åˆ›å»ºäº†SqlSessionFactoryï¼Œå°±ä¸å†éœ€è¦å®ƒäº†ã€‚ å› æ­¤SqlSessionFactoryBuilderå®ä¾‹çš„æœ€ä½³ä½œç”¨åŸŸæ˜¯æ–¹æ³•ä½œç”¨åŸŸï¼ˆä¹Ÿå°±æ˜¯å±€éƒ¨æ–¹æ³•å˜é‡ï¼‰ã€‚ ä½ å¯ä»¥é‡ç”¨SqlSessionFactoryBuilderæ¥åˆ›å»ºå¤šä¸ªSqlSessionFactoryå®ä¾‹ï¼Œä½†æ˜¯æœ€å¥½è¿˜æ˜¯ä¸è¦è®©å…¶ä¸€ç›´å­˜åœ¨ï¼Œä»¥ä¿è¯æ‰€æœ‰çš„ XML è§£æèµ„æºå¯ä»¥è¢«é‡Šæ”¾ç»™æ›´é‡è¦çš„äº‹æƒ…ã€‚ SqlSessionFactoryï¼šSqlSessionFactoryä¸€æ—¦è¢«åˆ›å»ºå°±åº”è¯¥åœ¨åº”ç”¨çš„è¿è¡ŒæœŸé—´ä¸€ç›´å­˜åœ¨ï¼Œæ²¡æœ‰ä»»ä½•ç†ç”±ä¸¢å¼ƒå®ƒæˆ–é‡æ–°åˆ›å»ºå¦ä¸€ä¸ªå®ä¾‹ã€‚ ä½¿ç”¨SqlSessionFactoryçš„æœ€ä½³å®è·µæ˜¯åœ¨åº”ç”¨è¿è¡ŒæœŸé—´ä¸è¦é‡å¤åˆ›å»ºå¤šæ¬¡ï¼Œå¤šæ¬¡é‡å»ºSqlSessionFactoryè¢«è§†ä¸ºä¸€ç§ä»£ç â€œåå‘³é“ï¼ˆbad smellï¼‰â€ã€‚å› æ­¤SqlSessionFactoryçš„æœ€ä½³ä½œç”¨åŸŸæ˜¯åº”ç”¨ä½œç”¨åŸŸã€‚ æœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥åšåˆ°ï¼Œæœ€ç®€å•çš„å°±æ˜¯ä½¿ç”¨å•ä¾‹æ¨¡å¼æˆ–è€…é™æ€å•ä¾‹æ¨¡å¼ã€‚ SqlSessionï¼šæ¯ä¸ªçº¿ç¨‹éƒ½åº”è¯¥æœ‰å®ƒè‡ªå·±çš„SqlSessionå®ä¾‹ã€‚SqlSessionçš„å®ä¾‹ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå› æ­¤æ˜¯ä¸èƒ½è¢«å…±äº«çš„ï¼Œæ‰€ä»¥å®ƒçš„æœ€ä½³çš„ä½œç”¨åŸŸæ˜¯è¯·æ±‚æˆ–æ–¹æ³•ä½œç”¨åŸŸã€‚ ç»å¯¹ä¸èƒ½å°†SqlSessionå®ä¾‹çš„å¼•ç”¨æ”¾åœ¨ä¸€ä¸ªç±»çš„é™æ€åŸŸï¼Œç”šè‡³ä¸€ä¸ªç±»çš„å®ä¾‹å˜é‡ä¹Ÿä¸è¡Œã€‚ ä¹Ÿç»ä¸èƒ½å°† SqlSession å®ä¾‹çš„å¼•ç”¨æ”¾åœ¨ä»»ä½•ç±»å‹çš„æ‰˜ç®¡ä½œç”¨åŸŸä¸­ï¼Œæ¯”å¦‚Servletæ¡†æ¶ä¸­çš„HttpSessionã€‚ å¦‚æœä½ ç°åœ¨æ­£åœ¨ä½¿ç”¨ä¸€ç§Webæ¡†æ¶ï¼Œè¦è€ƒè™‘SqlSessionæ”¾åœ¨ä¸€ä¸ªå’ŒHTTPè¯·æ±‚å¯¹è±¡ç›¸ä¼¼çš„ä½œç”¨åŸŸä¸­ã€‚ æ¢å¥è¯è¯´ï¼Œæ¯æ¬¡æ”¶åˆ°çš„HTTPè¯·æ±‚ï¼Œå°±å¯ä»¥æ‰“å¼€ä¸€ä¸ªSqlSessionï¼Œè¿”å›ä¸€ä¸ªå“åº”ï¼Œå°±å…³é—­å®ƒã€‚ è¿™ä¸ªå…³é—­æ“ä½œæ˜¯å¾ˆé‡è¦çš„ï¼Œä½ åº”è¯¥æŠŠè¿™ä¸ªå…³é—­æ“ä½œæ”¾åˆ°finallyå—ä¸­ä»¥ç¡®ä¿æ¯æ¬¡éƒ½èƒ½æ‰§è¡Œå…³é—­ã€‚ åœ¨ä½ çš„æ‰€æœ‰çš„ä»£ç ä¸­ä¸€è‡´åœ°ä½¿ç”¨ä»¥ä¸‹ç¡®ä¿SqlSessionå…³é—­çš„æ ‡å‡†æ¨¡å¼æ¥ä¿è¯æ‰€æœ‰æ•°æ®åº“èµ„æºéƒ½èƒ½è¢«æ­£ç¡®åœ°å…³é—­ï¼š try (SqlSession session = sqlSessionFactory.openSession()) { // ä½ çš„åº”ç”¨é€»è¾‘ä»£ç  } æ˜ å°„å™¨å®ä¾‹ï¼Œå³xxxDAOæˆ–xxxMapperï¼šæ˜ å°„å™¨æ˜¯ä¸€äº›ç”±ä½ åˆ›å»ºçš„ã€ç»‘å®šä½ æ˜ å°„çš„è¯­å¥çš„æ¥å£ã€‚æ˜ å°„å™¨æ¥å£çš„å®ä¾‹æ˜¯ä»SqlSessionä¸­è·å¾—çš„ã€‚å› æ­¤ä»æŠ€æœ¯å±‚é¢è®²ï¼Œä»»ä½•æ˜ å°„å™¨å®ä¾‹çš„æœ€å¤§ä½œç”¨åŸŸæ˜¯å’Œè¯·æ±‚å®ƒä»¬çš„SqlSessionç›¸åŒçš„ã€‚å°½ç®¡å¦‚æ­¤ï¼Œæ˜ å°„å™¨å®ä¾‹çš„æœ€ä½³ä½œç”¨åŸŸæ˜¯æ–¹æ³•ä½œç”¨åŸŸã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œæ˜ å°„å™¨å®ä¾‹åº”è¯¥åœ¨è°ƒç”¨å®ƒä»¬çš„æ–¹æ³•ä¸­è¢«è¯·æ±‚ï¼Œç”¨è¿‡ä¹‹åå³å¯ä¸¢å¼ƒã€‚ å¹¶ä¸éœ€è¦æ˜¾å¼åœ°å…³é—­æ˜ å°„å™¨å®ä¾‹ï¼Œå°½ç®¡åœ¨æ•´ä¸ªè¯·æ±‚ä½œç”¨åŸŸä¿æŒæ˜ å°„å™¨å®ä¾‹ä¹Ÿä¸ä¼šæœ‰ä»€ä¹ˆé—®é¢˜ï¼Œä½†æ˜¯ä½ å¾ˆå¿«ä¼šå‘ç°ï¼ŒåƒSqlSessionä¸€æ ·ï¼Œåœ¨è¿™ä¸ªä½œç”¨åŸŸä¸Šç®¡ç†å¤ªå¤šçš„èµ„æºçš„è¯ä¼šéš¾äºæ§åˆ¶ã€‚ ä¸ºäº†é¿å…è¿™ç§å¤æ‚æ€§ï¼Œæœ€å¥½æŠŠæ˜ å°„å™¨æ”¾åœ¨æ–¹æ³•ä½œç”¨åŸŸå†…ã€‚ä¸‹é¢çš„ç¤ºä¾‹å°±å±•ç¤ºäº†è¿™ä¸ªå®è·µï¼š try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); // ä½ çš„åº”ç”¨é€»è¾‘ä»£ç  } åé¢æˆ‘ä»¬ä¼šå¯¹è¿™å‡ ä¸ªé‡è¦çš„ç±»è¿›è¡Œæºç åˆ†æï¼Œçœ‹çœ‹åº•å±‚éƒ½å¹²äº†å•¥ï¼Œæ€ä¹ˆå¹²çš„ã€‚ å¥½äº†ï¼Œè¿è¡Œä»£ç åï¼Œå°±å¯ä»¥çœ‹åˆ°æ­£å¸¸çš„æ—¥å¿—è¾“å‡ºå•¦ï¼š 12:27:14.182 [main] DEBUG org.apache.ibatis.logging.LogFactory - Logging initialized using &#39;class org.apache.ibatis.logging.slf4j.Slf4jImpl&#39; adapter. 12:27:14.216 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections. 12:27:14.216 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections. 12:27:14.216 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections. 12:27:14.216 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections. 12:27:14.326 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection 12:27:15.277 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - Created connection 1709804316. 12:27:15.277 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@65e98b1c] 12:27:15.287 [main] DEBUG com.springboot.dao.UserDAO.selectUser - ==&gt; Preparing: select ID, USER_ID, NAME, EMAIL, CREATED_TIME, MODIFIED_TIME from USER where id = ? 12:27:15.321 [main] DEBUG com.springboot.dao.UserDAO.selectUser - ==&gt; Parameters: 1(Long) 12:27:15.348 [main] DEBUG com.springboot.dao.UserDAO.selectUser - &lt;== Total: 1 User{id=1, userId=28250, name=&#39;æµ‹è¯•äºº&#39;, email=&#39;test@danke.com&#39;, createdTime=Tue Oct 29 11:49:44 CST 2019, modifiedTime=Tue Oct 29 11:49:44 CST 2019} 12:27:15.349 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@65e98b1c] 12:27:15.352 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@65e98b1c] 12:27:15.352 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection 1709804316 to pool. åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå»æƒ³ï¼šä¸Šé¢çš„USERå®ä½“ç±»ã€UserDAOã€UserMapper.xmlè¿™å‡ ä¸ªæ–‡ä»¶ï¼Œæˆ‘ä»¬éƒ½è¦è‡ªå·±å»å†™å—ï¼Œä¸€ä¸ªä¸¤ä¸ªè¿˜å¥½ï¼Œå¤šçš„è¯é‚£å²‚ä¸æ˜¯å¾ˆéº»çƒ¦ï¼Ÿéä¹Ÿã€‚å®˜æ–¹çš„å¤§ä½¬å·²ç»ä¸ºæˆ‘ä»¬è€ƒè™‘å¥½äº†ï¼Œå®Œå…¨å¯ä»¥ä½¿ç”¨MyBatis Generator(MBG)æ¥ç”Ÿæˆå˜›ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬åœ¨åˆ†æäº†æˆ‘ä»¬çš„ä¸šåŠ¡åï¼ŒæŠŠæ•°æ®åº“è¡¨å»ºå¥½ï¼Œå°±ç›´æ¥å¯ä»¥ä½¿ç”¨MBGç”Ÿæˆä»£ç å•¦ï¼Œè¿™ä¸å°±å¾ˆçˆ½äº†å—ï¼ é›†æˆå¼æˆ‘ä»¬ä¿ç•™daoã€modelã€mapperï¼Œè‡ªåŠ¨é…ç½®çš„æ—¶å€™ï¼Œè¿˜éœ€è¦ä½¿ç”¨ï¼Œå¯åˆ«åˆ äº†ï¼Œè¦ä¸è¿˜å¾—å†æ¥ä¸€éã€‚æŠŠmybatis-config.xmlæ³¨é‡Šæ‰æˆ–æ”¹ä¸ºmybatis-config.xml.bakï¼ŒMyBatisTestå¯ä»¥æš‚æ—¶ä¸ç”¨ç®¡ã€‚ 1ã€æ•°æ®æºåŠMapperé…ç½®å°†resources/application.propertiesæ–‡ä»¶æ”¹ä¸ºresources/application.ymlï¼Œå½“ç„¶ï¼Œä¸æ”¹ä¹Ÿå¯ä»¥ï¼Œä¸ªäººå–œæ¬¢ymlæ–¹å¼é…ç½®è€Œå·²ã€‚ğŸ˜ç„¶ååœ¨application.ymlæ–‡ä»¶ä¸­æ·»åŠ ä»¥ä¸‹é…ç½®ï¼š spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver username: test password: test url: xxx mybatis: mapper-locations: classpath:/mapper/*.xml æ³¨æ„ï¼šåœ¨å†™ymlæ–‡ä»¶çš„æ—¶å€™ï¼Œæ•°æ®åº“é“¾æ¥urlä¸­çš„&amp;ä¸éœ€è¦è½¬ä¹‰æˆ&amp;amp; 2ã€æ„å»ºControlleræ–°å»ºåŒ…com.springboot.springbootmybatis.controllerï¼Œæ–°å»ºç±»HelloUserControllerï¼š @RestController public class HelloUserController { @Autowired private UserDAO userDAO; //å¦‚æœåœ¨UserDAOä¸Šæ²¡æœ‰@Repositoryï¼Œæ­¤å¤„ä¼šæŠ¥çº¢è‰²çš„ä¸‹åˆ’çº¿ @GetMapping(&quot;/user/{userId}&quot;) public User getUser(@PathVariable(&quot;userId&quot;) Long userId) { User user = userDAO.selectUser(userId); return user; } } è¿™é‡Œçœç•¥äº†serviceå±‚ï¼Œç›´æ¥åœ¨HelloUserControllerä¸­è°ƒç”¨DAOçš„æ¥å£ã€‚å®é™…å¼€å‘ä¸­ï¼ŒServiceå±‚æ˜¯å¿…ä¸å¯å°‘çš„ã€‚è¿™é‡Œçš„@GetMapping ç­‰äº @RequestMapping(method = RequestMethod.GET)ï¼Œç®€å•çš„å†™æ³•ï¼Œä¸ä¹‹å¯¹åº”çš„è¿˜æœ‰@PostMappingã€‚ 3ã€æ·»åŠ Mapperæ‰«æåœ¨ä¸»ç±»SpringbootMybatisApplicationä¸Šæ·»åŠ æ³¨è§£ï¼š@MapperScan(basePackages = &quot;com.springboot.springbootmybatis.dao&quot;)ï¼Œé…ç½®æ‰«æDAOæ¥å£çš„åŒ…è·¯å¾„ã€‚ @SpringBootApplication @MapperScan(basePackages = &quot;com.springboot.springbootmybatis.dao&quot;) public class SpringbootMybatisApplication { public static void main(String[] args) { SpringApplication.run(SpringbootMybatisApplication.class, args); } } æ³¨æ„ï¼šæ·»åŠ çš„åŒ…éœ€è¦å’Œä¸»ç±»SpringbootMybatisApplicationåœ¨åŒä¸€çº§ç›®å½•ï¼Œå¦åˆ™æ‰«æä¸åˆ°å…¶ä¸­çš„ç±»ï¼Œä¹‹å‰Springbootçš„è‡ªåŠ¨é…ç½®æºç å·²åˆ†æè¿‡ï¼šä¼šä»¥ä¸»ç±»SpringbootMybatisApplicationæ‰€åœ¨çš„åŒ…ä¸ºbasePackageè¿›è¡Œç»„ä»¶æ‰«æã€‚æ—¢ç„¶å¦‚æ­¤ï¼Œé‚£è¿™é‡Œä¸é…ç½®@MapperScanè¡Œä¸è¡Œå‘¢ï¼Œå½“ç„¶ä¸è¡Œï¼æƒ³æƒ³å•Šï¼Œæˆ‘ä»¬é¢å‘æ¥å£ç¼–ç¨‹ï¼Œéœ€è¦ä½¿ç”¨DAOæ¥å£å»æ•°æ®åº“æŸ¥è¯¢æ•°æ®ï¼Œç„¶åè¿”å›ç»™è°ƒç”¨è€…ï¼Œå¦‚æœæ¥å£æ²¡æœ‰å®ç°ç±»ï¼Œé‚£æ€ä¹ˆå»æ•°æ®åº“æŸ¥è¯¢å‘¢ã€‚è€Œä¸”å¦‚æœæ²¡æœ‰å®ç°ç±»ï¼ŒSpringæ€ä¹ˆå»å®ä¾‹åŒ–ï¼Œæ€ä¹ˆå»å¸®åŠ©æˆ‘ä»¬ç®¡ç†Beanå‘¢ï¼Œé‚£ä¸ç”¨Springè¡Œä¸è¡Œï¼Ÿè¡Œå•Šï¼Œé‚£å°±ä½¿ç”¨ä¸Šé¢çš„é‚£ç§æ–¹å¼ï¼Œä¹Ÿå¯ä»¥å®ç°ï¼Œä½†æ˜¯ä¸è§‰å¾—éº»çƒ¦å—ï¼Œæ‰€æœ‰çš„äº‹æƒ…éƒ½è¦è‡ªå·±å»åšäº†ï¼Œæ¯”å¦‚ï¼šBeançš„åˆ›å»ºåŠç®¡ç†ï¼Œè¿æ¥çš„æ‰“å¼€å…³é—­ç­‰ã€‚é‚£è¿™é‡ŒåŠ äº†@MapperScanåï¼Œä¸ºä»€ä¹ˆå°±å¯ä»¥äº†å‘¢ï¼Ÿé¢„çŸ¥åäº‹å¦‚ä½•ï¼Œè¯·å¬ä¸‹å›åˆ†è§£ï¼ 4ã€è®¿é—®æµ‹è¯•å¯åŠ¨åº”ç”¨ç¨‹åºï¼Œåœ¨SpringbootMybatisApplicationç±»ä¸­å³é”®Run `SpringbootMybatisApplication `ï¼Œå°±å¯ä»¥å¯åŠ¨å•¦ï¼åœ¨æ§åˆ¶å°ï¼Œå¯ä»¥çœ‹åˆ°ä»¥ä¸‹è¾“å‡ºï¼š o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &#39;&#39; åœ¨æµè§ˆå™¨ä¸­è®¿é—®ï¼šhttp://localhost:8080/user/1ï¼Œå³å¯çœ‹åˆ°ç»“æœï¼š {&quot;id&quot;:1,&quot;userId&quot;:11111,&quot;name&quot;:&quot;æµ‹è¯•äºº&quot;,&quot;email&quot;:&quot;test@163.com&quot;,&quot;createdTime&quot;:&quot;2019-10-29 15:49:44&quot;,&quot;modifiedTime&quot;:&quot;2019-10-29 15:49:44&quot;} å°æ€»ç»“1ã€ç†è§£ä»€ä¹ˆæ˜¯MyBatisMyBatis æ˜¯ä¸€æ¬¾ä¼˜ç§€çš„æŒä¹…å±‚æ¡†æ¶ï¼Œå®ƒæ”¯æŒå®šåˆ¶åŒ– SQLã€å­˜å‚¨è¿‡ç¨‹ä»¥åŠé«˜çº§æ˜ å°„ã€‚MyBatis é¿å…äº†å‡ ä¹æ‰€æœ‰çš„ JDBC ä»£ç å’Œæ‰‹åŠ¨è®¾ç½®å‚æ•°ä»¥åŠè·å–ç»“æœé›†ã€‚MyBatis å¯ä»¥ä½¿ç”¨ç®€å•çš„ XML æˆ–æ³¨è§£æ¥é…ç½®å’Œæ˜ å°„åŸç”Ÿç±»å‹ã€æ¥å£å’Œ Java çš„ POJOï¼ˆPlain Old Java Objectsï¼Œæ™®é€šè€å¼ Java å¯¹è±¡ï¼‰ä¸ºæ•°æ®åº“ä¸­çš„è®°å½•ã€‚ 2ã€ä½¿ç”¨MyBatisçš„ä¸¤ç§æ–¹å¼ ç¼–ç¨‹å¼ é›†æˆå¼ 3ã€SQLé…ç½®çš„ä¸¤ç§æ–¹å¼ ä¼˜ç‚¹ ç¼ºç‚¹ XMLæ–¹å¼ å¤„ç†å¤æ‚çš„SQLï¼›å¯¹SQLè¿›è¡Œç»Ÿä¸€çš„ç®¡ç† XMLæ–‡ä»¶æ¯”è¾ƒå¤šï¼›éœ€è¦æŸ¥æ‰¾XMLæ–‡ä»¶ æ³¨è§£æ–¹å¼ ç®€æ´ç›´è§‚ï¼›ä¸éœ€è¦å»æŸ¥æ‰¾XMLæ–‡ä»¶ ä¸èƒ½å¾ˆå¥½çš„å¤„ç†å¤æ‚çš„SQLï¼Œä¼šæ¯”è¾ƒæ··ä¹± 4ã€é‡è¦ç±»çš„ä½œç”¨åŸŸ(Scope)å’Œç”Ÿå‘½å‘¨æœŸ ä½œç”¨åŸŸ(Scope)å’Œç”Ÿå‘½å‘¨æœŸ SqlSessionFactoryBuilder æ–¹æ³•ä½œç”¨åŸŸï¼ˆå³ï¼šå±€éƒ¨æ–¹æ³•å˜é‡ï¼‰ SqlSessionFactory åº”ç”¨ä½œç”¨åŸŸï¼ˆå•ä¾‹æ¨¡å¼æˆ–è€…é™æ€å•ä¾‹æ¨¡å¼ï¼‰ SqlSession è¯·æ±‚æˆ–æ–¹æ³•ä½œç”¨åŸŸï¼ˆæ”¾åˆ°finallyå—æˆ–tryä¸­ï¼Œç¡®ä¿å…³é—­ï¼‰ æ˜ å°„å™¨å®ä¾‹ æ–¹æ³•ä½œç”¨åŸŸï¼ˆå³ï¼šå±€éƒ¨æ–¹æ³•å˜é‡ï¼‰ 5ã€å¼€å‘ä¸šåŠ¡é¡ºåºç†è§£ä¸šåŠ¡ -&gt; å»ºç«‹åº“è¡¨ -&gt; ä½¿ç”¨MBGç”Ÿæˆç›¸å…³ä»£ç ","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"/tags/mybatis/"},{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"è‡ªå®šä¹‰Springbootçš„Starter","slug":"tech-springboot-custstarter","date":"2019-10-24T10:30:00.000Z","updated":"2019-10-25T14:08:08.479Z","comments":true,"path":"2019/10/24/tech-springboot-custstarter/","link":"","permalink":"/2019/10/24/tech-springboot-custstarter/","excerpt":"","text":"ç†è§£äº†Springbootè‡ªåŠ¨é…ç½®åŸç†åå‘¢ï¼Œæ¥çœ‹çœ‹æ€ä¹ˆè‡ªå®šä¹‰ä¸€ä¸ªstarterã€‚Starterçš„å‘½åä¹Ÿæ˜¯æœ‰ä¸€å®šçš„è§„èŒƒçš„ï¼Œå®˜æ–¹è¯´çš„æ˜¯ï¼šspring-boot-starter-xxxè¢«å®˜æ–¹ä¿ç•™ä½¿ç”¨å•¦ï¼Œç¬¬ä¸‰æ–¹è‡ªå®šä¹‰å°±ä½¿ç”¨xxx-spring-boot-starterã€‚ è‡ªå®šä¹‰Springboot Starteræ€ä¹ˆåˆå§‹åŒ–ä¸€ä¸ªé¡¹ç›®ï¼Œè¯·çœ‹è¿™é‡Œå§ï¼1ã€ä½¿ç”¨Ideaåˆå§‹åŒ–ä¸€ä¸ªæ²¡æœ‰æ•´åˆä»»ä½•ä¸­é—´ä»¶çš„é¡¹ç›®ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨ä½¿ç”¨å·¥å…·ä¸­çš„Spring Initializråˆå§‹åŒ–é¡¹ç›®çš„æ—¶å€™ï¼Œåœ¨é€‰æ‹©ä¸­é—´ä»¶ä¾èµ–çš„æ—¶å€™ï¼Œå•¥ä¹Ÿä¸é€‰ç›´æ¥nextã€‚è¿™é‡Œå°±åˆå§‹åŒ–ä¸€ä¸ªå«hello-spring-boot-starterçš„é¡¹ç›® 2ã€åœ¨åˆå§‹åŒ–å‡ºæ¥çš„é¡¹ç›®ä¸­ï¼ŒæŠŠç”Ÿæˆçš„åŒ…åŠå…¶ä¸­çš„ç±»åˆ æ‰ï¼Œç„¶åæ–°å»ºè‡ªå·±çš„åŒ…ã€‚ 3ã€æ–°å»ºcom.springboot.hello.markeråŒ…ï¼Œè¿™ä¸ªåŒ…ç”¨äºæ¡ä»¶æ³¨è§£ç”¨ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè‡ªå®šä¹‰çš„è‡ªåŠ¨é…ç½®å¿…é¡»åœ¨æœ‰è¿™ä¸ªç±»çš„å‰æä¸‹ï¼Œè‡ªåŠ¨é…ç½®æ‰èƒ½ç”Ÿæ•ˆã€‚ public class Marker { } 4ã€æ–°å»ºcom.springboot.hello.serviceåŒ…ï¼Œç”¨äºå†™ä¸šåŠ¡é€»è¾‘ï¼š public class HelloStarterService { public String helloStarter() { return &quot;WOWï¼Hello starter is working...&quot;; } } 5ã€æ–°å»º com.springboot.hello.autoconfigåŒ…ï¼Œåœ¨å…¶ä¸­ç¼–å†™è‡ªåŠ¨é…ç½®ç±»ï¼š @Configuration(proxyBeanMethods = false) @ConditionalOnClass(Marker.class) public class HelloStarterAutoConfiguration { @Bean public HelloStarterService getHelloStarterService() { return new HelloStarterService(); } } å¦‚æœä¸šåŠ¡é€»è¾‘ä¸­éœ€è¦å±æ€§é…ç½®ï¼Œè¿˜å¯ä»¥åœ¨ç±»ä¸ŠåŠ ä¸Š@EnableConfigurationProperties({xxxProperties.class})ï¼Œä¹Ÿå¯ä»¥åœ¨ç±»ä¸Šä½¿ç”¨@EnableConfigurationPropertieså¯ç”¨å±æ€§é…ç½®åï¼Œåœ¨æ–¹æ³•ä¸Šä½¿ç”¨@ConfigurationProperties(prefix = &quot;xxx.xxx&quot;)è¿›è¡Œé…ç½®ï¼Œä¹Ÿå¯ä»¥åŠ ä¸Šå…¶ä»–çš„æ¡ä»¶æ³¨è§£@ConditionalXXXè¿›è¡Œæ›´å¤æ‚çš„é…ç½®ã€‚ 6ã€åœ¨resourcesåŒ…ä¸‹æ–°å»ºMETA-INF/spring.factoriesæ–‡ä»¶ï¼Œåœ¨å…¶ä¸­å†™ä¸Šè‡ªåŠ¨é…ç½®ç±»ï¼š # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.springboot.hello.autoconfig.HelloStarterAutoConfiguration 7ã€åœ¨æ‰“åŒ…ä¹‹å‰åˆ é™¤pom.xmlä¸­çš„è¿™æ®µé…ç½®ï¼Œå¦åˆ™å›æŠ¥æ‰¾ä¸åˆ°mainç±»çš„é”™è¯¯ï¼š &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 8ã€åœ¨æˆ‘ä»¬ä¹‹å‰çš„springboot-webé¡¹ç›®çš„pom.xmlä¸­å¼•å…¥è¿™ä¸ªstarterï¼š &lt;dependency&gt; &lt;groupId&gt;com.springboot&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; ç„¶åæˆ‘ä»¬åœ¨é¡¹ç›®çš„application.ymlæ–‡ä»¶ä¸­æ‰“å¼€debugï¼š server: port: 8081 debug: true ä¸Šé¢çš„ç«¯å£å·ï¼Œæ˜¯ä¹‹å‰æ”¹çš„ï¼Œåé¢è®¿é—®çš„æ—¶å€™å°±ä½¿ç”¨è¿™ä¸ªç«¯å£ï¼ 9ã€åœ¨Helloworld.javaä¸­åŠ å…¥åœ¨è‡ªåŠ¨é…ç½®ç±»ä¸­å†™çš„HelloStarterServiceï¼Œè¿™ä¸ªåœ°æ–¹ä¸éœ€è¦å»å®ä¾‹åŒ–ï¼Œå°±å¯ä»¥æ‹¿åˆ°æ¥å£HelloStarterServiceçš„å®ä¾‹ï¼Œè‡ªåŠ¨é…ç½®å·²ç»å¸®æˆ‘ä»¬æå¥½äº†ï¼Œç›´æ¥ç”¨å°±è¡Œäº†ã€‚ @RestController public class Helloworld { @Autowired private HelloStarterService helloStarterService; @RequestMapping public String helloworld() { return &quot;hello world&quot;; } @RequestMapping(&quot;/helloStarter&quot;) public String helloStarter() { return helloStarterService.helloStarter(); } } å¯åŠ¨ä¸€ä¸‹ï¼Œè§è¯å¥‡è¿¹çš„æ—¶åˆ»ã€‚åœ¨å¯åŠ¨åçš„æ—¥å¿—ä¸­å‘ç°ï¼Œè‡ªå®šä¹‰çš„è‡ªåŠ¨é…ç½®ç±»å·²ç»ç”Ÿæ•ˆäº†ï¼š ============================ CONDITIONS EVALUATION REPORT ============================ Positive matches: ----------------- ... ... HelloStarterAutoConfiguration matched: - @ConditionalOnClass found required class &#39;com.springboot.hello.marker.Marker&#39; (OnClassCondition) ... ... Negative matches: ----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class &#39;javax.jms.ConnectionFactory&#39; (OnClassCondition) ... ... Positive matchesæ˜¯è‡ªåŠ¨é…ç½®ç”Ÿæ•ˆçš„ï¼ŒNegative matchesæ˜¯è‡ªåŠ¨é…ç½®æ²¡æœ‰ç”Ÿæ•ˆçš„ã€‚å¦‚æœæˆ‘ä»¬çš„è‡ªåŠ¨é…ç½®æ²¡æœ‰ç”Ÿæ•ˆä¼šä¸ä¼šå‡ºç°åœ¨Negative matchesä¸­å‘¢ï¼ŒæŠŠè‡ªåŠ¨é…ç½®ä¸­çš„æ¡ä»¶ç¨å¾®æ”¹ä¸€ä¸‹ï¼Œæ¥çœ‹çœ‹ï¼š @Configuration(proxyBeanMethods = false) @ConditionalOnBean(Marker.class) public class HelloStarterAutoConfiguration { @Bean public HelloStarterService getHelloStarterService() { return new HelloStarterService(); } } æŠŠæ¡ä»¶æ”¹æˆäº†@ConditionalOnBean(Marker.class)ï¼Œç”±äºåœ¨Spring contextç¯å¢ƒä¸­æ˜¯ä¸å­˜åœ¨Markerç±»å®ä¾‹çš„ï¼Œæ‰€ä»¥è‡ªåŠ¨é…ç½®æ˜¯ä¸ä¼šç”Ÿæ•ˆçš„ï¼Œé‡æ–°æ‰“åŒ…ï¼Œreimportä¸€ä¸‹mavenä¾èµ–ï¼Œç„¶åå¯åŠ¨springboot-webé¡¹ç›®åï¼Œä¼šçœ‹åˆ°è¿™æ ·çš„è¾“å‡ºæ—¥å¿—ï¼š *************************** APPLICATION FAILED TO START *************************** Description: Field helloStarterService in com.springboot.springbootweb.controller.Helloworld required a bean of type &#39;com.springboot.hello.service.HelloStarterService&#39; that could not be found. The injection point has the following annotations: - @org.springframework.beans.factory.annotation.Autowired(required=true) The following candidates were found but could not be injected: - Bean method &#39;getHelloStarterService&#39; in &#39;HelloStarterAutoConfiguration&#39; not loaded because @ConditionalOnBean (types: com.springboot.hello.marker.Marker; SearchStrategy: all) did not find any beans of type com.springboot.hello.marker.Marker Action: Consider revisiting the entries above or defining a bean of type &#39;com.springboot.hello.service.HelloStarterService&#39; in your configuration. è‡ªåŠ¨é…ç½®å¤±æ•ˆï¼Œå±æ€§æ³¨å…¥å¤±è´¥ï¼Œåº”ç”¨å¯åŠ¨å¤±è´¥ï¼æŠŠhelloStarterServiceè¿™ä¸ªå±æ€§æ³¨é‡Šæ‰ï¼š @RestController public class Helloworld { // @Autowired // private HelloStarterService helloStarterService; @RequestMapping public String helloworld() { return &quot;hello world&quot;; } @RequestMapping(&quot;/helloStarter&quot;) public String helloStarter() { // return helloStarterService.helloStarter(); return null; } } å†å¯åŠ¨ä¸‹ï¼ŒæœåŠ¡æ­£å¸¸å¯åŠ¨åçœ‹çœ‹æ—¥å¿—ï¼š ============================ CONDITIONS EVALUATION REPORT ============================ Positive matches: ----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class &#39;org.springframework.web.servlet.DispatcherServlet&#39; (OnClassCondition) - found &#39;session&#39; scope (OnWebApplicationCondition) ... ... Negative matches: ----------------- ... ... HelloStarterAutoConfiguration: Did not match: - @ConditionalOnBean (types: com.springboot.hello.marker.Marker; SearchStrategy: all) did not find any beans of type com.springboot.hello.marker.Marker (OnBeanCondition) ... ... é¢„æ–™ä¹‹ä¸­ï¼Œå¯¹å§ï¼é€šä¸ªè¿™ä¸ªæ—¥å¿—å°±å¯ä»¥çŸ¥é“è‡ªå®šä¹‰çš„è‡ªåŠ¨é…ç½®ç±»æœ‰æ²¡æœ‰ç”Ÿæ•ˆå•¦ï¼OKï¼æˆ‘ä»¬å»æ‰helloStarterServiceå±æ€§åŠæ–¹æ³•ä¸­çš„æ³¨é‡Šï¼Œå°†Starterä¸­çš„@ConditionalOnBeanæ”¹å›@ConditionalOnClassï¼Œé‡æ–°æ‰“åŒ…åï¼Œåœ¨é¡¹ç›®ä¸­reimportä¸€ä¸‹é¡¹ç›®ä¾èµ–ï¼Œè®©é¡¹ç›®é‡æ–°æ­£å¸¸å¯åŠ¨èµ·æ¥ã€‚ 10ã€åœ¨æµè§ˆå™¨ä¸­è¾“å…¥ï¼šhttp://localhost:8081/helloStarteråï¼Œå¯ä»¥çœ‹åˆ°ï¼š WOWï¼hello starter is working... åˆ°æ­¤å‘¢ï¼Œè‡ªå®šä¹‰Springboot Starterå°±æå®šäº†ã€‚å†æ¥æ€»ç»“ä¸‹æ­¥éª¤ï¼š åˆå§‹åŒ–ä¸€ä¸ªstarteré¡¹ç›® ç¼–å†™ä¸šåŠ¡é€»è¾‘ ç¼–å†™è‡ªåŠ¨é…ç½®ç±»åŠé…ç½®ç›¸åº”çš„é…ç½® å°†è‡ªåŠ¨é…ç½®ç±»åŠ å…¥åˆ°META-INF/spring.factoriesæ–‡ä»¶ä¸­ æ‰“åŒ…starter åœ¨é¡¹ç›®ä¸­å¼•ç”¨","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"Springbootè‡ªåŠ¨é…ç½®åŸç†è§£æ","slug":"tech-springboot-autoconfig","date":"2019-10-23T02:00:00.000Z","updated":"2019-10-24T13:10:49.497Z","comments":true,"path":"2019/10/23/tech-springboot-autoconfig/","link":"","permalink":"/2019/10/23/tech-springboot-autoconfig/","excerpt":"","text":"æœ‰äº†Springbootæ ¸å¿ƒæ³¨è§£çš„åŸºç¡€ä¹‹åå‘¢ï¼Œæ¥çœ‹çœ‹Springbootæ˜¯æ€ä¹ˆå®ç°è‡ªåŠ¨é…ç½®çš„ï¼Ÿé¦–å…ˆï¼Œæ¥çœ‹çœ‹å¯åŠ¨ç±»ï¼š @SpringBootApplication public class SpringbootWebApplication { public static void main(String[] args) { SpringApplication.run(SpringbootWebApplication.class, args); } } ä»runæ–¹æ³•è¿›å»ï¼Œç›´åˆ°ä»¥ä¸‹ä»£ç ï¼š public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) { // èµ„æºåŠ è½½å™¨ this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); // WEBç±»å‹æ¨æ–­ // ç”±äºæˆ‘ä»¬åœ¨POMé‡Œå¼•å…¥äº†spring-boot-starter-web,æ‰€ä»¥ç±»å‹æ¨æ–­åï¼š // this.webApplicationType = WebApplicationType.SERVLET // ä¹Ÿå°±è¯´ä¼šå¯åŠ¨ä¸€ä¸ªSERVLETå®¹å™¨ this.webApplicationType = WebApplicationType.deduceFromClasspath(); // è·å–å¹¶è®¾ç½®åº”ç”¨çš„åˆå§‹åŒ–å™¨ï¼šç”¨äºåœ¨refreshï¼ˆConfigurableApplicationContext#refreshï¼‰ä¹‹å‰åˆå§‹åŒ–Springçš„å›è°ƒæ¥å£(ApplicationContextInitializer#initialize) setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // è·å–å¹¶è®¾ç½®åº”ç”¨ç¨‹åºç›‘å¬å™¨ï¼šä»3.0å¼€å§‹ï¼Œä¸€ä¸ªApplicationListenerå¯ä»¥å£°æ˜æ„Ÿå…´è¶£çš„äº‹ä»¶ç±»å‹ã€‚å½“äº‹ä»¶è¢«æ³¨å†Œåˆ°Spring ApplicationContextæ—¶ï¼Œäº‹ä»¶ä¼šè¢«ç›¸åº”åœ°è¿‡æ»¤ï¼Œå¹¶ä¸”ç›‘å¬å™¨ä»…è°ƒç”¨åŒ¹é…çš„ç›‘å¬äº‹ä»¶ï¼ˆäº‹ä»¶è¿™ä¸ªåœ°æ–¹ä¼šèŠ±ä¸ªç« èŠ‚æ¥è¯´ä¸€ä¸‹ï¼‰ setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // æ¨æ–­è¿è¡Œçš„ä¸»ç±»ï¼Œè¿™ä¸ªåœ°æ–¹å°±æ˜¯ä¸Šé¢ç¼–å†™çš„ï¼šSpringbootWebApplication this.mainApplicationClass = deduceMainApplicationClass(); } ä¸Šé¢è¿™æ®µä»£ç ï¼Œå°±æ˜¯ä¸ºåé¢è¿è¡Œspringbootåšå¥½å‡†å¤‡ã€‚æ¥ç€å¾€ä¸‹åˆ°runæ–¹æ³•ï¼š // è¿è¡ŒSpring applicationï¼Œåˆ›å»ºå¹¶ä¸”åˆ·æ–°ä¸€ä¸ªæ–°çš„ApplicationContext public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); // headlesså±æ€§è®¾ç½®ä¸ç”¨ç®¡ configureHeadlessProperty(); // åŠ è½½SpringApplicationè¿è¡Œæ—¶çš„ç›‘å¬å™¨ï¼Œæ­¤æ—¶ä¼šè·å¾—ä¸€ä¸ªï¼šEventPublishingRunListener SpringApplicationRunListeners listeners = getRunListeners(args); // å¹¿æ’­ApplicationStartingEventäº‹ä»¶ listeners.starting(); try { // é»˜è®¤ApplicationArgumentsçš„å®ç°ï¼Œç”¨äºé…ç½®ç¯å¢ƒ ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // å› ä¸ºä¹‹å‰çš„ç±»å‹æ¨æ–­æ˜¯SERVLETï¼Œæ‰€ä»¥ä¼šå‡†å¤‡ä¸€ä¸ªStandardServletEnvironmentçš„ç¯å¢ƒï¼Œç„¶åé…ç½®propertySourceã€profileç­‰ï¼Œç„¶åä¼šé€šè¿‡EventPublishingRunListenerå°†è¯¥äº‹ä»¶å¹¿æ’­å‡ºå»åï¼Œå°†ç¯å¢ƒç»‘å®šåˆ°SpringApplication ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // è®¾ç½®è°ƒç”¨JavaBeançš„æ—¶å€™è®©Springä½¿ç”¨Introspector#IGNORE_ALL_BEANINFOæ¨¡å¼ï¼Œè¿™ä¸ªå°±ä¸ç®¡äº† configureIgnoreBeanInfo(environment); // æ§åˆ¶å°çš„bannerå“ªé‡Œæ¥çš„ï¼Œå°±æ˜¯è¿™é‡Œæ‰“å°çš„å•¦ï¼ // bannerå¯ä»¥è‡ªå®šä¹‰ï¼Œå¯ä»¥æ˜¯å›¾ç‰‡æˆ–æ˜¯textï¼Œå½“ç„¶ä¸¤ä¸ªéƒ½æœ‰ï¼Œä¹Ÿå¯ä»¥æ‰“å° Banner printedBanner = printBanner(environment); // å› ä¸ºä¹‹å‰çš„ç±»å‹æ¨æ–­æ˜¯SERVLETï¼Œæ‰€ä»¥ä¼šåˆ›å»ºä¸€ä¸ªAnnotationConfigServletWebServerApplicationContext context = createApplicationContext(); // é”™è¯¯åˆ†æçš„ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªï¼šFailureAnalyzers exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); // contextç¯å¢ƒè®¾ç½®ï¼Œè½¬æ¢å™¨å’Œæ ¼å¼åŒ–è®¾ç½®ï¼Œåº”ç”¨Initializersï¼ŒBeanå®šä¹‰åŠ è½½ç­‰ prepareContext(context, environment, listeners, applicationArguments, printedBanner); // æ ¸å¿ƒæ–¹æ³•å•¦ï¼Œè¿›å»ä¹‹åå‘¢ï¼Œä½ ä¼šå‘ç°æ˜¯Springçš„refreshæ–¹æ³•ï¼Œé¡¿æ—¶æ˜¯ä¸æ˜¯å°±ç†Ÿæ‚‰å•¦ refreshContext(context); // è¿™æ˜¯ä¸ªç©ºæ–¹æ³• afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); } // å¹¿æ’­ApplicationStartedEventäº‹ä»¶ listeners.started(context); // æ²¡å‘ç°æœ‰å•¥ç”¨ callRunners(context, applicationArguments); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); } try { // å¹¿æ’­ApplicationReadyEventäº‹ä»¶ listeners.running(context); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); } return context; } ä»refreshContext(context)è¿›å»ï¼Œç›´åˆ°refresh(): @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. // è°ƒç”¨åœ¨contextä¸­æ³¨å†Œä¸ºBeançš„å·¥å‚å¤„ç†å™¨ï¼Œè‡ªåŠ¨é…ç½®çš„æ ¸å¿ƒæ‰€åœ¨ invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // å®ä¾‹åŒ–Beanï¼ˆéæ‡’åŠ è½½ï¼‰ finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &#39;active&#39; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring&#39;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } è‡ªåŠ¨é…ç½®çš„æ ¸å¿ƒæ–¹æ³•ï¼Œä¸‹é¢ä¸€æ­¥æ­¥æ¥ï¼Œçœ‹çœ‹è¿™ä¸ªæ ¸å¿ƒæ–¹æ³•é‡Œéƒ½åœ¨å¹²å•¥ï¼š protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } } ç‚¹å‡»è¿›PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())ï¼š public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) { // Invoke BeanDefinitionRegistryPostProcessors first, if any. Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;(); if (beanFactory instanceof BeanDefinitionRegistry) { BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;(); List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;(); for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) { if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) { BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; registryProcessor.postProcessBeanDefinitionRegistry(registry); registryProcessors.add(registryProcessor); } else { regularPostProcessors.add(postProcessor); } } // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! // Separate between BeanDefinitionRegistryPostProcessors that implement // PriorityOrdered, Ordered, and the rest. List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;(); // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear. boolean reiterate = true; while (reiterate) { reiterate = false; postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (!processedBeans.contains(ppName)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); reiterate = true; } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); } // Now, invoke the postProcessBeanFactory callback of all processors handled so far. invokeBeanFactoryPostProcessors(registryProcessors, beanFactory); invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); } else { // Invoke factory processors registered with the context instance. invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory); } // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); // Separate between BeanFactoryPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;(); for (String ppName : postProcessorNames) { if (processedBeans.contains(ppName)) { // skip - already processed in first phase above } else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { orderedPostProcessorNames.add(ppName); } else { nonOrderedPostProcessorNames.add(ppName); } } // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); // è°ƒç”¨å·¥å‚å¤„ç†å™¨ï¼Œè¿›å…¥åˆ°è¿™ä¸ªæ–¹æ³• invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory); // Next, invoke the BeanFactoryPostProcessors that implement Ordered. List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size()); for (String postProcessorName : orderedPostProcessorNames) { orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); } sortPostProcessors(orderedPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory); // Finally, invoke all other BeanFactoryPostProcessors. List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size()); for (String postProcessorName : nonOrderedPostProcessorNames) { nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); } invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); // Clear cached merged bean definitions since the post-processors might have // modified the original metadata, e.g. replacing placeholders in values... beanFactory.clearMetadataCache(); } ç‚¹å‡»è¿›invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory): private static void invokeBeanFactoryPostProcessors( Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory) { for (BeanFactoryPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeanFactory(beanFactory); } } ç‚¹å‡»è¿›postProcessor.postProcessBeanFactory(beanFactory)ï¼Œè¿™ä¸ªåœ°æ–¹ï¼Œä¼šå‘ç°æœ‰å¾ˆå¤šçš„xxxProcessorï¼Œå…¶ä»–çš„ä¸ç”¨è¯´ï¼Œæˆ‘ä»¬è¿™é‡Œä»‹ç»è‡ªåŠ¨é…ç½®ï¼Œæ‰€ä»¥é€‰æ‹©ConfigurationClassPostProcessor#postProcessBeanFactoryè¿›å»ï¼š public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { int factoryId = System.identityHashCode(beanFactory); if (this.factoriesPostProcessed.contains(factoryId)) { throw new IllegalStateException( &quot;postProcessBeanFactory already called on this post-processor against &quot; + beanFactory); } this.factoriesPostProcessed.add(factoryId); if (!this.registriesPostProcessed.contains(factoryId)) { // BeanDefinitionRegistryPostProcessor hook apparently not supported... // Simply call processConfigurationClasses lazily at this point then. processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory); } enhanceConfigurationClasses(beanFactory); beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory)); } ç‚¹å‡»è¿›processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);: public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) { List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;(); String[] candidateNames = registry.getBeanDefinitionNames(); // è·å–@Configuration classçš„Beanå®šä¹‰ä¿¡æ¯ for (String beanName : candidateNames) { BeanDefinition beanDef = registry.getBeanDefinition(beanName); if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) { if (logger.isDebugEnabled()) { logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef); } } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) { configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); } } // Return immediately if no @Configuration classes were found if (configCandidates.isEmpty()) { return; } // Sort by previously determined @Order value, if applicable configCandidates.sort((bd1, bd2) -&gt; { int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition()); int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition()); return Integer.compare(i1, i2); }); // Detect any custom bean name generation strategy supplied through the enclosing application context SingletonBeanRegistry sbr = null; if (registry instanceof SingletonBeanRegistry) { sbr = (SingletonBeanRegistry) registry; if (!this.localBeanNameGeneratorSet) { BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton( AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR); if (generator != null) { this.componentScanBeanNameGenerator = generator; this.importBeanNameGenerator = generator; } } } if (this.environment == null) { this.environment = new StandardEnvironment(); } // Parse each @Configuration class // æ„é€ å¤„ç†@Configurationç±»çš„è§£æå™¨ ConfigurationClassParser parser = new ConfigurationClassParser( this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry); Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates); Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size()); do { // å¼€å§‹è§£æ@Configuration class parser.parse(candidates); parser.validate(); Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses()); configClasses.removeAll(alreadyParsed); // Read the model and create bean definitions based on its content if (this.reader == null) { this.reader = new ConfigurationClassBeanDefinitionReader( registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry()); } // æ³¨å†Œé…ç½®ç±»çš„Beanå®šä¹‰ä¿¡æ¯ this.reader.loadBeanDefinitions(configClasses); alreadyParsed.addAll(configClasses); candidates.clear(); if (registry.getBeanDefinitionCount() &gt; candidateNames.length) { String[] newCandidateNames = registry.getBeanDefinitionNames(); Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames)); Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;(); for (ConfigurationClass configurationClass : alreadyParsed) { alreadyParsedClasses.add(configurationClass.getMetadata().getClassName()); } for (String candidateName : newCandidateNames) { if (!oldCandidateNames.contains(candidateName)) { BeanDefinition bd = registry.getBeanDefinition(candidateName); if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp; !alreadyParsedClasses.contains(bd.getBeanClassName())) { candidates.add(new BeanDefinitionHolder(bd, candidateName)); } } } candidateNames = newCandidateNames; } } while (!candidates.isEmpty()); // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) { sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry()); } if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) { // Clear cache in externally provided MetadataReaderFactory; this is a no-op // for a shared cache since it&#39;ll be cleared by the ApplicationContext. ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache(); } } ç‚¹å‡»è¿›parser.parse(candidates)ï¼š public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) { for (BeanDefinitionHolder holder : configCandidates) { BeanDefinition bd = holder.getBeanDefinition(); try { if (bd instanceof AnnotatedBeanDefinition) { // ä½¿ç”¨annotationçš„beanè¿›å…¥è¿™ä¸ªæ–¹æ³•è¿›è¡Œè§£æ parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); } else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) { parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName()); } else { parse(bd.getBeanClassName(), holder.getBeanName()); } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex); } } this.deferredImportSelectorHandler.process(); } ç‚¹å‡»è¿›parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName())ï¼š protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException { processConfigurationClass(new ConfigurationClass(metadata, beanName)); } ç‚¹å‡»è¿›processConfigurationClass(new ConfigurationClass(metadata, beanName))ï¼Œè¿™ä¸ªç±»ä¼šè¢«é€’å½’è°ƒç”¨å¤„ç†é…ç½®ç±»ï¼š protected void processConfigurationClass(ConfigurationClass configClass) throws IOException { // æ˜¯å¦éœ€è¦è·³è¿‡è‡ªåŠ¨é…ç½®ï¼Œé…ç½®çš„@Conditionalå°±æ˜¯åœ¨è¿™ä¸ªåœ°æ–¹è§£æçš„ï¼Œè¿›å»çœ‹çœ‹æ€ä¹ˆè§£æçš„ if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) { return; } ConfigurationClass existingClass = this.configurationClasses.get(configClass); if (existingClass != null) { if (configClass.isImported()) { if (existingClass.isImported()) { existingClass.mergeImportedBy(configClass); } // Otherwise ignore new imported config class; existing non-imported class overrides it. return; } else { // Explicit bean definition found, probably replacing an import. // Let&#39;s remove the old one and go with the new one. this.configurationClasses.remove(configClass); this.knownSuperclasses.values().removeIf(configClass::equals); } } // Recursively process the configuration class and its superclass hierarchy. // é€’å½’å¤„ç†é…ç½®ç±»åŠçˆ¶ç±» SourceClass sourceClass = asSourceClass(configClass); do { sourceClass = doProcessConfigurationClass(configClass, sourceClass); } while (sourceClass != null); this.configurationClasses.put(configClass, configClass); } ç‚¹å‡»è¿›this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)ï¼š public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) { // è·³è¿‡ä¸æ»¡è¶³@Conditionalæ³¨è§£çš„Bean if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) { return false; } if (phase == null) { if (metadata instanceof AnnotationMetadata &amp;&amp; ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) { return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION); } return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN); } // è·å–beanä¸Šçš„conditionalæ³¨è§£ä¸­çš„ç±»æ¡ä»¶ List&lt;Condition&gt; conditions = new ArrayList&lt;&gt;(); for (String[] conditionClasses : getConditionClasses(metadata)) { for (String conditionClass : conditionClasses) { Condition condition = getCondition(conditionClass, this.context.getClassLoader()); conditions.add(condition); } } AnnotationAwareOrderComparator.sort(conditions); for (Condition condition : conditions) { ConfigurationPhase requiredPhase = null; if (condition instanceof ConfigurationCondition) { requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase(); } if ((requiredPhase == null || requiredPhase == phase) &amp;&amp; !condition.matches(this.context, metadata)) { return true; } } return false; } ç‚¹å‡»è¿›getConditionClasses(metadata)å»çœ‹çœ‹ï¼š private List&lt;String[]&gt; getConditionClasses(AnnotatedTypeMetadata metadata) { MultiValueMap&lt;String, Object&gt; attributes = metadata.getAllAnnotationAttributes(Conditional.class.getName(), true); Object values = (attributes != null ? attributes.get(&quot;value&quot;) : null); return (List&lt;String[]&gt;) (values != null ? values : Collections.emptyList()); } ç‚¹å‡»è¿›metadata.getAllAnnotationAttributes(Conditional.class.getName(), true)é‡Œé¢å¹²äº†å•¥ï¼š default MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes( String annotationName, boolean classValuesAsString) { Adapt[] adaptations = Adapt.values(classValuesAsString, true); return getAnnotations().stream(annotationName) .filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes)) .map(MergedAnnotation::withNonMergedAttributes) .collect(MergedAnnotationCollectors.toMultiValueMap(map -&gt; map.isEmpty() ? null : map, adaptations)); } è¿™æ˜¯AnnotatedTypeMetadataæ¥å£çš„ä¸€ä¸ªé»˜è®¤æ–¹æ³•ï¼Œè¿›å…¥getAnnotations()æ–¹æ³•ï¼š @Override public MergedAnnotations getAnnotations() { return this.annotations; } è¿™é‡Œè¿”å›çš„å°±æ˜¯åœ¨xxxAutoConfigurationç±»ä¸Šé…ç½®çš„æ³¨è§£ä¿¡æ¯äº†ï¼Œæ¯”å¦‚è¯´ï¼š @Configuration(proxyBeanMethods = false) @ConditionalOnMissingBean(name = &quot;demo&quot;, search = SearchStrategy.CURRENT) @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) @Conditional(Demo1.class) @EnableConfigurationProperties public class MyAutoConfiguration { ... } é‚£ä¹ˆè·å–åˆ°çš„å°±æ˜¯MyAutoConfigurationç±»ä¸Šçš„æ³¨è§£ä¿¡æ¯å•¦ã€‚ç„¶ååœ¨AnnotatedTypeMetadata#getAllAnnotationAttributesé‡Œä¼šè¿›è¡Œè¿‡æ»¤ï¼Œæœ€ç»ˆåªä¼šè¿‡æ»¤å‡ºæ¡ä»¶æ³¨è§£ï¼Œè¿™é‡Œåˆ—å­çš„è¯å°±æ˜¯@ConditionalOnMissingBeanå’Œ@Conditionalè¿™ä¸¤ä¸ªã€‚å›åˆ°shouldSkip()ä¸­çš„getCondition()æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•å¹²çš„äº‹æƒ…å°±æ˜¯å¯¹è§£æå‡ºæ¥çš„æ¡ä»¶ç±»è¿›è¡Œå®ä¾‹åŒ–ï¼Œæ¯”å¦‚åœ¨MyAutoConfigurationä¸­ï¼Œå°±æ˜¯å¯¹Demo.classè¿›è¡Œå®ä¾‹åŒ–ã€‚å†çœ‹çœ‹é‡Œé¢çš„condition.matches(this.context, metadata)æ–¹æ³•ï¼Œè¿™ä¸ªåœ°æ–¹çš„matchesæœ‰ä¸‰ä¸ªå¯é€‰é¡¹ï¼š ConditionEvaluationReport.AncestorsMatchedCondition#matches è¿™ä¸ªæ˜¯æŠ¥å‘Šconditionæ—¥å¿—ä¿¡æ¯çš„ï¼Œä¸ç”¨ç®¡ ProfileCondition#matches è¿™ä¸ªå°±æ¯”è¾ƒé‡è¦äº†ï¼Œä¼šåŒ¹é…@Profileæ³¨è§£ï¼Œè¿›è¡Œç¯å¢ƒåˆ‡æ¢ SpringBootCondition#matches(ConditionContext, AnnotatedTypeMetadata) é‡ä¸­ä¹‹é‡äº†ï¼Œè¿™ä¸ªæ˜¯ä½¿ç”¨Spring Bootçš„æ‰€æœ‰Conditionå®ç°çš„åŸºç¡€ï¼Œå¯ä»¥çœ‹åˆ°ç±»ä¸­æœ‰ä¸ªæ–¹æ³•public abstract ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata);æ˜¯ä¸ªæŠ½è±¡ç±»ï¼Œå®ç°è¿™ä¸ªæ–¹æ³•ï¼Œä¸å°±å¯ä»¥å®ç°è‡ªå·±çš„æ¡ä»¶æ³¨è§£äº†å—ã€‚è€Œä¸”ä½ ä¼šå‘ç°å¯¹äº@ConditionalXXXçš„æ³¨è§£å¤§éƒ¨åˆ†éƒ½ä¼šæœ‰OnXXXConditionæ¡ä»¶ç±»ä¸ä¹‹å¯¹åº”ï¼Œé‚£ä¹ˆé€šè¿‡è¿™ä¸ªå¯¹åº”å…³ç³»ä¸å°±å¯ä»¥æ‰¾åˆ°å¯¹åº”çš„æ¡ä»¶ç±»äº†å—ã€‚æ‰¾ä¸åˆ°çš„å°±åˆä¸ºä¸€ä¸ªæ¡ä»¶ç±»å•¦ï¼Œæ¯”å¦‚è¯´ï¼šConditionalOnBeanå’ŒConditionalOnMissingBeanå¯¹åº”çš„å°±æ˜¯OnBeanCondition ä»¥ä¸Šéƒ½å®ç°äº†Conditionæ¥å£ï¼š @FunctionalInterface public interface Condition { /** * Determine if the condition matches. * @param context the condition context * @param metadata metadata of the {@link org.springframework.core.type.AnnotationMetadata class} * or {@link org.springframework.core.type.MethodMetadata method} being checked * @return {@code true} if the condition matches and the component can be registered, * or {@code false} to veto the annotated component&#39;s registration */ boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata); } å½“ç„¶å•¦ï¼Œè¿™ä¸ªåœ°æ–¹ä½¿ç”¨çš„å°±æ˜¯SpringBootCondition#matches,è¿›å»çœ‹çœ‹ï¼š @Override public final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { String classOrMethodName = getClassOrMethodName(metadata); try { ConditionOutcome outcome = getMatchOutcome(context, metadata); logOutcome(classOrMethodName, outcome); recordEvaluation(context, classOrMethodName, outcome); return outcome.isMatch(); } catch (NoClassDefFoundError ex) { throw new IllegalStateException(&quot;Could not evaluate condition on &quot; + classOrMethodName + &quot; due to &quot; + ex.getMessage() + &quot; not found. Make sure your own configuration does not rely on &quot; + &quot;that class. This can also happen if you are &quot; + &quot;@ComponentScanning a springframework package (e.g. if you &quot; + &quot;put a @ComponentScan in the default package by mistake)&quot;, ex); } catch (RuntimeException ex) { throw new IllegalStateException(&quot;Error processing condition on &quot; + getName(metadata), ex); } } ä¸ç¬¦åˆè‡ªåŠ¨é…ç½®æ¡ä»¶çš„å°±è¿”å›falseï¼Œé‚£ä¹ˆshouldSkipå°±ä¼šè·³è¿‡ï¼Œä¸è¿›è¡Œè‡ªåŠ¨é…ç½®äº†ã€‚å›åˆ°ConfigurationClassParser#processConfigurationClassï¼Œçœ‹çœ‹å…¶ä¸­çš„doProcessConfigurationClass(configClass, sourceClass)æ–¹æ³•ï¼Œç‚¹è¿›å»çœ‹çœ‹ï¼š protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException { if (configClass.getMetadata().isAnnotated(Component.class.getName())) { // Recursively process any member (nested) classes first // é¦–å…ˆé€’å½’å¤„ç†åµŒå¥—çš„é…ç½®ç±» processMemberClasses(configClass, sourceClass); } // Process any @PropertySource annotations for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) { if (this.environment instanceof ConfigurableEnvironment) { processPropertySource(propertySource); } else { logger.info(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() + &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;); } } // Process any @ComponentScan annotations Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) { for (AnnotationAttributes componentScan : componentScans) { // The config class is annotated with @ComponentScan -&gt; perform the scan immediately Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed for (BeanDefinitionHolder holder : scannedBeanDefinitions) { BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition(); if (bdCand == null) { bdCand = holder.getBeanDefinition(); } if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) { parse(bdCand.getBeanClassName(), holder.getBeanName()); } } } } // Process any @Import annotations // å¤„ç†@Importï¼Œä¸»è¦æ¥çœ‹çœ‹è¿™ä¸ª processImports(configClass, sourceClass, getImports(sourceClass), true); // Process any @ImportResource annotations AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); if (importResource != null) { String[] resources = importResource.getStringArray(&quot;locations&quot;); Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;); for (String resource : resources) { String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); configClass.addImportedResource(resolvedResource, readerClass); } } // Process individual @Bean methods Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass); for (MethodMetadata methodMetadata : beanMethods) { configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); } // Process default methods on interfaces processInterfaces(configClass, sourceClass); // Process superclass, if any if (sourceClass.getMetadata().hasSuperClass()) { String superclass = sourceClass.getMetadata().getSuperClassName(); if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) { this.knownSuperclasses.put(superclass, configClass); // Superclass found, return its annotation metadata and recurse return sourceClass.getSuperClass(); } } // No superclass -&gt; processing is complete return null; } çœ‹åˆ°å…¶ä¸­çš„@PropertySourceã€@ComponentScanç­‰ï¼ŒæƒŠä¸æƒŠå–œï¼Œæ„ä¸æ„å¤–ï¼è§£æéƒ½åœ¨è¿™é‡Œé¢äº†ï¼ç‚¹è¿›processImports(configClass, sourceClass, getImports(sourceClass), true)å»çœ‹çœ‹ï¼š private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) { if (importCandidates.isEmpty()) { return; } if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) { this.problemReporter.error(new CircularImportProblem(configClass, this.importStack)); } else { this.importStack.push(configClass); try { for (SourceClass candidate : importCandidates) { if (candidate.isAssignable(ImportSelector.class)) { // Candidate class is an ImportSelector -&gt; delegate to it to determine imports Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); if (selector instanceof DeferredImportSelector) { this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector); } else { // è°ƒç”¨XXXSelectorçš„selectImportsæ–¹æ³•ï¼Œç‚¹è¿›å» String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames); processImports(configClass, currentSourceClass, importSourceClasses, false); } } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) { // Candidate class is an ImportBeanDefinitionRegistrar -&gt; // delegate to it to register additional bean definitions Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportBeanDefinitionRegistrar registrar = ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry); configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); } else { // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt; // process it as an @Configuration class this.importStack.registerImport( currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); processConfigurationClass(candidate.asConfigClass(configClass)); } } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to process import candidates for configuration class [&quot; + configClass.getMetadata().getClassName() + &quot;]&quot;, ex); } finally { this.importStack.pop(); } } } ç‚¹å‡»è¿›å»çœ‹çœ‹ï¼Œå‘ç°ä¼šæœ‰å¾ˆå¤šçš„XXXSelectorï¼Œå› ä¸ºæˆ‘ä»¬çœ‹çš„æ˜¯è‡ªåŠ¨é…ç½®ï¼Œæ‰€ä»¥å‘¢ï¼Œé€‰æ‹©AutoConfigurationImportSelector#selectImportsè¿›å»çœ‹çœ‹ã€‚ public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); // ä¸»è¦æ¥çœ‹çœ‹è¿™ä¸ªæ–¹æ³•å¹²å•¥çš„ AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } æˆ‘å˜ä¸ªå»ï¼Œæ˜¯ä¸æ˜¯å¾ˆç†Ÿæ‚‰ï¼Œä¹‹å‰è®²è§£@EnableAutoConfigurationæ˜¯ä¸æ˜¯è¯´è¿‡ï¼Œå†ç²˜ä¸‹ä»£ç ï¼š @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { ... } å¥½äº†ï¼Œç°åœ¨æ¥çœ‹çœ‹getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata);è¿™ä¸ªæ–¹æ³•å¹²å•¥çš„ï¼š protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } // åŠ è½½è‡ªåŠ¨é…ç½®ç±»çš„å…ƒæ•°æ®ä¿¡æ¯ AnnotationAttributes attributes = getAttributes(annotationMetadata); // è·å–è‡ªåŠ¨é…ç½®ç±»çš„å…¨é™å®šå List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } ç‚¹è¿›getCandidateConfigurations(annotationMetadata, attributes)å»çœ‹çœ‹ï¼š protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { // åŠ è½½è‡ªåŠ¨é…ç½®ç±»çš„å…¨é™å®šç±»å List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot; + &quot;are using a custom packaging, make sure that file is correct.&quot;); return configurations; } ç‚¹è¿›getSpringFactoriesLoaderFactoryClass()çœ‹çœ‹ï¼š protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() { return EnableAutoConfiguration.class; } è¿™ä¸å°±æ˜¯å¯åŠ¨è‡ªåŠ¨é…ç½®çš„æ³¨è§£å—ï¼Ÿæ‹¿è¿™ä¸ªå¹²ä»€ä¹ˆå‘¢ï¼Ÿå›åˆ°ä¸Šä¸€æ­¥ï¼Œç‚¹è¿›SpringFactoriesLoader.loadFactoryNameså»çœ‹çœ‹ï¼š public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) { String factoryTypeName = factoryType.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList()); } private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) { MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) { return result; } try { Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); while (urls.hasMoreElements()) { URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) { String factoryTypeName = ((String) entry.getKey()).trim(); for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) { result.add(factoryTypeName, factoryImplementationName.trim()); } } } cache.put(classLoader, result); return result; } catch (IOException ex) { throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; + FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex); } } çœ‹åˆ°ä¸‹é¢çš„loadSpringFactoriesæ–¹æ³•ä¸­æœ‰ä¸€ä¸ªFACTORIES_RESOURCE_LOCATIONï¼š public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;; è¿™ä¸å°±æ˜¯ä¸ªæ–‡ä»¶ä¹ˆï¼Œå¹²ä»€ä¹ˆçš„ï¼Œæ¥çœ‹çœ‹ï¼š org.springframework.boot.autoconfigure.EnableAutoConfigurationè¿™ä¸ªKEYä¸‹çš„è‡ªåŠ¨é…ç½®ä¸æ­¢å›¾ç‰‡çš„è¿™ç‚¹ï¼Œè¿˜æœ‰å¾ˆå¤šï¼Œå¯ä»¥ç‚¹è¿›å»çœ‹çœ‹ï¼çœ‹åˆ°è¿™é‡Œå‘¢ï¼Œæ˜¯ä¸æ˜¯å°±æ˜ç™½äº†ã€‚è¿™ä¸ªspring.factorieså°±æ˜¯ç”¨æ¥é…ç½®è‡ªåŠ¨é…ç½®ç±»çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåªè¦åœ¨é¡¹ç›®çš„META-INF/spring.factoriesä¸­é…ç½®ä¸Šè‡ªå®šä¹‰çš„è‡ªåŠ¨é…ç½®ç±»ï¼Œé‚£ä¹ˆSpring Bootå¯åŠ¨çš„æ—¶å€™ï¼Œå°±å¯ä»¥ç»™ä½ åšè‡ªåŠ¨é…ç½®çš„äº‹æƒ…äº†ï¼å›åˆ°getAutoConfigurationEntryæ–¹æ³•ï¼š protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); // è·å–è‡ªåŠ¨é…ç½®ç±»çš„å…¨é™å®šç±»å List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); // å»é‡å¤çš„è‡ªåŠ¨é…ç½®ç±» configurations = removeDuplicates(configurations); // è¿”å›éœ€è¦æ’é™¤çš„è‡ªåŠ¨é…ç½®ç±» Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); // æ£€æŸ¥éœ€è¦æ’é™¤çš„è‡ªåŠ¨é…ç½®æ˜¯å¦å­˜åœ¨ checkExcludedClasses(configurations, exclusions); // ç§»å‡ºè‡ªåŠ¨é…ç½®ç±» configurations.removeAll(exclusions); // æŒ‰ç…§è‡ªåŠ¨é…ç½®ç±»ä¸Šé…ç½®çš„@ConditionalXXXæ¡ä»¶è¿›è¡Œè¿‡æ»¤ // ä½¿ç”¨spring.factoriesæ–‡ä»¶ä¸­org.springframework.boot.autoconfigure.AutoConfigurationImportFilterå¯¹åº”çš„è¿‡æ»¤å™¨è¿›è¡Œè¿‡æ»¤ã€‚æœ‰ä¸‰ä¸ªè¿‡æ»¤å™¨ï¼š // org.springframework.boot.autoconfigure.condition.OnBeanCondition // org.springframework.boot.autoconfigure.condition.OnClassCondition // org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition // åˆ†åˆ«è°ƒç”¨è¿‡æ»¤å™¨ä¸­matchæ–¹æ³•è¿‡æ»¤å‡ºç¬¦åˆæ¡ä»¶çš„è‡ªåŠ¨é…ç½®ç±» configurations = filter(configurations, autoConfigurationMetadata); // å‘å¸ƒè‡ªåŠ¨é…ç½®äº‹ä»¶ // ä½¿ç”¨spring.factoriesæ–‡ä»¶ä¸­org.springframework.boot.autoconfigure.AutoConfigurationImportListenerå¯¹åº”çš„ç›‘å¬å™¨org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListenerå‘é€AutoConfigurationImportEventäº‹ä»¶ fireAutoConfigurationImportEvents(configurations, exclusions); // è¿”å›åŒ…å«å·²åˆ›å»ºå’Œå·²æ’é™¤çš„è‡ªåŠ¨é…ç½®å®ä½“ return new AutoConfigurationEntry(configurations, exclusions); } å›åˆ°processImportsæ–¹æ³•ï¼š private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) { if (importCandidates.isEmpty()) { return; } if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) { this.problemReporter.error(new CircularImportProblem(configClass, this.importStack)); } else { this.importStack.push(configClass); try { for (SourceClass candidate : importCandidates) { if (candidate.isAssignable(ImportSelector.class)) { // Candidate class is an ImportSelector -&gt; delegate to it to determine imports Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); if (selector instanceof DeferredImportSelector) { this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector); } else { String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames); processImports(configClass, currentSourceClass, importSourceClasses, false); } } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) { // Candidate class is an ImportBeanDefinitionRegistrar -&gt; // delegate to it to register additional bean definitions Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportBeanDefinitionRegistrar registrar = ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry); configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); } else { // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt; // process it as an @Configuration class this.importStack.registerImport( currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); processConfigurationClass(candidate.asConfigClass(configClass)); } } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to process import candidates for configuration class [&quot; + configClass.getMetadata().getClassName() + &quot;]&quot;, ex); } finally { this.importStack.pop(); } } } processImportsæ–¹æ³•ä¼šè¢«é€’å½’è°ƒç”¨ï¼Œç›´åˆ°æ‰€æœ‰çš„é…ç½®ç±»å¤„ç†å®Œæ¯•ã€‚ç„¶ååœ¨ConfigurationClassPostProcessor#processConfigBeanDefinitionsæ–¹æ³•ä¸­ï¼Œå°±ä¼šè°ƒç”¨this.reader.loadBeanDefinitions(configClasses)æ³¨å†ŒBeançš„å®šä¹‰ä¿¡æ¯ã€‚æœ€ååœ¨refresh()æ–¹æ³•ä¸­è°ƒç”¨finishBeanFactoryInitialization(beanFactory)æ–¹æ³•å®ä¾‹åŒ–Beanã€‚åˆ°æ­¤è‡ªåŠ¨é…ç½®çš„æºç åˆ†æå°±ç»“æŸå•¦ï¼Œæœ€åæ¥ä¸€ä¸ªå›¾æ€»ç»“ä¸€ä¸‹å¤§æ¦‚æµç¨‹ï¼š","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"Springbootæ ¸å¿ƒæ³¨è§£","slug":"tech-springboot-annotation","date":"2019-10-21T03:00:00.000Z","updated":"2019-10-23T14:33:42.111Z","comments":true,"path":"2019/10/21/tech-springboot-annotation/","link":"","permalink":"/2019/10/21/tech-springboot-annotation/","excerpt":"","text":"åœ¨å¼€å§‹ä»‹ç»Springbootè‡ªåŠ¨é…ç½®ä¹‹å‰ï¼Œæ¥çœ‹çœ‹Springbootæœ‰å“ªäº›æœ€æ ¸å¿ƒçš„æ³¨è§£ã€‚ç»§ç»­Springbootå¼€èƒƒèœï¼Œæ‰“å¼€SpringbootWebApplicationç±»åï¼Œå‘ç°è¯¥ç±»ä¸Šæœ‰ä¸”åªæœ‰ä¸€ä¸ªæ³¨è§£@SpringBootApplicationï¼Œæ¥çœ‹çœ‹è¿™ä¸ªæ˜¯æ³¨è§£æ‰€åŒ…å«çš„æ„æ€ï¼š@SpringBootApplication è¿™æ˜¯ä¸€ä¸ªä¾¿æ·çš„ç»„åˆæ³¨è§£ï¼Œä½¿ç”¨è¯¥æ³¨è§£æ„å‘³ç€ï¼š å¯ç”¨é…ç½®@SpringBootConfiguration è§¦å‘è‡ªåŠ¨é…ç½®@EnableAutoConfiguration ç»„ä»¶æ‰«æ@ComponentScan é…ç½®å±æ€§æ‰«æ@ConfigurationPropertiesScan ä¸€ä¸ªä¸ªæ¥çœ‹çœ‹éƒ½æ˜¯å•¥æ„æ€ï¼š @SpringBootConfiguration ç”¨äºåŠ è½½Springbootåº”ç”¨æ‰€éœ€è¦çš„é…ç½®ï¼Œå¹¶ä¸”æ ‡æ³¨å½“å‰ç±»æ˜¯é…ç½®ç±»ï¼Œå°†é…ç½®ç±»ä¸­å£°æ˜çš„ä¸€ä¸ªæˆ–æ˜¯å¤šä¸ªå·²@Beanæ³¨è§£æ ‡è®°çš„æ–¹æ³•çš„å®ä¾‹çº³å…¥åˆ°springå®¹å™¨ä¸­ï¼Œå¹¶ä¸”å®ä¾‹åå°±æ˜¯æ–¹æ³•åã€‚è¯¥æ³¨è§£åœ¨Springbootåº”ç”¨ä¸­å¯ä»¥ä½¿ç”¨æ¥æ›¿ä»£@Configurationï¼Œè¿™æ ·çš„è¯ï¼Œåœ¨è‡ªåŠ¨é…ç½®çš„æ—¶å€™ï¼Œå°±å¯ä»¥è¢«è‡ªåŠ¨å‘ç°äº†ï¼Œè¯¥æ³¨è§£æœ¬èº«å°±ç»„åˆäº†@Configurationæ³¨è§£ã€‚Springbootåº”ç”¨æœ‰ä¸”åªèƒ½åŒ…å«ä¸€ä¸ª@SpringBootConfigurationæ³¨è§£ã€‚ @EnableAutoConfiguration è¿™ä¸ªæ˜¯æ ¸å¿ƒä¸­çš„æ ¸å¿ƒæ³¨è§£å•¦ï¼ä½¿ç”¨è¯¥æ³¨è§£è¡¨ç¤ºå¼€å¯è‡ªåŠ¨é…ç½®åŠŸèƒ½ï¼Œspringåº”ç”¨ä¸Šä¸‹æ–‡å°±ä¼šè¯•ç€å»çŒœæµ‹å¹¶ä¸”é…ç½®ä½ æ‰€æœŸæœ›çš„beanã€‚å…¶å®å°±æ˜¯å°†æ‰€æœ‰ç¬¦åˆ@Conditionalæ³¨è§£çš„é…ç½®ç±»åŠ è½½åˆ°Springbootåˆ›å»ºçš„å®¹å™¨ä¸­ã€‚è‡ªåŠ¨é…ç½®ç±»æ˜¯åŸºäºä½ çš„classpathå’Œä½ å®šä¹‰äº†ä»€ä¹ˆæ ·çš„beanè€Œè¢«åº”ç”¨ã€‚æ¯”å¦‚è¯´ï¼šåœ¨ä½ çš„ç±»è·¯å¾„ä¸‹æœ‰tomcat-embedded.jarï¼Œé‚£å°±æ„å‘³ç€ä½ å¸Œæœ›æœ‰ä¸€ä¸ªTomcatServletWebServerFactoryï¼Œé™¤éä½ è‡ªå·±å®šä¹‰äº†TomcatServletWebServerFactorybeanã€‚ä½¿ç”¨@SpringBootApplicationæ„å‘³ç€è‡ªåŠ¨é…ç½®è‡ªåŠ¨ç”Ÿæ•ˆï¼Œå¦‚æœæœ‰ä½ ä¸éœ€è¦çš„é…ç½®ï¼Œå¯ä»¥ä½¿ç”¨#excludeName()è¿›è¡Œæ’é™¤ã€‚è‡ªåŠ¨é…ç½®çš„ç±»é€šå¸¸éƒ½æ˜¯Spring@Configurationçš„beanï¼Œè¿™äº›beané€šè¿‡ä½¿ç”¨SpringFactoriesLoaderæœºåˆ¶å®šä½ã€‚é€šå¸¸è‡ªåŠ¨é…ç½®ç±»éƒ½æ˜¯@Conditionalçš„beans(å¤§å¤šæ•°ä½¿ç”¨@ConditionalOnClasså’Œ@ConditionalOnMissingBeanæ³¨è§£)ã€‚åœ¨æ³¨è§£ä¸ŠåŒ…å«äº†ä¸¤ä¸ªæ³¨è§£ï¼š AutoConfigurationPackage å­˜å‚¨è‡ªåŠ¨é…ç½®çš„åŒ…ï¼Œåœ¨è¯¥åŒ…ä¸‹çš„beanéƒ½ä¼šè¢«æ³¨å†Œ @Import(AutoConfigurationPackages.Registrar.class) é€šè¿‡è¿™ä¸ªæ³¨è§£å»å­˜å‚¨åŸºç¡€åŒ…åŠæ³¨å†Œbeançš„å®šä¹‰ @Import(AutoConfigurationImportSelector.class) è¿™å°±æ˜¯è‡ªåŠ¨é…ç½®çš„æ ¸å¿ƒå•¦ï¼Œæ‰€æœ‰çš„è‡ªåŠ¨é…ç½®ç±»é€šè¿‡è¿™ä¸ªå¯¼å…¥è¿›æ¥ï¼Œé‚£ä¹ˆå®ƒæ˜¯åœ¨å“ªé‡Œè¢«è°ƒç”¨ï¼Œä»¥åŠè‡ªåŠ¨é…ç½®beanæ€ä¹ˆé…ç½®è¿›æ¥çš„ï¼Œç•™å¾…åé¢åˆ†æã€‚ @ComponentScan è¿™ä¸ªæ˜¯ç»„ä»¶æ‰«æï¼Œå¯ä»¥é…ç½®ç»„ä»¶æ‰«æçš„åŸºç¡€åŒ…ä»¥åŠè¿‡æ»¤å™¨ï¼ŒåŠ è½½ç¬¦åˆæ¡ä»¶çš„ç»„ä»¶æˆ–Beançš„å®šä¹‰ï¼Œæœ€ç»ˆå°†è¿™äº›BeanåŠ è½½åˆ°å®¹å™¨ä¸­ã€‚Springæ¡†æ¶é»˜è®¤ä»¥Springbootå¯åŠ¨ç±»æ‰€åœ¨çš„åŒ…ä¸ºbasePackageè¿›è¡Œæ‰«æï¼Œå½“ç„¶ä¹Ÿå¯ä»¥é€šè¿‡basePackageç­‰å±æ€§è‡ªå®šä¹‰æ‰«æèŒƒå›´ã€‚ @ConfigurationPropertiesScan æŒ‡å®šæ‰«æ@ConfigurationPropertiesç±»çš„åŸºç¡€åŒ… @Import(ConfigurationPropertiesScanRegistrar.class) é€šè¿‡æ‰«æä½¿ç”¨ImportBeanDefinitionRegistraræ³¨å†Œ@ConfigurationPropertiebeanå®šä¹‰ @EnableConfigurationProperties å¯¹å¸¦æœ‰@ConfigurationPropertiesæ³¨è§£çš„beanéƒ½å¯ä»¥ä½¿ç”¨æ ‡å‡†çš„æ–¹å¼è¢«æ³¨å†Œï¼Œæ¯”å¦‚è¯´ä½¿ç”¨@Beanæ–¹å¼ @Import(EnableConfigurationPropertiesRegistrar.class) å¯¹å¸¦æœ‰@EnableConfigurationPropertiesçš„ç±»ä½¿ç”¨ImportBeanDefinitionRegistrarè¿›è¡Œæ³¨å†Œ è¿™äº›æ³¨è§£åœ¨é¡¹ç›®é‡Œéƒ½å¯ä»¥ç‚¹è¿›å»çœ‹çœ‹ï¼Œç†Ÿæ‚‰ä¸€ä¸‹ï¼Œå¯¹è‡ªåŠ¨é…ç½®çš„è§£ææœ‰å¸®åŠ©ï¼Œè¦ä¸ç„¶ä¼šæ„Ÿåˆ°æœ‰ç‚¹æ‡µï¼æœ€åï¼Œæˆ‘ä»¬å†ç”¨ä¸€ä¸ªå›¾æ¥æ€»ç»“ä¸‹ï¼Œæ ‡çº¢çš„æ˜¯æ ¸å¿ƒä¸­çš„æ ¸å¿ƒï¼Œéœ€è¦é‡ç‚¹å…³æ³¨çš„åœ°æ–¹ï¼š","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"Springbootå¼€èƒƒèœ","slug":"tech-springboot-introduction","date":"2019-10-19T07:00:00.000Z","updated":"2019-10-22T15:09:53.027Z","comments":true,"path":"2019/10/19/tech-springboot-introduction/","link":"","permalink":"/2019/10/19/tech-springboot-introduction/","excerpt":"","text":"æˆ‘ä»¬åœ¨å­¦ä¹ æŸä¸€çŸ¥è¯†ä¹‹å‰ï¼Œæ€»å¾—æ¸…æ¥šå®ƒæ˜¯å¹²ä»€ä¹ˆçš„ï¼ˆWhatï¼‰ï¼Œæ€ä¹ˆå¹²ï¼ˆHowï¼‰ï¼Œä¸ºä»€ä¹ˆè¿™ä¹ˆå¹²ï¼ˆWhyï¼‰ï¼Œå¯¹å®ƒå‘å‡ºæ¥è‡ªçµé­‚çš„ä¸‰æ‹·é—®ã€‚æ¥çœ‹çœ‹å®˜ç½‘ä»‹ç»ï¼š ä¸€ã€Introducing Spring BootSpring Boot makes it easy to create stand-alone, production-grade Spring-based Applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. You can use Spring Boot to create Java applications that can be started by using java -jar or more traditional war deployments. We also provide a command line tool that runs â€œspring scriptsâ€. Our primary goals are: Provide a radically faster and widely accessible getting-started experience for all Spring development. Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults. Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration). Absolutely no code generation and no requirement for XML configuration. æ˜ç™½æ²¡ï¼Ÿä¸æ˜ç™½ï¼Ÿé‚£æˆ‘å°±ç”¨æˆ‘è¿™ä¸‰çº§éƒ½æ²¡è¿‡çš„è‹±è¯­æ°´å¹³ç®€å•çš„ç¿»è¯‘ä¸‹ï¼š Spring boot ä½¿å¾—åˆ›å»ºä»¥åŠè¿è¡ŒåŸºäºå•æœºç‰ˆæˆ–ç”Ÿäº§çº§åˆ«å¾—springåº”ç”¨å˜å¾—å¾ˆç®€å•ã€‚æˆ‘ä»¬æå‡ºäº†springå¹³å°å’Œç¬¬ä¸‰åº“çš„è§‚ç‚¹ï¼Œä½¿å¾—ä½ å¯ä»¥ä»¥æœ€å°å¾—ä»£ä»·å»å¼€å§‹å¹²ä½ æƒ³å¹²å¾—äº‹æƒ…ã€‚è€Œä¸”å¯¹äºå¤§éƒ¨åˆ†Spring Bootåº”ç”¨ç¨‹åºä»…ä»…éœ€è¦å¾ˆå°‘çš„é…ç½®å°±å¯ä»¥è¿è¡Œã€‚ ä½ å¯ä»¥ä½¿ç”¨Spring Bootå»åˆ›å»ºJavaå¼•ç”¨ï¼Œå¹¶ä¸”ä»¥java -jaræˆ–æ˜¯ä¼ ç»Ÿéƒ¨ç½²waråŒ…çš„æ–¹å¼è¿è¡Œã€‚æˆ‘ä»¬ä¹Ÿæä¾›äº†åœ¨å‘½ä»¤è¡Œä»¥&quot;spring scripts&quot;çš„æ–¹å¼è¿è¡Œ æˆ‘ä»¬çš„é‡è¦ç›®æ ‡æ˜¯ï¼š å¯¹äºæ‰€æœ‰çš„Springå¼€å‘ä»æ ¹æœ¬ä¸Šæä¾›ä¸€ä¸ªæ›´å¿«é€Ÿä¸”å¯å¹¿æ³›åœ°å®¹æ˜“è®¿é—®çš„å…¥é—¨ä½“éªŒ å¼€ç®±å³ç”¨ ç»™ä¸€ç³»åˆ—å¤§å‹é¡¹ç›®æä¾›é€šç”¨çš„éåŠŸèƒ½æ€§ç‰¹æ€§ï¼ˆä¾‹å¦‚åµŒå…¥å¼æœåŠ¡å™¨ã€å®‰å…¨æ€§ã€æŒ‡æ ‡ã€è¿è¡ŒçŠ¶å†µæ£€æŸ¥å’Œå¤–éƒ¨åŒ–é…ç½®ï¼‰ ç»å¯¹çš„æ— éœ€ä»£ç ç”Ÿæˆå’ŒXMLé…ç½® è¿˜æ²¡æ˜ç™½ï¼Ÿè‡ªè¡ŒGoogleå»å§ï¼ï¼ï¼ä¸‹é¢å¯ä»¥ä¸ç”¨ç¿»è¯‘äº†ã€‚ äºŒã€System RequirementsSpring Boot 2.2.0.RELEASE requires Java 8 and is compatible up to Java 13 (included). Spring Framework 5.2.0.RELEASE or above is also required. Explicit build support is provided for the following build tools: Build Tool Version Maven 3.3+ Gradle 5.x (4.10 is also supported but in a deprecated form) Spring Boot supports the following embedded servlet containers: Name Servlet Version Tomcat 9.0 4.0 Jetty 9.4 3.1 Undertow 2.0 4.0 You can also deploy Spring Boot applications to any Servlet 3.1+ compatible container. ä¸‰ã€Installing Spring Boot1ã€Installation Instructions for the Java Developerå¯¹äºå¼€å‘è€…æ¥è¯´çš„è¯ï¼Œä¸»è¦æœ‰ä¸‹é¢ä¸¤ç§æ–¹å¼ï¼šaã€Maven Installationä½¿ç”¨mavenå‰ï¼Œéœ€è¦å…ˆé…ç½®å¥½mavençš„ç¯å¢ƒã€‚å…¸å‹çš„è¯´ï¼Œä½ çš„Maven POMæ–‡ä»¶ä¼šç»§æ‰¿spring-boot-starter-parent projectå¹¶ä¸”ä¼šå£°æ˜ä¸€ä¸ªæˆ–è€…å¤šä¸ªstartersã€‚ä¸€ä¸ªå…¸å‹çš„pom.xmlæ–‡ä»¶ï¼š &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; bã€Gradle InstallationGradleæ²¡ç”¨è¿‡ï¼Œè‡ªè¡Œçœ‹æ–‡æ¡£å§ï¼ 1ã€Installing the Spring Boot CLIThe Spring Boot CLI (Command Line Interface) is a command line tool that you can use to quickly prototype with Spring. It lets you run Groovy scripts, which means that you have a familiar Java-like syntax without so much boilerplate code. You do not need to use the CLI to work with Spring Boot, but it is definitely the quickest way to get a Spring application off the ground. Spring Boot CLI æ˜¯ä¸€ä¸ªå‘½ä»¤è¡Œå·¥å…·ï¼Œåœ¨æˆ‘ä»¬ä½¿ç”¨Spring Bootçš„å·¥ä½œä¸­å¹¶ä¸éœ€è¦ä½¿ç”¨CLIã€‚ å››ã€Developing Your First Spring Boot ApplicationThis section describes how to develop a simple â€œHello World!â€ web application that highlights some of Spring Bootâ€™s key features. We use Maven to build this project, since most IDEs support it.è¿™ä¸ªéƒ¨åˆ†æ¼”ç¤ºæ€ä¹ˆä½¿ç”¨mavenéƒ¨ç½²ä¸€ä¸ªç®€å•çš„&quot;Hello World&quot;webåº”ç”¨ï¼Œå¤§éƒ¨åˆ†IDEséƒ½æ”¯æŒä½¿ç”¨maven Before we begin, open a terminal and run the following commands to ensure that you have valid versions of Java and Maven installed:å¼€å§‹ä¹‹å‰è¦ç¡®è®¤Javaå’ŒMavenå·²å®‰è£…å¥½ $ java -version java version &quot;1.8.0_102&quot; Java(TM) SE Runtime Environment (build 1.8.0_102-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode) $ mvn -v Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-17T14:33:14-04:00) Maven home: /usr/local/Cellar/maven/3.3.9/libexec Java version: 1.8.0_102, vendor: Oracle Corporation This sample needs to be created in its own folder. Subsequent instructions assume that you have created a suitable folder and that it is your current directory.ä¹Ÿå°±æ˜¯è¯´ï¼Œéœ€è¦åˆ›å»ºä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œå¹¶ä¸”å½“å‰çš„è·¯å¾„æ˜¯åœ¨ä½ åˆ›å»ºçš„æ–‡ä»¶ä¸‹ 1ã€Creating the POMWe need to start by creating a Maven pom.xml file. The pom.xml is the recipe that is used to build your project. Open your favorite text editor and add the following:ä½¿ç”¨å–œçˆ±çš„ç¼–è¾‘å·¥å…·åˆ›å»ºä¸€ä¸ªpom.xmlæ–‡ä»¶ &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Additional lines to be added here... --&gt; &lt;/project&gt; 2ã€Adding Classpath DependenciesSpring Bootæä¾›äº†å¾ˆå¤šçš„â€Startersâ€ï¼Œè®©ä½ å¯ä»¥æŠŠjarsæ·»åŠ åˆ°classpathä¸‹ã€‚æˆ‘ä»¬åœ¨POMä¸­çš„parentéƒ¨åˆ†æ·»åŠ äº†spring-boot-starter-parentï¼Œspring-boot-starter-parentæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„starterï¼Œå®ƒæä¾›äº†dependency-managementï¼Œå› æ­¤æˆ‘ä»¬åœ¨ä¾èµ–ä¸­å¯ä»¥è¸¢å‡ºversionæ ‡ç­¾ã€‚è¿™ä¸ªåœ°æ–¹æˆ‘ä»¬ä»¥æ·»åŠ spring-boot-starter-webä¸ºåˆ—ï¼š &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3ã€Writing the CodeTo finish our application, we need to create a single Java file. By default, Maven compiles sources from src/main/java, so you need to create that folder structure and then add a file named src/main/java/Example.java to contain the following code:mavené»˜è®¤æ˜¯åœ¨src/main/java/ä¸‹ç¼–è¯‘æºæ–‡ä»¶çš„ï¼Œå› æ­¤éœ€è¦å°†Example.javaç±»æ–‡ä»¶æ·»åŠ åˆ°src/main/java/ç›®å½•ä¸‹ import org.springframework.boot.*; import org.springframework.boot.autoconfigure.*; import org.springframework.web.bind.annotation.*; @RestController @EnableAutoConfiguration public class Example { @RequestMapping(&quot;/&quot;) String home() { return &quot;Hello World!&quot;; } public static void main(String[] args) { SpringApplication.run(Example.class, args); } } @RestControllerå’Œ@RequestMappingæ˜¯SpringMVCçš„æ³¨è§£ï¼@EnableAutoConfigurationè¿™æ˜¯ä¸€ä¸ªå¯¹äºSpring Bootæ¥è¯´ï¼Œå¾ˆæ ¸å¿ƒçš„ä¸€ä¸ªæ³¨è§£ï¼Œæˆ‘ä»¬åé¢å†è¯´ã€‚ 4ã€Running the ExampleAt this point, your application should work. Since you used the spring-boot-starter-parent POM, you have a useful run goal that you can use to start the application. Type mvn spring-boot:run from the root project directory to start the application. You should see output similar to the following:åœ¨é¡¹ç›®æ ¹ç›®å½•æ‰§è¡Œmvn spring-boot:runï¼Œå°±å¯ä»¥çœ‹åˆ°è¾“å‡ºæ—¥å¿— $ mvn spring-boot:run . ____ _ __ _ _ /\\\\ / ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) ....... . . . ....... . . . (log output here) ....... . . . ........ Started Example in 2.222 seconds (JVM running for 6.514) If you open a web browser to localhost:8080, you should see the following output: Hello World! To gracefully exit the application, press ctrl-cã€‚ 5ã€Creating an Executable JarTo create an executable jar, we need to add the spring-boot-maven-plugin to our pom.xml. To do so, insert the following lines just below the dependencies section:åœ¨pomæ–‡ä»¶ä¸­æ·»åŠ å¦‚ä¸‹ä¾èµ– &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; Noticeï¼šThe spring-boot-starter-parent POM includes &lt;executions&gt;configuration to bind the repackage goal. If you do not use the parent POM, you need to declare this configuration yourself. See the plugin documentation for details.spring-boot-starter-parentåŒ…å«äº†&lt;executions&gt;å¹¶ä¸”ç»‘å®šäº†repackageæ„å»ºï¼Œå› æ­¤æˆ‘ä»¬ç›´æ¥åŠ ä¸Šä¸Šé¢çš„ä¾èµ–å°±å¯ä»¥äº†ã€‚å¦‚æœä½ æ²¡æœ‰ä½¿ç”¨parent Pomçš„è¯å‘¢ï¼Œå°±éœ€è¦è‡ªå·±å£°æ˜æ„å»ºé…ç½®äº† Save your pom.xml and run mvn package from the command line, as follows: $ mvn package [INFO] Scanning for projects... [INFO] [INFO] ------------------------------------------------------------------------ [INFO] Building myproject 0.0.1-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO] .... .. [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject --- [INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar [INFO] [INFO] --- spring-boot-maven-plugin:2.2.0.RELEASE:repackage (default) @ myproject --- [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ If you look in the target directory, you should see myproject-0.0.1-SNAPSHOT.jar. The file should be around 10 MB in size. If you want to peek inside, you can use jar tvf, as follows:åœ¨targetç›®å½•ä¸­å¯ä»¥çœ‹åˆ°myproject-0.0.1-SNAPSHOT.jaræ–‡ä»¶ï¼Œä½¿ç”¨jar tvfå¯ä»¥æŸ¥çœ‹æ–‡ä»¶å†…éƒ¨çš„è¯¦ç»†ä¿¡æ¯ $ jar tvf target/myproject-0.0.1-SNAPSHOT.jar You should also see a much smaller file named myproject-0.0.1-SNAPSHOT.jar.original in the target directory. This is the original jar file that Maven created before it was repackaged by Spring Boot.åœ¨targetç›®å½•ä¸­è¿˜å¯ä»¥çœ‹åˆ°ä¸€ä¸ªmyproject-0.0.1-SNAPSHOT.jar.originalæ–‡ä»¶ï¼Œå®ƒæ˜¯mavenåœ¨ä½¿ç”¨Spring Bootæ‰“åŒ…ä¹‹å‰åˆ›å»ºçš„jaræºæ–‡ä»¶ To run that application, use the java -jar command, as follows: $ java -jar target/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\\\ / ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) ....... . . . ....... . . . (log output here) ....... . . . ........ Started Example in 2.536 seconds (JVM running for 2.864) As before, to exit the application, press ctrl-c. åˆ°æ­¤ä¸ºæ­¢å‘¢ï¼ŒSpring Bootçš„çµé­‚ä¸‰é—®å·²ç»æ¸…æ¥šäº†ã€‚ä½†æ˜¯å‘ç°ä¸€ä¸ªé—®é¢˜ï¼Œæ‰‹åŠ¨å»å†™POMï¼Œç„¶ååˆ›å»ºç±»æ–‡ä»¶ï¼Œè¿™ä¹ˆç®€å•å·¥ç¨‹è¿˜å¥½ï¼Œé‚£ä¹ˆå¤æ‚çš„å·¥ç¨‹çš„å‘¢ï¼Œè¿™ä¸ªè¿‡ç¨‹å°±å¾ˆç—›è‹¦äº†å•Šã€‚é‚£ä¹ˆæˆ‘ä»¬æ¥çœ‹çœ‹ä½¿ç”¨å·¥å…·æ€ä¹ˆåˆ›å»ºSpring Bootå·¥ç¨‹ï¼Œè¿™é‡Œä½¿ç”¨Ideaä¸ºä¾‹ï¼Œå…¶ä»–çš„IDEsç±»ä¼¼ï¼Œå°±ä¸ç”¨è¯´äº†å“ˆï¼ äº”ã€Develop Spring Boot Aplication With IDEA1ã€åˆå§‹åŒ–Spring Booté¡¹ç›®æ‰“å¼€Ideaï¼Œå·¦ä¸Šè§’ä¾æ¬¡ï¼šfile -&gt; new -&gt; projectåœ¨å¼¹å‡ºæ¡†ä¸­å·¦ä¾§èœå•ä¸­é€‰æ‹©Spring Initializråï¼Œåœ¨å³ä¾§é…ç½®SDKç‰ˆæœ¬ï¼Œä¸‹é¢é€‰æ‹©Defaultå°±è¡Œäº†ï¼Œç„¶ånexté…ç½®projectï¼Œç„¶ånexté€‰æ‹©éœ€è¦æ•´åˆçš„webä¸­é—´ä»¶ï¼Œè¿™é‡Œæœ‰å¾ˆå¤šçš„ä¸­é—´å¯é€‰ï¼Œå¯ä»¥éƒ½çœ‹çœ‹ï¼Œåé¢å°†è¦ä»‹ç»çš„ä¸€äº›ä¸­é—´ä»¶ä¹Ÿåœ¨é‡Œé¢ï¼ˆå¦‚ï¼šeurekaï¼‰ï¼Œç„¶ånexté…ç½®é¡¹ç›®å­˜å‚¨è·¯å¾„ï¼ŒFinishåï¼Œæ¥çœ‹ä¸‹ç›®å½•ç»“æ„ï¼šåˆ°è¿™é‡Œï¼Œä½ å°±å¯ä»¥ç›´æ¥å¯åŠ¨äº†ï¼š . ____ _ __ _ _ /\\\\ / ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) 2019-10-19 17:27:49.228 INFO 33267 --- [ main] c.s.s.SpringbootWebApplication : Starting SpringbootWebApplication on bogon with PID 33267 (/Users/dingzhongshen/SelfProjects/springblog/springboot-web/target/classes started by dingzhongshen in /Users/dingzhongshen/SelfProjects/springblog/springboot-web) 2019-10-19 17:27:49.232 INFO 33267 --- [ main] c.s.s.SpringbootWebApplication : No active profile set, falling back to default profiles: default 2019-10-19 17:27:50.389 INFO 33267 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 2019-10-19 17:27:50.398 INFO 33267 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2019-10-19 17:27:50.399 INFO 33267 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.27] 2019-10-19 17:27:50.469 INFO 33267 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2019-10-19 17:27:50.469 INFO 33267 --- [ main] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1150 ms 2019-10-19 17:27:50.631 INFO 33267 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService &#39;applicationTaskExecutor&#39; 2019-10-19 17:27:50.816 INFO 33267 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &#39;&#39; 2019-10-19 17:27:50.819 INFO 33267 --- [ main] c.s.s.SpringbootWebApplication : Started SpringbootWebApplication in 2.547 seconds (JVM running for 5.328) çœ‹åˆ°ä¸Šé¢æ—¥å¿—Tomcat started on port(s): 8080ï¼Œå°±è¡¨ç¤ºSpring Booté¡¹ç›®å·²ç»åˆå§‹åŒ–å¹¶å¯åŠ¨æˆåŠŸäº†ã€‚æ˜¯ä¸æ˜¯å¾ˆç®€å•ï¼Œå¼€ç®±å³ç”¨å˜›ï¼ï¼ï¼å½“ç„¶å•¦ï¼Œæˆ‘ä»¬è¦åšçš„äº‹æƒ…ï¼Œå¯ä¸æ­¢è¿™ä¹ˆå¤šï¼Œæ¥ä¸‹æ¥å†™ä¸ªControllerè¯•è¯•ã€‚ 2ã€é…ç½®Spring Bootåœ¨resourcesç›®å½•ä¸‹ï¼Œæœ‰ä¸ªapplication.propertiesæ–‡ä»¶ï¼Œæˆ‘å–œæ¬¢æ”¹æˆapplication.ymlã€‚ç„¶åå°±å¯ä»¥åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­é…ç½®éœ€è¦çš„å±æ€§å•¦ï¼Œæ¯”å¦‚å°†æœåŠ¡ç«¯å£å·æ”¹æˆ8081ï¼š server: port: 8081 å¯åŠ¨åº”ç”¨ä¹‹åï¼Œå°±å¯ä»¥åœ¨æ—¥å¿—é‡Œçœ‹åˆ°ç«¯å£è¢«æ”¹æˆï¼š o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8081 (http) with context path &#39;&#39; context pathä¹Ÿæ˜¯å¯ä»¥è¿›è¡Œé…ç½®çš„ã€‚åœ¨ä½¿ç”¨spring bootçš„æ—¶å€™ï¼Œéœ€è¦é›†æˆä¸€äº›å…¶ä»–çš„ä¸­é—´ä»¶ï¼Œå®ƒä»¬çš„å±æ€§éƒ½é…ç½®åœ¨è¿™é‡Œï¼Œé‚£ä»–ä»¬æœ‰ä»€ä¹ˆæ ·çš„å±æ€§ï¼Œæ€ä¹ˆçœ‹å‘¢ï¼Ÿåˆ«æ€¥ï¼Œåé¢ä»‹ç»ï¼ 3ã€ç¼–å†™é€»è¾‘ï¼ŒåŠ å…¥ç›¸åº”çš„å¯åŠ¨æ³¨è§£å¯åŠ¨ä¹‹åï¼Œåœ¨æµè§ˆå™¨æµè¾“å…¥http://localhost:8080/ï¼Œå°±å¯ä»¥çœ‹åˆ°æ•ˆæœå•¦ï¼Œæ˜¯ä¸æ˜¯å¾ˆé…·ï¼š Hello World! Bingoï¼ï¼ï¼æ­å–œä½ ï¼Œå·²ç»åˆæ­¥æŒæ¡Spring Bootå•¦ï¼ä¸Šé¢å·²ç»åŒ…å«äº†springbootæ•´åˆä¸­é—´ä»¶çš„è¿‡ç¨‹ï¼Œä¸çŸ¥é“ä½ å‘ç°æ²¡ï¼Œæ²¡æœ‰ï¼Ÿä¸æ€¥ï¼Œåé¢å†è¯´ï¼ç°åœ¨ä½ å°±åªéœ€è¦çŸ¥é“ï¼Œä½¿ç”¨Spring Bootæ— éå°±è¿™ä¹ˆ ä¸‰æ¿æ–§ å°±è¡Œäº†ï¼","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"åšå®¢é¦–ç¯‡","slug":"thought-introduction","date":"2019-10-18T10:08:08.000Z","updated":"2019-11-01T14:13:47.243Z","comments":true,"path":"2019/10/18/thought-introduction/","link":"","permalink":"/2019/10/18/thought-introduction/","excerpt":"","text":"å‰å› é‚£æ˜¯åœ¨å¾ˆä¹…å¾ˆä¹…ä»¥å‰ï¼Œæ€»è§‰å¾—å†™åšå®¢å¾ˆæµªè´¹æ—¶é—´ï¼ˆå…¶å®ç°åœ¨ä¹Ÿè¿™ä¹ˆè§‰å¾—ï¼Œå“ˆå“ˆå“ˆï¼‰ï¼Œä¸éœ€è¦å»å†™åšå®¢ï¼Œæœ‰ä»€ä¹ˆé—®é¢˜æˆ–æ˜¯éœ€è¦å­¦ä¹ ä»€ä¹ˆçŸ¥è¯†ï¼Œç›´æ¥å®˜ç½‘æˆ–æ˜¯Googleæˆ–æ˜¯åº¦å¨˜ä¸å°±è¡Œäº†å—ï¼Œæ¥å¾—å¤šå¿«å‘¢ã€‚ä¹Ÿæ€»ç›¸ä¿¡è‡ªå·±èƒ½å¤Ÿè®°ä½è‡ªå·±å­¦ä¹ çš„ä¸œè¥¿ï¼Œä¸éœ€è¦å»è®°ç¬”è®°ã€‚ç„¶åå‘¢ï¼Œæ¯æ¬¡å­¦ä¹ çŸ¥è¯†æˆ–æ˜¯é‡åˆ°é—®é¢˜éƒ½å»å®˜ç½‘æˆ–æ˜¯Googleæˆ–æ˜¯åº¦å¨˜ï¼Œä¹æ­¤ä¸ç–²ã€‚å…¶å®è¿™æ˜¯ä¸€ä¸ªä¸¥é‡çš„é—®é¢˜ï¼Œè‡ªå·±å´ä¸ä»¥ä¸ºæ„æˆ–æ˜¯æ²¡æœ‰å¯Ÿè§‰ã€‚ä½†æ˜¯ï¼Œæ—¶é—´ä¸€é•¿ï¼Œè¿™ä¸ªé—®é¢˜å°±ä¼šé€æ¸æš´éœ²å‡ºæ¥ï¼šå­¦ä¹ çš„ä¸œè¥¿æœ‰è‡ªå·±çš„ç†è§£å’Œæ„Ÿæ‚Ÿï¼Œä½†æ˜¯æ²¡æœ‰æ€»ç»“å‡ºæ¥ï¼Œå¾ˆé›¶æ•£ï¼Œæ²¡æœ‰è‡ªå·±çš„çŸ¥è¯†ç»“æ„ï¼Œå½¢æˆä¸äº†è‡ªå·±çš„çŸ¥è¯†ä½“ç³»ï¼å› ä¸ºè¶Šå¾€åï¼Œè‡ªå·±å°±ä¼šè§‰å¾—è‡ªå·±æ€ä¹ˆçªç„¶ä»€ä¹ˆéƒ½ä¸ä¼šäº†ï¼Œæ€ä¹ˆä»€ä¹ˆéƒ½æƒ³ä¸èµ·æ¥äº†ï¼ŒçŸ¥è¯†æ›´æ–°è¿­ä»£é‚£ä¹ˆå¿«ï¼Œè‡ªå·±æ€ä¹ˆè·Ÿä¸ä¸Šäº†å‘¢ï¼ˆä¹Ÿè®¸æœ‰é‚£ä¹ˆä¸€éƒ¨åˆ†å‡¤æ¯›æ£±è§’çš„äººä¸ä¼šè¿™ä¹ˆè§‰å¾—ï¼‰ï¼Ÿå­¦ä¹ çš„ä¸œè¥¿ï¼Œåœ¨å·¥ä½œä¸­å¹¶ä¸æ˜¯éƒ½ä¼šç”¨åˆ°ï¼Œä¸åšç¬”è®°ï¼Œæ€»ä¼šæœ‰å¿˜è®°çš„æ—¶å€™ï¼Œå¥½è®°æ€§ä¸å¦‚çƒ‚ç¬”å¤´ï¼ˆç¥–å…ˆçš„æ™ºæ…§ç»“æ™¶ï¼‰ã€‚ç†è§£çš„ä¸œè¥¿æˆ–æ˜¯ä¼šçš„ä¸œè¥¿å¿˜è®°äº†æ€ä¹ˆåŠå‘¢ï¼Ÿå®˜ç½‘æˆ–æ˜¯Googleæˆ–æ˜¯åº¦å¨˜å†æ¥å‡ éï¼Ÿå¦‚æ­¤å¾€å¤å—ï¼Ÿè®°ä¸ä½åˆä¸å–œæ¬¢èŠ±ç‚¹æ—¶é—´æ€»ç»“æˆè‡ªå·±çš„ä¸œè¥¿è®°ä¸‹æ¥ï¼Œè¶Šå¾€åï¼Œä¸è§‰å¾—è‡ªå·±ç›¸æ¯”ä¸å…¶ä»–äººæ¥è¯´ï¼Œå­¦ä¹ æ–°ä¸œè¥¿çš„æ—¶å€™è¶Šæ¥è¶Šæ…¢äº†å—ï¼Œä¸ä¼šè§‰å¾—è‡ªå·±è·Ÿä¸ä¸ŠçŸ¥è¯†çš„æ›´æ–°è¿­ä»£äº†å—ï¼Ÿèƒ½æ‰¾å›æ¥æœ€å¥½ï¼Œä½†æ˜¯æ¯æ¬¡éƒ½ä¼šèŠ±è´¹æ¯”è¾ƒå¤šçš„æ—¶é—´ï¼Œå¯èƒ½å°±è¦è½åå’¯ã€‚ä¸€æ—¶çš„æ„Ÿæ‚Ÿæˆ–æ˜¯ç†è§£å¯èƒ½å°±æ‰¾ä¸å›æ¥å’¯ï¼æ‰€ä»¥å‘¢ï¼Œè¿˜æ˜¯è¦è®°è®°ç¬”è®°æ»´ï¼Œæ‚ä¸ƒæ‚å…«çš„è®°å‘—ï¼ ç»è¿‡å…ˆå‰ä¹Ÿçœ‹è¿‡ä¸€äº›åšå®¢ï¼Œä¸æ˜¯å¾ˆç®€æ´ï¼Œæ€»ä¼šæœ‰å¾ˆå¤šé™¤äº†åšå®¢å†…å®¹ä¹‹å¤–çš„å…¶ä»–çš„ä¸€äº›ä¸œè¥¿ï¼ˆä¸ä¸¾ä¾‹äº†å“ˆï¼‰ï¼Œæƒ³ç€è‡ªå·±å»æä¸€ä¸ªï¼Œä¸è¿‡å¯¹äºåªä¼šåç«¯çš„æˆ‘æ¥è¯´ï¼ŒæŒ‘æˆ˜æ€§æ˜¯ä½•å…¶å¤§ã€‚ç„¶åå‘ç°äº†Hexoå’ŒHugoï¼Œä¸¤è€…æˆ‘é€‰æ‹©äº†Hexoï¼Œå¯èƒ½æ˜¯ä¸»é¢˜æ¯”è¾ƒå¤šå§ï¼ˆå“ˆå“ˆå“ˆï¼‰ã€‚æ­£å¥½é‚£æ®µæ—¶é—´æ­£åœ¨å­¦ä¹ Pythonï¼Œé‚£å¹²è„†å‰ç«¯ç”¨Hexoçš„ä¸»é¢˜ï¼ˆæˆ‘æŠŠHexoçš„é¡µé¢ç»™æ‘˜å‡ºæ¥äº†ï¼Œè´¹ç€åŠ²è‡ªå·±å¹²ï¼‰ï¼Œç„¶ååç«¯ç”¨Pythonçš„webæ¡†æ¶Djangoï¼ŒDBç”¨MongoDBã€‚ç„¶åå°±å¼€å¹²äº†ï¼Œæ­£å½“å¿«æŠŠç½‘ç«™æå¥½çš„æ—¶å€™ï¼Œæˆ‘å°±å»æŸå¤§å‚äº†ï¼Œåé¢å°±æ²¡æœ‰æ—¶é—´å†æã€‚ ç›´åˆ°æœ€è¿‘æ€»æƒ³ç€æŠŠä¹‹å‰çš„åšå®¢æèµ·æ¥ã€‚æ˜¯é€‰æ‹©ä¹‹å‰è‡ªå·±æçš„ç½‘ç«™å‘¢ï¼Œè¿˜æ˜¯ç›´æ¥ä½¿ç”¨Hexoæ­å»ºå‘¢ï¼Ÿä»æ—¶é—´å°±æ˜¯é‡‘é’±çš„è§’åº¦ï¼Œæˆ‘å…ˆé€‰æ‹©ç›´æ¥ä½¿ç”¨Hexoæ­å»ºèµ·æ¥ï¼Œåç»­å†åšæ‰“ç®—ä¹Ÿä¸è¿Ÿã€‚äºæ˜¯å‘¢ï¼Œå°±æœ‰äº†ç°åœ¨çš„å¤šå¤šåšå®¢ã€‚ ç»“æœé€šè¿‡è¿™ä¸ªåšå®¢ï¼Œå£®ç€èƒ†å­æŠŠå¸¸ç”¨çš„ä¸€äº›ä¸»æµæ¡†æ¶çš„å­¦ä¹ æ€»ç»“èµ·æ¥ï¼Œå½¢æˆè‡ªå·±çš„çŸ¥è¯†ç»“æ„ä½“ç³»ã€‚ä¸æ­¤åŒæ—¶ä¹Ÿå¯ä»¥è®°å½•è‡ªå·±ç”Ÿæ´»çš„ç‚¹ç‚¹æ»´æ»´ï¼Œåæ­£å°±æ˜¯æ‚ä¸ƒæ‚å…«çš„å‘—ï¼","categories":[{"name":"thought","slug":"thought","permalink":"/categories/thought/"}],"tags":[{"name":"éšæƒ³","slug":"éšæƒ³","permalink":"/tags/éšæƒ³/"}],"keywords":[{"name":"thought","slug":"thought","permalink":"/categories/thought/"}]}]}