{"meta":{"title":"DuoDuo","subtitle":null,"description":"好少年光芒万丈","author":"duoduo","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-10-19T13:56:24.456Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[爱思考のduoduo] 与&nbsp; duoduo&nbsp; （ 真情告白 ） 对话中... bot_ui_ini()","keywords":null},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-10-19T13:56:24.456Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-10-19T13:56:24.456Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-10-19T13:56:24.456Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-10-19T13:56:24.457Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-10-19T13:56:24.457Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-10-19T13:56:24.457Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-10-19T13:56:24.457Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"MyBatis介绍及基本用法","slug":"tech-mybatis-introduction","date":"2019-10-29T07:30:10.000Z","updated":"2019-10-30T16:12:21.952Z","comments":true,"path":"2019/10/29/tech-mybatis-introduction/","link":"","permalink":"/2019/10/29/tech-mybatis-introduction/","excerpt":"","text":"什么是MyBatisMyBatis官网给出的定义如下： MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings. MyBatis eliminates almost all of the JDBC code and manual setting of parameters and retrieval of results. MyBatis can use simple XML or Annotations for configuration and map primitives, Map interfaces and Java POJOs (Plain Old Java Objects) to database records. 英文不好？没关系，MyBatis给出了多种语言，其中就包括了中文版官方翻译，来看看： MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 怎么使用呢我们就不按照官网那样，初始化一个maven项目，然后再手动引入jar包的方式来构建项目了。我们直接使用Idea来初始化一个Springboot项目(目前大家都已在用Springboot开发项目，所以直接使用Spring Initializr初始化项目就OK。实在不想用，那就没办法咯！)，熟悉一下Springboot整合中间件的流程。打开Idea，依次File -&gt; new -&gt; Project... ， 选择Spring Initializr，配置好JDK，然后Next，配置好Project Metadata，然后next，可以选择Web -&gt; Spring Web方便后续做测试，重要的是选择SQL -&gt; MyBatis Framework 、MySQL Driver这两项，然后next配置项目名称及存储路径，Finish后呢，项目就建好了，顺带所需要的依赖包也引入到项目了。在开始之前呢，需要准备一个测试库（库名按你喜欢的方式命名就好）以及一个测试表（以下测试表为USER），准备好之后呢，就可以开始以下骚操作了。 编程式1、添加配置在resources包下新建mybatis-config.xml，然后加入下面模板内容： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; // 环境的名称，可以配置多个环境 &lt;environments default=&quot;development&quot;&gt; // 环境ID或数据源ID，通过ID可以配置多个数据源 &lt;environment id=&quot;development&quot;&gt; // 启用事物 &lt;transactionManager type=&quot;JDBC&quot;/&gt; // 构建连接池 &lt;dataSource type=&quot;POOLED&quot;&gt; // MySQL驱动 &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; // MySQL数据库链接地址 &lt;property name=&quot;url&quot; value=&quot;xxx&quot;/&gt; // 用户名 &lt;property name=&quot;username&quot; value=&quot;test&quot;/&gt; // 密码 &lt;property name=&quot;password&quot; value=&quot;test&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; // SQL查询语句配置 // SQL的配置方式有两种： // 第一种：采用这种XML的配置方式 // 第二种：使用注解的方式，直接在接口方法上使用@Select等注解，例如： // public interface UserMapper { // @Select(&quot;SELECT * FROM USER WHERE id = #{id}&quot;) // User selectUser(Long id); // } // 两种方式各有优劣，使用哪一种完全取决于自己或是开发团队 &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 依次填上你MySQL的相关信息即可。&lt;configuration&gt;节点中还可以配置&lt;typeHandlers&gt;，&lt;typeHandlers&gt;会对实体类的属性类型和数据库中的字段类型进行转换，MyBatis默认支持已很多的类型转换，比如：String和char、varchar互转，Date和TIMESTAMP互转等。还可以配置&lt;plugins&gt;，用于在处理数据前后做一些事情，比如常用的分页插件，用于对分页进行处理。还有其他的一些配置可以直接在官网的configuration配置文档中查看。MySQL链接的通常写法： jdbc:mysql://ip或domain:port/库名?characterEncoding=utf-8&amp;amp;autoReconnect=true&amp;amp;failOverReadOnly=false&amp;amp;serverTimezone=Asia/Shanghai 在xml中配置的时候，需要把&amp;进行转义为&amp;amp;否则会报错： Exception in thread &quot;main&quot; org.apache.ibatis.exceptions.PersistenceException: ### Error building SqlSession. ### Cause: org.apache.ibatis.builder.BuilderException: Error creating document instance. Cause: org.xml.sax.SAXParseException; lineNumber: 11; columnNumber: 126; 对实体 &quot;autoReconnect&quot; 的引用必须以 &#39;;&#39; 分隔符结尾。 at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) at org.apache.ibatis.session.SqlSessionFactoryBuilder.build(SqlSessionFactoryBuilder.java:80) at org.apache.ibatis.session.SqlSessionFactoryBuilder.build(SqlSessionFactoryBuilder.java:64) at com.springboot.mybatis.MyBatisTest.main(MyBatisTest.java:22) 2、构建User实体类新建包com.springboot.springbootmybatis.model，编写实体类User： public class User { /** * 主键 */ private Long id; /** * 用户ID */ private Long userId; /** * 用户名 */ private String name; /** * 用户的邮箱 */ private String email; /** * 创建时间 */ private Date createdTime; /** * 修改时间 */ private Date modifiedTime; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public Long getUserId() { return userId; } public void setUserId(Long userId) { this.userId = userId; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Date getCreatedTime() { return createdTime; } public void setCreatedTime(Date createdTime) { this.createdTime = createdTime; } public Date getModifiedTime() { return modifiedTime; } public void setModifiedTime(Date modifiedTime) { this.modifiedTime = modifiedTime; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, userId=&quot; + userId + &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, email=&#39;&quot; + email + &#39;\\&#39;&#39; + &quot;, createdTime=&quot; + createdTime + &quot;, modifiedTime=&quot; + modifiedTime + &#39;}&#39;; } } 3、构建UserDAO接口新建包com.springboot.springbootmybatis.dao，新建接口UserDAO： @Repository public interface UserDAO { /** * 根据主键查询User信息 * @param id * @return */ User selectUser(Long id); } 4、构建userMapper.xml文件在resources下新建mapper文件夹，然后新建userMapper.xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.springboot.dao.UserDAO&quot;&gt; &lt;resultMap id=&quot;baseResultMap&quot; type=&quot;com.springboot.model.User&quot;&gt; &lt;id column=&quot;ID&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;USER_ID&quot; jdbcType=&quot;BIGINT&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;NAME&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;EMAIL&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;CREATED_TIME&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createdTime&quot;/&gt; &lt;result column=&quot;MODIFIED_TIME&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;modifiedTime&quot;/&gt; &lt;/resultMap&gt; &lt;sql id=&quot;columns&quot;&gt; ID, USER_ID, NAME, EMAIL, CREATED_TIME, MODIFIED_TIME &lt;/sql&gt; &lt;select id=&quot;selectUser&quot; resultMap=&quot;baseResultMap&quot;&gt; select &lt;include refid=&quot;columns&quot;/&gt; from USER where id = #{id} &lt;/select&gt; &lt;/mapper&gt; 以上工作准备好之后，我们就可以开始测试了。新建包com.springboot.springbootmybatis.mybatis，然后新建类MyBatisTest，在main方法中，引入： public class MyBatisTest { public static void main(String[] args) throws Exception { String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { UserDAO mapper = session.getMapper(UserDAO.class); User user = mapper.selectUser(1L); System.out.println(user.toString()); } } } 来看看其中几个重要类的官方解释： SqlSessionFactoryBuilder：这个类可以被实例化、使用和丢弃，一旦创建了SqlSessionFactory，就不再需要它了。 因此SqlSessionFactoryBuilder实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要让其一直存在，以保证所有的 XML 解析资源可以被释放给更重要的事情。 SqlSessionFactory：SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用SqlSessionFactory的最佳实践是在应用运行期间不要重复创建多次，多次重建SqlSessionFactory被视为一种代码“坏味道（bad smell）”。因此SqlSessionFactory的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession：每个线程都应该有它自己的SqlSession实例。SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将SqlSession实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如Servlet框架中的HttpSession。 如果你现在正在使用一种Web框架，要考虑SqlSession放在一个和HTTP请求对象相似的作用域中。 换句话说，每次收到的HTTP请求，就可以打开一个SqlSession，返回一个响应，就关闭它。 这个关闭操作是很重要的，你应该把这个关闭操作放到finally块中以确保每次都能执行关闭。 在你的所有的代码中一致地使用以下确保SqlSession关闭的标准模式来保证所有数据库资源都能被正确地关闭： try (SqlSession session = sqlSessionFactory.openSession()) { // 你的应用逻辑代码 } 映射器实例，即xxxDAO或xxxMapper：映射器是一些由你创建的、绑定你映射的语句的接口。映射器接口的实例是从SqlSession中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的SqlSession相同的。尽管如此，映射器实例的最佳作用域是方法作用域。 也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可丢弃。 并不需要显式地关闭映射器实例，尽管在整个请求作用域保持映射器实例也不会有什么问题，但是你很快会发现，像SqlSession一样，在这个作用域上管理太多的资源的话会难于控制。 为了避免这种复杂性，最好把映射器放在方法作用域内。下面的示例就展示了这个实践： try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); // 你的应用逻辑代码 } 后面我们会对这几个重要的类进行源码分析，看看底层都干了啥，怎么干的。 好了，运行代码后，就可以看到正常的日志输出啦： 12:27:14.182 [main] DEBUG org.apache.ibatis.logging.LogFactory - Logging initialized using &#39;class org.apache.ibatis.logging.slf4j.Slf4jImpl&#39; adapter. 12:27:14.216 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections. 12:27:14.216 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections. 12:27:14.216 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections. 12:27:14.216 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections. 12:27:14.326 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection 12:27:15.277 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - Created connection 1709804316. 12:27:15.277 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@65e98b1c] 12:27:15.287 [main] DEBUG com.springboot.dao.UserDAO.selectUser - ==&gt; Preparing: select ID, USER_ID, NAME, EMAIL, CREATED_TIME, MODIFIED_TIME from USER where id = ? 12:27:15.321 [main] DEBUG com.springboot.dao.UserDAO.selectUser - ==&gt; Parameters: 1(Long) 12:27:15.348 [main] DEBUG com.springboot.dao.UserDAO.selectUser - &lt;== Total: 1 User{id=1, userId=28250, name=&#39;测试人&#39;, email=&#39;test@danke.com&#39;, createdTime=Tue Oct 29 11:49:44 CST 2019, modifiedTime=Tue Oct 29 11:49:44 CST 2019} 12:27:15.349 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@65e98b1c] 12:27:15.352 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@65e98b1c] 12:27:15.352 [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection 1709804316 to pool. 到这里，我们可能会去想：上面的USER实体类、UserDAO、UserMapper.xml这几个文件，我们都要自己去写吗，一个两个还好，多的话那岂不是很麻烦？非也。官方的大佬已经为我们考虑好了，完全可以使用MyBatis Generator(MBG)来生成嘛。所以，我们在分析了我们的业务后，把数据库表建好，就直接可以使用MBG生成代码啦，这不就很爽了吗！ 集成式我们保留dao、model、mapper，自动配置的时候，还需要使用，可别删了，要不还得再来一遍。把mybatis-config.xml注释掉或改为mybatis-config.xml.bak，MyBatisTest可以暂时不用管。 1、数据源及Mapper配置将resources/application.properties文件改为resources/application.yml，当然，不改也可以，个人喜欢yml方式配置而已。😎然后在application.yml文件中添加以下配置： spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver username: test password: test url: xxx mybatis: mapper-locations: classpath:/mapper/*.xml 注意：在写yml文件的时候，数据库链接url中的&amp;不需要转义成&amp;amp; 2、构建Controller新建包com.springboot.springbootmybatis.controller，新建类HelloUserController： @RestController public class HelloUserController { @Autowired private UserDAO userDAO; //如果在UserDAO上没有@Repository，此处会报红色的下划线 @GetMapping(&quot;/user/{userId}&quot;) public User getUser(@PathVariable(&quot;userId&quot;) Long userId) { User user = userDAO.selectUser(userId); return user; } } 这里省略了service层，直接在HelloUserController中调用DAO的接口。实际开发中，Service层是必不可少的。这里的@GetMapping 等于 @RequestMapping(method = RequestMethod.GET)，简单的写法，与之对应的还有@PostMapping。 3、添加Mapper扫描在主类SpringbootMybatisApplication上添加注解：@MapperScan(basePackages = &quot;com.springboot.springbootmybatis.dao&quot;)，配置扫描DAO接口的包路径。 @SpringBootApplication @MapperScan(basePackages = &quot;com.springboot.springbootmybatis.dao&quot;) public class SpringbootMybatisApplication { public static void main(String[] args) { SpringApplication.run(SpringbootMybatisApplication.class, args); } } 注意：添加的包需要和主类SpringbootMybatisApplication在同一级目录，否则扫描不到其中的类，之前Springboot的自动配置源码已分析过：会以主类SpringbootMybatisApplication所在的包为basePackage进行组件扫描。既然如此，那这里不配置@MapperScan行不行呢，当然不行！想想啊，我们面向接口编程，需要使用DAO接口去数据库查询数据，然后返回给调用者，如果接口没有实现类，那怎么去数据库查询呢。而且如果没有实现类，Spring怎么去实例化，怎么去帮助我们管理Bean呢，那不用Spring行不行？行啊，那就使用上面的那种方式，也可以实现，但是不觉得麻烦吗，所有的事情都要自己去做了，比如：Bean的创建及管理，连接的打开关闭等。那这里加了@MapperScan后，为什么就可以了呢？预知后事如何，请听下回分解！ 4、访问测试启动应用程序，在SpringbootMybatisApplication类中右键Run `SpringbootMybatisApplication `，就可以启动啦！在控制台，可以看到以下输出： o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &#39;&#39; 在浏览器中访问：http://localhost:8080/user/1，即可看到结果： {&quot;id&quot;:1,&quot;userId&quot;:11111,&quot;name&quot;:&quot;测试人&quot;,&quot;email&quot;:&quot;test@163.com&quot;,&quot;createdTime&quot;:&quot;2019-10-29 15:49:44&quot;,&quot;modifiedTime&quot;:&quot;2019-10-29 15:49:44&quot;} 小总结1、理解什么是MyBatisMyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 2、使用MyBatis的两种方式 编程式 集成式 3、SQL配置的两种方式 优点 缺点 XML方式 处理复杂的SQL；对SQL进行统一的管理 XML文件比较多；需要查找XML文件 注解方式 简洁直观；不需要去查找XML文件 不能很好的处理复杂的SQL，会比较混乱 4、重要类的作用域(Scope)和生命周期 作用域(Scope)和生命周期 SqlSessionFactoryBuilder 方法作用域（即：局部方法变量） SqlSessionFactory 应用作用域（单例模式或者静态单例模式） SqlSession 请求或方法作用域（放到finally块或try中，确保关闭） 映射器实例 方法作用域（即：局部方法变量） 5、开发业务顺序理解业务 -&gt; 建立库表 -&gt; 使用MBG生成相关代码","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"/tags/mybatis/"},{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"自定义Springboot的Starter","slug":"tech-springboot-custstarter","date":"2019-10-24T10:30:00.000Z","updated":"2019-10-25T14:08:08.479Z","comments":true,"path":"2019/10/24/tech-springboot-custstarter/","link":"","permalink":"/2019/10/24/tech-springboot-custstarter/","excerpt":"","text":"理解了Springboot自动配置原理后呢，来看看怎么自定义一个starter。Starter的命名也是有一定的规范的，官方说的是：spring-boot-starter-xxx被官方保留使用啦，第三方自定义就使用xxx-spring-boot-starter。 自定义Springboot Starter怎么初始化一个项目，请看这里吧！1、使用Idea初始化一个没有整合任何中间件的项目，也就是说在使用工具中的Spring Initializr初始化项目的时候，在选择中间件依赖的时候，啥也不选直接next。这里就初始化一个叫hello-spring-boot-starter的项目 2、在初始化出来的项目中，把生成的包及其中的类删掉，然后新建自己的包。 3、新建com.springboot.hello.marker包，这个包用于条件注解用，也就是说，自定义的自动配置必须在有这个类的前提下，自动配置才能生效。 public class Marker { } 4、新建com.springboot.hello.service包，用于写业务逻辑： public class HelloStarterService { public String helloStarter() { return &quot;WOW！Hello starter is working...&quot;; } } 5、新建 com.springboot.hello.autoconfig包，在其中编写自动配置类： @Configuration(proxyBeanMethods = false) @ConditionalOnClass(Marker.class) public class HelloStarterAutoConfiguration { @Bean public HelloStarterService getHelloStarterService() { return new HelloStarterService(); } } 如果业务逻辑中需要属性配置，还可以在类上加上@EnableConfigurationProperties({xxxProperties.class})，也可以在类上使用@EnableConfigurationProperties启用属性配置后，在方法上使用@ConfigurationProperties(prefix = &quot;xxx.xxx&quot;)进行配置，也可以加上其他的条件注解@ConditionalXXX进行更复杂的配置。 6、在resources包下新建META-INF/spring.factories文件，在其中写上自动配置类： # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.springboot.hello.autoconfig.HelloStarterAutoConfiguration 7、在打包之前删除pom.xml中的这段配置，否则回报找不到main类的错误： &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 8、在我们之前的springboot-web项目的pom.xml中引入这个starter： &lt;dependency&gt; &lt;groupId&gt;com.springboot&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 然后我们在项目的application.yml文件中打开debug： server: port: 8081 debug: true 上面的端口号，是之前改的，后面访问的时候就使用这个端口！ 9、在Helloworld.java中加入在自动配置类中写的HelloStarterService，这个地方不需要去实例化，就可以拿到接口HelloStarterService的实例，自动配置已经帮我们搞好了，直接用就行了。 @RestController public class Helloworld { @Autowired private HelloStarterService helloStarterService; @RequestMapping public String helloworld() { return &quot;hello world&quot;; } @RequestMapping(&quot;/helloStarter&quot;) public String helloStarter() { return helloStarterService.helloStarter(); } } 启动一下，见证奇迹的时刻。在启动后的日志中发现，自定义的自动配置类已经生效了： ============================ CONDITIONS EVALUATION REPORT ============================ Positive matches: ----------------- ... ... HelloStarterAutoConfiguration matched: - @ConditionalOnClass found required class &#39;com.springboot.hello.marker.Marker&#39; (OnClassCondition) ... ... Negative matches: ----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class &#39;javax.jms.ConnectionFactory&#39; (OnClassCondition) ... ... Positive matches是自动配置生效的，Negative matches是自动配置没有生效的。如果我们的自动配置没有生效会不会出现在Negative matches中呢，把自动配置中的条件稍微改一下，来看看： @Configuration(proxyBeanMethods = false) @ConditionalOnBean(Marker.class) public class HelloStarterAutoConfiguration { @Bean public HelloStarterService getHelloStarterService() { return new HelloStarterService(); } } 把条件改成了@ConditionalOnBean(Marker.class)，由于在Spring context环境中是不存在Marker类实例的，所以自动配置是不会生效的，重新打包，reimport一下maven依赖，然后启动springboot-web项目后，会看到这样的输出日志： *************************** APPLICATION FAILED TO START *************************** Description: Field helloStarterService in com.springboot.springbootweb.controller.Helloworld required a bean of type &#39;com.springboot.hello.service.HelloStarterService&#39; that could not be found. The injection point has the following annotations: - @org.springframework.beans.factory.annotation.Autowired(required=true) The following candidates were found but could not be injected: - Bean method &#39;getHelloStarterService&#39; in &#39;HelloStarterAutoConfiguration&#39; not loaded because @ConditionalOnBean (types: com.springboot.hello.marker.Marker; SearchStrategy: all) did not find any beans of type com.springboot.hello.marker.Marker Action: Consider revisiting the entries above or defining a bean of type &#39;com.springboot.hello.service.HelloStarterService&#39; in your configuration. 自动配置失效，属性注入失败，应用启动失败！把helloStarterService这个属性注释掉： @RestController public class Helloworld { // @Autowired // private HelloStarterService helloStarterService; @RequestMapping public String helloworld() { return &quot;hello world&quot;; } @RequestMapping(&quot;/helloStarter&quot;) public String helloStarter() { // return helloStarterService.helloStarter(); return null; } } 再启动下，服务正常启动后看看日志： ============================ CONDITIONS EVALUATION REPORT ============================ Positive matches: ----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class &#39;org.springframework.web.servlet.DispatcherServlet&#39; (OnClassCondition) - found &#39;session&#39; scope (OnWebApplicationCondition) ... ... Negative matches: ----------------- ... ... HelloStarterAutoConfiguration: Did not match: - @ConditionalOnBean (types: com.springboot.hello.marker.Marker; SearchStrategy: all) did not find any beans of type com.springboot.hello.marker.Marker (OnBeanCondition) ... ... 预料之中，对吧！通个这个日志就可以知道自定义的自动配置类有没有生效啦！OK！我们去掉helloStarterService属性及方法中的注释，将Starter中的@ConditionalOnBean改回@ConditionalOnClass，重新打包后，在项目中reimport一下项目依赖，让项目重新正常启动起来。 10、在浏览器中输入：http://localhost:8081/helloStarter后，可以看到： WOW！hello starter is working... 到此呢，自定义Springboot Starter就搞定了。再来总结下步骤： 初始化一个starter项目 编写业务逻辑 编写自动配置类及配置相应的配置 将自动配置类加入到META-INF/spring.factories文件中 打包starter 在项目中引用","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"Springboot自动配置原理解析","slug":"tech-springboot-autoconfig","date":"2019-10-23T02:00:00.000Z","updated":"2019-10-24T13:10:49.497Z","comments":true,"path":"2019/10/23/tech-springboot-autoconfig/","link":"","permalink":"/2019/10/23/tech-springboot-autoconfig/","excerpt":"","text":"有了Springboot核心注解的基础之后呢，来看看Springboot是怎么实现自动配置的？首先，来看看启动类： @SpringBootApplication public class SpringbootWebApplication { public static void main(String[] args) { SpringApplication.run(SpringbootWebApplication.class, args); } } 从run方法进去，直到以下代码： public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) { // 资源加载器 this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); // WEB类型推断 // 由于我们在POM里引入了spring-boot-starter-web,所以类型推断后： // this.webApplicationType = WebApplicationType.SERVLET // 也就说会启动一个SERVLET容器 this.webApplicationType = WebApplicationType.deduceFromClasspath(); // 获取并设置应用的初始化器：用于在refresh（ConfigurableApplicationContext#refresh）之前初始化Spring的回调接口(ApplicationContextInitializer#initialize) setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // 获取并设置应用程序监听器：从3.0开始，一个ApplicationListener可以声明感兴趣的事件类型。当事件被注册到Spring ApplicationContext时，事件会被相应地过滤，并且监听器仅调用匹配的监听事件（事件这个地方会花个章节来说一下） setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 推断运行的主类，这个地方就是上面编写的：SpringbootWebApplication this.mainApplicationClass = deduceMainApplicationClass(); } 上面这段代码，就是为后面运行springboot做好准备。接着往下到run方法： // 运行Spring application，创建并且刷新一个新的ApplicationContext public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); // headless属性设置不用管 configureHeadlessProperty(); // 加载SpringApplication运行时的监听器，此时会获得一个：EventPublishingRunListener SpringApplicationRunListeners listeners = getRunListeners(args); // 广播ApplicationStartingEvent事件 listeners.starting(); try { // 默认ApplicationArguments的实现，用于配置环境 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 因为之前的类型推断是SERVLET，所以会准备一个StandardServletEnvironment的环境，然后配置propertySource、profile等，然后会通过EventPublishingRunListener将该事件广播出去后，将环境绑定到SpringApplication ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 设置调用JavaBean的时候让Spring使用Introspector#IGNORE_ALL_BEANINFO模式，这个就不管了 configureIgnoreBeanInfo(environment); // 控制台的banner哪里来的，就是这里打印的啦！ // banner可以自定义，可以是图片或是text，当然两个都有，也可以打印 Banner printedBanner = printBanner(environment); // 因为之前的类型推断是SERVLET，所以会创建一个AnnotationConfigServletWebServerApplicationContext context = createApplicationContext(); // 错误分析的，会得到一个：FailureAnalyzers exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); // context环境设置，转换器和格式化设置，应用Initializers，Bean定义加载等 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 核心方法啦，进去之后呢，你会发现是Spring的refresh方法，顿时是不是就熟悉啦 refreshContext(context); // 这是个空方法 afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); } // 广播ApplicationStartedEvent事件 listeners.started(context); // 没发现有啥用 callRunners(context, applicationArguments); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); } try { // 广播ApplicationReadyEvent事件 listeners.running(context); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); } return context; } 从refreshContext(context)进去，直到refresh(): @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. // 调用在context中注册为Bean的工厂处理器，自动配置的核心所在 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 实例化Bean（非懒加载） finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &#39;active&#39; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring&#39;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } 自动配置的核心方法，下面一步步来，看看这个核心方法里都在干啥： protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } } 点击进PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())： public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) { // Invoke BeanDefinitionRegistryPostProcessors first, if any. Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;(); if (beanFactory instanceof BeanDefinitionRegistry) { BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;(); List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;(); for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) { if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) { BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; registryProcessor.postProcessBeanDefinitionRegistry(registry); registryProcessors.add(registryProcessor); } else { regularPostProcessors.add(postProcessor); } } // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! // Separate between BeanDefinitionRegistryPostProcessors that implement // PriorityOrdered, Ordered, and the rest. List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;(); // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear. boolean reiterate = true; while (reiterate) { reiterate = false; postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) { if (!processedBeans.contains(ppName)) { currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); reiterate = true; } } sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); } // Now, invoke the postProcessBeanFactory callback of all processors handled so far. invokeBeanFactoryPostProcessors(registryProcessors, beanFactory); invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); } else { // Invoke factory processors registered with the context instance. invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory); } // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); // Separate between BeanFactoryPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;(); for (String ppName : postProcessorNames) { if (processedBeans.contains(ppName)) { // skip - already processed in first phase above } else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { orderedPostProcessorNames.add(ppName); } else { nonOrderedPostProcessorNames.add(ppName); } } // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); // 调用工厂处理器，进入到这个方法 invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory); // Next, invoke the BeanFactoryPostProcessors that implement Ordered. List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size()); for (String postProcessorName : orderedPostProcessorNames) { orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); } sortPostProcessors(orderedPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory); // Finally, invoke all other BeanFactoryPostProcessors. List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size()); for (String postProcessorName : nonOrderedPostProcessorNames) { nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); } invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); // Clear cached merged bean definitions since the post-processors might have // modified the original metadata, e.g. replacing placeholders in values... beanFactory.clearMetadataCache(); } 点击进invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory): private static void invokeBeanFactoryPostProcessors( Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory) { for (BeanFactoryPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeanFactory(beanFactory); } } 点击进postProcessor.postProcessBeanFactory(beanFactory)，这个地方，会发现有很多的xxxProcessor，其他的不用说，我们这里介绍自动配置，所以选择ConfigurationClassPostProcessor#postProcessBeanFactory进去： public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { int factoryId = System.identityHashCode(beanFactory); if (this.factoriesPostProcessed.contains(factoryId)) { throw new IllegalStateException( &quot;postProcessBeanFactory already called on this post-processor against &quot; + beanFactory); } this.factoriesPostProcessed.add(factoryId); if (!this.registriesPostProcessed.contains(factoryId)) { // BeanDefinitionRegistryPostProcessor hook apparently not supported... // Simply call processConfigurationClasses lazily at this point then. processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory); } enhanceConfigurationClasses(beanFactory); beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory)); } 点击进processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);: public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) { List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;(); String[] candidateNames = registry.getBeanDefinitionNames(); // 获取@Configuration class的Bean定义信息 for (String beanName : candidateNames) { BeanDefinition beanDef = registry.getBeanDefinition(beanName); if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) { if (logger.isDebugEnabled()) { logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef); } } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) { configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); } } // Return immediately if no @Configuration classes were found if (configCandidates.isEmpty()) { return; } // Sort by previously determined @Order value, if applicable configCandidates.sort((bd1, bd2) -&gt; { int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition()); int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition()); return Integer.compare(i1, i2); }); // Detect any custom bean name generation strategy supplied through the enclosing application context SingletonBeanRegistry sbr = null; if (registry instanceof SingletonBeanRegistry) { sbr = (SingletonBeanRegistry) registry; if (!this.localBeanNameGeneratorSet) { BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton( AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR); if (generator != null) { this.componentScanBeanNameGenerator = generator; this.importBeanNameGenerator = generator; } } } if (this.environment == null) { this.environment = new StandardEnvironment(); } // Parse each @Configuration class // 构造处理@Configuration类的解析器 ConfigurationClassParser parser = new ConfigurationClassParser( this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry); Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates); Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size()); do { // 开始解析@Configuration class parser.parse(candidates); parser.validate(); Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses()); configClasses.removeAll(alreadyParsed); // Read the model and create bean definitions based on its content if (this.reader == null) { this.reader = new ConfigurationClassBeanDefinitionReader( registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry()); } // 注册配置类的Bean定义信息 this.reader.loadBeanDefinitions(configClasses); alreadyParsed.addAll(configClasses); candidates.clear(); if (registry.getBeanDefinitionCount() &gt; candidateNames.length) { String[] newCandidateNames = registry.getBeanDefinitionNames(); Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames)); Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;(); for (ConfigurationClass configurationClass : alreadyParsed) { alreadyParsedClasses.add(configurationClass.getMetadata().getClassName()); } for (String candidateName : newCandidateNames) { if (!oldCandidateNames.contains(candidateName)) { BeanDefinition bd = registry.getBeanDefinition(candidateName); if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp; !alreadyParsedClasses.contains(bd.getBeanClassName())) { candidates.add(new BeanDefinitionHolder(bd, candidateName)); } } } candidateNames = newCandidateNames; } } while (!candidates.isEmpty()); // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) { sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry()); } if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) { // Clear cache in externally provided MetadataReaderFactory; this is a no-op // for a shared cache since it&#39;ll be cleared by the ApplicationContext. ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache(); } } 点击进parser.parse(candidates)： public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) { for (BeanDefinitionHolder holder : configCandidates) { BeanDefinition bd = holder.getBeanDefinition(); try { if (bd instanceof AnnotatedBeanDefinition) { // 使用annotation的bean进入这个方法进行解析 parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); } else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) { parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName()); } else { parse(bd.getBeanClassName(), holder.getBeanName()); } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex); } } this.deferredImportSelectorHandler.process(); } 点击进parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName())： protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException { processConfigurationClass(new ConfigurationClass(metadata, beanName)); } 点击进processConfigurationClass(new ConfigurationClass(metadata, beanName))，这个类会被递归调用处理配置类： protected void processConfigurationClass(ConfigurationClass configClass) throws IOException { // 是否需要跳过自动配置，配置的@Conditional就是在这个地方解析的，进去看看怎么解析的 if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) { return; } ConfigurationClass existingClass = this.configurationClasses.get(configClass); if (existingClass != null) { if (configClass.isImported()) { if (existingClass.isImported()) { existingClass.mergeImportedBy(configClass); } // Otherwise ignore new imported config class; existing non-imported class overrides it. return; } else { // Explicit bean definition found, probably replacing an import. // Let&#39;s remove the old one and go with the new one. this.configurationClasses.remove(configClass); this.knownSuperclasses.values().removeIf(configClass::equals); } } // Recursively process the configuration class and its superclass hierarchy. // 递归处理配置类及父类 SourceClass sourceClass = asSourceClass(configClass); do { sourceClass = doProcessConfigurationClass(configClass, sourceClass); } while (sourceClass != null); this.configurationClasses.put(configClass, configClass); } 点击进this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)： public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) { // 跳过不满足@Conditional注解的Bean if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) { return false; } if (phase == null) { if (metadata instanceof AnnotationMetadata &amp;&amp; ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) { return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION); } return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN); } // 获取bean上的conditional注解中的类条件 List&lt;Condition&gt; conditions = new ArrayList&lt;&gt;(); for (String[] conditionClasses : getConditionClasses(metadata)) { for (String conditionClass : conditionClasses) { Condition condition = getCondition(conditionClass, this.context.getClassLoader()); conditions.add(condition); } } AnnotationAwareOrderComparator.sort(conditions); for (Condition condition : conditions) { ConfigurationPhase requiredPhase = null; if (condition instanceof ConfigurationCondition) { requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase(); } if ((requiredPhase == null || requiredPhase == phase) &amp;&amp; !condition.matches(this.context, metadata)) { return true; } } return false; } 点击进getConditionClasses(metadata)去看看： private List&lt;String[]&gt; getConditionClasses(AnnotatedTypeMetadata metadata) { MultiValueMap&lt;String, Object&gt; attributes = metadata.getAllAnnotationAttributes(Conditional.class.getName(), true); Object values = (attributes != null ? attributes.get(&quot;value&quot;) : null); return (List&lt;String[]&gt;) (values != null ? values : Collections.emptyList()); } 点击进metadata.getAllAnnotationAttributes(Conditional.class.getName(), true)里面干了啥： default MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes( String annotationName, boolean classValuesAsString) { Adapt[] adaptations = Adapt.values(classValuesAsString, true); return getAnnotations().stream(annotationName) .filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes)) .map(MergedAnnotation::withNonMergedAttributes) .collect(MergedAnnotationCollectors.toMultiValueMap(map -&gt; map.isEmpty() ? null : map, adaptations)); } 这是AnnotatedTypeMetadata接口的一个默认方法，进入getAnnotations()方法： @Override public MergedAnnotations getAnnotations() { return this.annotations; } 这里返回的就是在xxxAutoConfiguration类上配置的注解信息了，比如说： @Configuration(proxyBeanMethods = false) @ConditionalOnMissingBean(name = &quot;demo&quot;, search = SearchStrategy.CURRENT) @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) @Conditional(Demo1.class) @EnableConfigurationProperties public class MyAutoConfiguration { ... } 那么获取到的就是MyAutoConfiguration类上的注解信息啦。然后在AnnotatedTypeMetadata#getAllAnnotationAttributes里会进行过滤，最终只会过滤出条件注解，这里列子的话就是@ConditionalOnMissingBean和@Conditional这两个。回到shouldSkip()中的getCondition()方法，这个方法干的事情就是对解析出来的条件类进行实例化，比如在MyAutoConfiguration中，就是对Demo.class进行实例化。再看看里面的condition.matches(this.context, metadata)方法，这个地方的matches有三个可选项： ConditionEvaluationReport.AncestorsMatchedCondition#matches 这个是报告condition日志信息的，不用管 ProfileCondition#matches 这个就比较重要了，会匹配@Profile注解，进行环境切换 SpringBootCondition#matches(ConditionContext, AnnotatedTypeMetadata) 重中之重了，这个是使用Spring Boot的所有Condition实现的基础，可以看到类中有个方法public abstract ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata);是个抽象类，实现这个方法，不就可以实现自己的条件注解了吗。而且你会发现对于@ConditionalXXX的注解大部分都会有OnXXXCondition条件类与之对应，那么通过这个对应关系不就可以找到对应的条件类了吗。找不到的就合为一个条件类啦，比如说：ConditionalOnBean和ConditionalOnMissingBean对应的就是OnBeanCondition 以上都实现了Condition接口： @FunctionalInterface public interface Condition { /** * Determine if the condition matches. * @param context the condition context * @param metadata metadata of the {@link org.springframework.core.type.AnnotationMetadata class} * or {@link org.springframework.core.type.MethodMetadata method} being checked * @return {@code true} if the condition matches and the component can be registered, * or {@code false} to veto the annotated component&#39;s registration */ boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata); } 当然啦，这个地方使用的就是SpringBootCondition#matches,进去看看： @Override public final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { String classOrMethodName = getClassOrMethodName(metadata); try { ConditionOutcome outcome = getMatchOutcome(context, metadata); logOutcome(classOrMethodName, outcome); recordEvaluation(context, classOrMethodName, outcome); return outcome.isMatch(); } catch (NoClassDefFoundError ex) { throw new IllegalStateException(&quot;Could not evaluate condition on &quot; + classOrMethodName + &quot; due to &quot; + ex.getMessage() + &quot; not found. Make sure your own configuration does not rely on &quot; + &quot;that class. This can also happen if you are &quot; + &quot;@ComponentScanning a springframework package (e.g. if you &quot; + &quot;put a @ComponentScan in the default package by mistake)&quot;, ex); } catch (RuntimeException ex) { throw new IllegalStateException(&quot;Error processing condition on &quot; + getName(metadata), ex); } } 不符合自动配置条件的就返回false，那么shouldSkip就会跳过，不进行自动配置了。回到ConfigurationClassParser#processConfigurationClass，看看其中的doProcessConfigurationClass(configClass, sourceClass)方法，点进去看看： protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException { if (configClass.getMetadata().isAnnotated(Component.class.getName())) { // Recursively process any member (nested) classes first // 首先递归处理嵌套的配置类 processMemberClasses(configClass, sourceClass); } // Process any @PropertySource annotations for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) { if (this.environment instanceof ConfigurableEnvironment) { processPropertySource(propertySource); } else { logger.info(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() + &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;); } } // Process any @ComponentScan annotations Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) { for (AnnotationAttributes componentScan : componentScans) { // The config class is annotated with @ComponentScan -&gt; perform the scan immediately Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed for (BeanDefinitionHolder holder : scannedBeanDefinitions) { BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition(); if (bdCand == null) { bdCand = holder.getBeanDefinition(); } if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) { parse(bdCand.getBeanClassName(), holder.getBeanName()); } } } } // Process any @Import annotations // 处理@Import，主要来看看这个 processImports(configClass, sourceClass, getImports(sourceClass), true); // Process any @ImportResource annotations AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); if (importResource != null) { String[] resources = importResource.getStringArray(&quot;locations&quot;); Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;); for (String resource : resources) { String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); configClass.addImportedResource(resolvedResource, readerClass); } } // Process individual @Bean methods Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass); for (MethodMetadata methodMetadata : beanMethods) { configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); } // Process default methods on interfaces processInterfaces(configClass, sourceClass); // Process superclass, if any if (sourceClass.getMetadata().hasSuperClass()) { String superclass = sourceClass.getMetadata().getSuperClassName(); if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) { this.knownSuperclasses.put(superclass, configClass); // Superclass found, return its annotation metadata and recurse return sourceClass.getSuperClass(); } } // No superclass -&gt; processing is complete return null; } 看到其中的@PropertySource、@ComponentScan等，惊不惊喜，意不意外！解析都在这里面了！点进processImports(configClass, sourceClass, getImports(sourceClass), true)去看看： private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) { if (importCandidates.isEmpty()) { return; } if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) { this.problemReporter.error(new CircularImportProblem(configClass, this.importStack)); } else { this.importStack.push(configClass); try { for (SourceClass candidate : importCandidates) { if (candidate.isAssignable(ImportSelector.class)) { // Candidate class is an ImportSelector -&gt; delegate to it to determine imports Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); if (selector instanceof DeferredImportSelector) { this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector); } else { // 调用XXXSelector的selectImports方法，点进去 String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames); processImports(configClass, currentSourceClass, importSourceClasses, false); } } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) { // Candidate class is an ImportBeanDefinitionRegistrar -&gt; // delegate to it to register additional bean definitions Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportBeanDefinitionRegistrar registrar = ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry); configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); } else { // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt; // process it as an @Configuration class this.importStack.registerImport( currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); processConfigurationClass(candidate.asConfigClass(configClass)); } } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to process import candidates for configuration class [&quot; + configClass.getMetadata().getClassName() + &quot;]&quot;, ex); } finally { this.importStack.pop(); } } } 点击进去看看，发现会有很多的XXXSelector，因为我们看的是自动配置，所以呢，选择AutoConfigurationImportSelector#selectImports进去看看。 public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); // 主要来看看这个方法干啥的 AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } 我嘞个去，是不是很熟悉，之前讲解@EnableAutoConfiguration是不是说过，再粘下代码： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { ... } 好了，现在来看看getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata);这个方法干啥的： protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } // 加载自动配置类的元数据信息 AnnotationAttributes attributes = getAttributes(annotationMetadata); // 获取自动配置类的全限定名 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } 点进getCandidateConfigurations(annotationMetadata, attributes)去看看： protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { // 加载自动配置类的全限定类名 List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot; + &quot;are using a custom packaging, make sure that file is correct.&quot;); return configurations; } 点进getSpringFactoriesLoaderFactoryClass()看看： protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() { return EnableAutoConfiguration.class; } 这不就是启动自动配置的注解吗？拿这个干什么呢？回到上一步，点进SpringFactoriesLoader.loadFactoryNames去看看： public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) { String factoryTypeName = factoryType.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList()); } private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) { MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) { return result; } try { Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); while (urls.hasMoreElements()) { URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) { String factoryTypeName = ((String) entry.getKey()).trim(); for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) { result.add(factoryTypeName, factoryImplementationName.trim()); } } } cache.put(classLoader, result); return result; } catch (IOException ex) { throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; + FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex); } } 看到下面的loadSpringFactories方法中有一个FACTORIES_RESOURCE_LOCATION： public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;; 这不就是个文件么，干什么的，来看看： org.springframework.boot.autoconfigure.EnableAutoConfiguration这个KEY下的自动配置不止图片的这点，还有很多，可以点进去看看！看到这里呢，是不是就明白了。这个spring.factories就是用来配置自动配置类的。也就是说，只要在项目的META-INF/spring.factories中配置上自定义的自动配置类，那么Spring Boot启动的时候，就可以给你做自动配置的事情了！回到getAutoConfigurationEntry方法： protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); // 获取自动配置类的全限定类名 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); // 去重复的自动配置类 configurations = removeDuplicates(configurations); // 返回需要排除的自动配置类 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); // 检查需要排除的自动配置是否存在 checkExcludedClasses(configurations, exclusions); // 移出自动配置类 configurations.removeAll(exclusions); // 按照自动配置类上配置的@ConditionalXXX条件进行过滤 // 使用spring.factories文件中org.springframework.boot.autoconfigure.AutoConfigurationImportFilter对应的过滤器进行过滤。有三个过滤器： // org.springframework.boot.autoconfigure.condition.OnBeanCondition // org.springframework.boot.autoconfigure.condition.OnClassCondition // org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition // 分别调用过滤器中match方法过滤出符合条件的自动配置类 configurations = filter(configurations, autoConfigurationMetadata); // 发布自动配置事件 // 使用spring.factories文件中org.springframework.boot.autoconfigure.AutoConfigurationImportListener对应的监听器org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener发送AutoConfigurationImportEvent事件 fireAutoConfigurationImportEvents(configurations, exclusions); // 返回包含已创建和已排除的自动配置实体 return new AutoConfigurationEntry(configurations, exclusions); } 回到processImports方法： private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) { if (importCandidates.isEmpty()) { return; } if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) { this.problemReporter.error(new CircularImportProblem(configClass, this.importStack)); } else { this.importStack.push(configClass); try { for (SourceClass candidate : importCandidates) { if (candidate.isAssignable(ImportSelector.class)) { // Candidate class is an ImportSelector -&gt; delegate to it to determine imports Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); if (selector instanceof DeferredImportSelector) { this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector); } else { String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames); processImports(configClass, currentSourceClass, importSourceClasses, false); } } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) { // Candidate class is an ImportBeanDefinitionRegistrar -&gt; // delegate to it to register additional bean definitions Class&lt;?&gt; candidateClass = candidate.loadClass(); ImportBeanDefinitionRegistrar registrar = ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry); configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); } else { // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt; // process it as an @Configuration class this.importStack.registerImport( currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); processConfigurationClass(candidate.asConfigClass(configClass)); } } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &quot;Failed to process import candidates for configuration class [&quot; + configClass.getMetadata().getClassName() + &quot;]&quot;, ex); } finally { this.importStack.pop(); } } } processImports方法会被递归调用，直到所有的配置类处理完毕。然后在ConfigurationClassPostProcessor#processConfigBeanDefinitions方法中，就会调用this.reader.loadBeanDefinitions(configClasses)注册Bean的定义信息。最后在refresh()方法中调用finishBeanFactoryInitialization(beanFactory)方法实例化Bean。到此自动配置的源码分析就结束啦，最后来一个图总结一下大概流程：","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"Springboot核心注解","slug":"tech-springboot-annotation","date":"2019-10-21T03:00:00.000Z","updated":"2019-10-23T14:33:42.111Z","comments":true,"path":"2019/10/21/tech-springboot-annotation/","link":"","permalink":"/2019/10/21/tech-springboot-annotation/","excerpt":"","text":"在开始介绍Springboot自动配置之前，来看看Springboot有哪些最核心的注解。继续Springboot开胃菜，打开SpringbootWebApplication类后，发现该类上有且只有一个注解@SpringBootApplication，来看看这个是注解所包含的意思：@SpringBootApplication 这是一个便捷的组合注解，使用该注解意味着： 启用配置@SpringBootConfiguration 触发自动配置@EnableAutoConfiguration 组件扫描@ComponentScan 配置属性扫描@ConfigurationPropertiesScan 一个个来看看都是啥意思： @SpringBootConfiguration 用于加载Springboot应用所需要的配置，并且标注当前类是配置类，将配置类中声明的一个或是多个已@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。该注解在Springboot应用中可以使用来替代@Configuration，这样的话，在自动配置的时候，就可以被自动发现了，该注解本身就组合了@Configuration注解。Springboot应用有且只能包含一个@SpringBootConfiguration注解。 @EnableAutoConfiguration 这个是核心中的核心注解啦！使用该注解表示开启自动配置功能，spring应用上下文就会试着去猜测并且配置你所期望的bean。其实就是将所有符合@Conditional注解的配置类加载到Springboot创建的容器中。自动配置类是基于你的classpath和你定义了什么样的bean而被应用。比如说：在你的类路径下有tomcat-embedded.jar，那就意味着你希望有一个TomcatServletWebServerFactory，除非你自己定义了TomcatServletWebServerFactorybean。使用@SpringBootApplication意味着自动配置自动生效，如果有你不需要的配置，可以使用#excludeName()进行排除。自动配置的类通常都是Spring@Configuration的bean，这些bean通过使用SpringFactoriesLoader机制定位。通常自动配置类都是@Conditional的beans(大多数使用@ConditionalOnClass和@ConditionalOnMissingBean注解)。在注解上包含了两个注解： AutoConfigurationPackage 存储自动配置的包，在该包下的bean都会被注册 @Import(AutoConfigurationPackages.Registrar.class) 通过这个注解去存储基础包及注册bean的定义 @Import(AutoConfigurationImportSelector.class) 这就是自动配置的核心啦，所有的自动配置类通过这个导入进来，那么它是在哪里被调用，以及自动配置bean怎么配置进来的，留待后面分析。 @ComponentScan 这个是组件扫描，可以配置组件扫描的基础包以及过滤器，加载符合条件的组件或Bean的定义，最终将这些Bean加载到容器中。Spring框架默认以Springboot启动类所在的包为basePackage进行扫描，当然也可以通过basePackage等属性自定义扫描范围。 @ConfigurationPropertiesScan 指定扫描@ConfigurationProperties类的基础包 @Import(ConfigurationPropertiesScanRegistrar.class) 通过扫描使用ImportBeanDefinitionRegistrar注册@ConfigurationPropertiebean定义 @EnableConfigurationProperties 对带有@ConfigurationProperties注解的bean都可以使用标准的方式被注册，比如说使用@Bean方式 @Import(EnableConfigurationPropertiesRegistrar.class) 对带有@EnableConfigurationProperties的类使用ImportBeanDefinitionRegistrar进行注册 这些注解在项目里都可以点进去看看，熟悉一下，对自动配置的解析有帮助，要不然会感到有点懵！最后，我们再用一个图来总结下，标红的是核心中的核心，需要重点关注的地方：","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"Springboot开胃菜","slug":"tech-springboot-introduction","date":"2019-10-19T07:00:00.000Z","updated":"2019-10-22T15:09:53.027Z","comments":true,"path":"2019/10/19/tech-springboot-introduction/","link":"","permalink":"/2019/10/19/tech-springboot-introduction/","excerpt":"","text":"我们在学习某一知识之前，总得清楚它是干什么的（What），怎么干（How），为什么这么干（Why），对它发出来自灵魂的三拷问。来看看官网介绍： 一、Introducing Spring BootSpring Boot makes it easy to create stand-alone, production-grade Spring-based Applications that you can run. We take an opinionated view of the Spring platform and third-party libraries, so that you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. You can use Spring Boot to create Java applications that can be started by using java -jar or more traditional war deployments. We also provide a command line tool that runs “spring scripts”. Our primary goals are: Provide a radically faster and widely accessible getting-started experience for all Spring development. Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults. Provide a range of non-functional features that are common to large classes of projects (such as embedded servers, security, metrics, health checks, and externalized configuration). Absolutely no code generation and no requirement for XML configuration. 明白没？不明白？那我就用我这三级都没过的英语水平简单的翻译下： Spring boot 使得创建以及运行基于单机版或生产级别得spring应用变得很简单。我们提出了spring平台和第三库的观点，使得你可以以最小得代价去开始干你想干得事情。而且对于大部分Spring Boot应用程序仅仅需要很少的配置就可以运行。 你可以使用Spring Boot去创建Java引用，并且以java -jar或是传统部署war包的方式运行。我们也提供了在命令行以&quot;spring scripts&quot;的方式运行 我们的重要目标是： 对于所有的Spring开发从根本上提供一个更快速且可广泛地容易访问的入门体验 开箱即用 给一系列大型项目提供通用的非功能性特性（例如嵌入式服务器、安全性、指标、运行状况检查和外部化配置） 绝对的无需代码生成和XML配置 还没明白？自行Google去吧！！！下面可以不用翻译了。 二、System RequirementsSpring Boot 2.2.0.RELEASE requires Java 8 and is compatible up to Java 13 (included). Spring Framework 5.2.0.RELEASE or above is also required. Explicit build support is provided for the following build tools: Build Tool Version Maven 3.3+ Gradle 5.x (4.10 is also supported but in a deprecated form) Spring Boot supports the following embedded servlet containers: Name Servlet Version Tomcat 9.0 4.0 Jetty 9.4 3.1 Undertow 2.0 4.0 You can also deploy Spring Boot applications to any Servlet 3.1+ compatible container. 三、Installing Spring Boot1、Installation Instructions for the Java Developer对于开发者来说的话，主要有下面两种方式：a、Maven Installation使用maven前，需要先配置好maven的环境。典型的说，你的Maven POM文件会继承spring-boot-starter-parent project并且会声明一个或者多个starters。一个典型的pom.xml文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; b、Gradle InstallationGradle没用过，自行看文档吧！ 1、Installing the Spring Boot CLIThe Spring Boot CLI (Command Line Interface) is a command line tool that you can use to quickly prototype with Spring. It lets you run Groovy scripts, which means that you have a familiar Java-like syntax without so much boilerplate code. You do not need to use the CLI to work with Spring Boot, but it is definitely the quickest way to get a Spring application off the ground. Spring Boot CLI 是一个命令行工具，在我们使用Spring Boot的工作中并不需要使用CLI。 四、Developing Your First Spring Boot ApplicationThis section describes how to develop a simple “Hello World!” web application that highlights some of Spring Boot’s key features. We use Maven to build this project, since most IDEs support it.这个部分演示怎么使用maven部署一个简单的&quot;Hello World&quot;web应用，大部分IDEs都支持使用maven Before we begin, open a terminal and run the following commands to ensure that you have valid versions of Java and Maven installed:开始之前要确认Java和Maven已安装好 $ java -version java version &quot;1.8.0_102&quot; Java(TM) SE Runtime Environment (build 1.8.0_102-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode) $ mvn -v Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-17T14:33:14-04:00) Maven home: /usr/local/Cellar/maven/3.3.9/libexec Java version: 1.8.0_102, vendor: Oracle Corporation This sample needs to be created in its own folder. Subsequent instructions assume that you have created a suitable folder and that it is your current directory.也就是说，需要创建一个文件夹，并且当前的路径是在你创建的文件下 1、Creating the POMWe need to start by creating a Maven pom.xml file. The pom.xml is the recipe that is used to build your project. Open your favorite text editor and add the following:使用喜爱的编辑工具创建一个pom.xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Additional lines to be added here... --&gt; &lt;/project&gt; 2、Adding Classpath DependenciesSpring Boot提供了很多的”Starters”，让你可以把jars添加到classpath下。我们在POM中的parent部分添加了spring-boot-starter-parent，spring-boot-starter-parent是一个特殊的starter，它提供了dependency-management，因此我们在依赖中可以踢出version标签。这个地方我们以添加spring-boot-starter-web为列： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、Writing the CodeTo finish our application, we need to create a single Java file. By default, Maven compiles sources from src/main/java, so you need to create that folder structure and then add a file named src/main/java/Example.java to contain the following code:maven默认是在src/main/java/下编译源文件的，因此需要将Example.java类文件添加到src/main/java/目录下 import org.springframework.boot.*; import org.springframework.boot.autoconfigure.*; import org.springframework.web.bind.annotation.*; @RestController @EnableAutoConfiguration public class Example { @RequestMapping(&quot;/&quot;) String home() { return &quot;Hello World!&quot;; } public static void main(String[] args) { SpringApplication.run(Example.class, args); } } @RestController和@RequestMapping是SpringMVC的注解！@EnableAutoConfiguration这是一个对于Spring Boot来说，很核心的一个注解，我们后面再说。 4、Running the ExampleAt this point, your application should work. Since you used the spring-boot-starter-parent POM, you have a useful run goal that you can use to start the application. Type mvn spring-boot:run from the root project directory to start the application. You should see output similar to the following:在项目根目录执行mvn spring-boot:run，就可以看到输出日志 $ mvn spring-boot:run . ____ _ __ _ _ /\\\\ / ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) ....... . . . ....... . . . (log output here) ....... . . . ........ Started Example in 2.222 seconds (JVM running for 6.514) If you open a web browser to localhost:8080, you should see the following output: Hello World! To gracefully exit the application, press ctrl-c。 5、Creating an Executable JarTo create an executable jar, we need to add the spring-boot-maven-plugin to our pom.xml. To do so, insert the following lines just below the dependencies section:在pom文件中添加如下依赖 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; Notice：The spring-boot-starter-parent POM includes &lt;executions&gt;configuration to bind the repackage goal. If you do not use the parent POM, you need to declare this configuration yourself. See the plugin documentation for details.spring-boot-starter-parent包含了&lt;executions&gt;并且绑定了repackage构建，因此我们直接加上上面的依赖就可以了。如果你没有使用parent Pom的话呢，就需要自己声明构建配置了 Save your pom.xml and run mvn package from the command line, as follows: $ mvn package [INFO] Scanning for projects... [INFO] [INFO] ------------------------------------------------------------------------ [INFO] Building myproject 0.0.1-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO] .... .. [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject --- [INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar [INFO] [INFO] --- spring-boot-maven-plugin:2.2.0.RELEASE:repackage (default) @ myproject --- [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ If you look in the target directory, you should see myproject-0.0.1-SNAPSHOT.jar. The file should be around 10 MB in size. If you want to peek inside, you can use jar tvf, as follows:在target目录中可以看到myproject-0.0.1-SNAPSHOT.jar文件，使用jar tvf可以查看文件内部的详细信息 $ jar tvf target/myproject-0.0.1-SNAPSHOT.jar You should also see a much smaller file named myproject-0.0.1-SNAPSHOT.jar.original in the target directory. This is the original jar file that Maven created before it was repackaged by Spring Boot.在target目录中还可以看到一个myproject-0.0.1-SNAPSHOT.jar.original文件，它是maven在使用Spring Boot打包之前创建的jar源文件 To run that application, use the java -jar command, as follows: $ java -jar target/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\\\ / ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) ....... . . . ....... . . . (log output here) ....... . . . ........ Started Example in 2.536 seconds (JVM running for 2.864) As before, to exit the application, press ctrl-c. 到此为止呢，Spring Boot的灵魂三问已经清楚了。但是发现一个问题，手动去写POM，然后创建类文件，这么简单工程还好，那么复杂的工程的呢，这个过程就很痛苦了啊。那么我们来看看使用工具怎么创建Spring Boot工程，这里使用Idea为例，其他的IDEs类似，就不用说了哈！ 五、Develop Spring Boot Aplication With IDEA1、初始化Spring Boot项目打开Idea，左上角依次：file -&gt; new -&gt; project在弹出框中左侧菜单中选择Spring Initializr后，在右侧配置SDK版本，下面选择Default就行了，然后next配置project，然后next选择需要整合的web中间件，这里有很多的中间可选，可以都看看，后面将要介绍的一些中间件也在里面（如：eureka），然后next配置项目存储路径，Finish后，来看下目录结构：到这里，你就可以直接启动了： . ____ _ __ _ _ /\\\\ / ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) 2019-10-19 17:27:49.228 INFO 33267 --- [ main] c.s.s.SpringbootWebApplication : Starting SpringbootWebApplication on bogon with PID 33267 (/Users/dingzhongshen/SelfProjects/springblog/springboot-web/target/classes started by dingzhongshen in /Users/dingzhongshen/SelfProjects/springblog/springboot-web) 2019-10-19 17:27:49.232 INFO 33267 --- [ main] c.s.s.SpringbootWebApplication : No active profile set, falling back to default profiles: default 2019-10-19 17:27:50.389 INFO 33267 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 2019-10-19 17:27:50.398 INFO 33267 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2019-10-19 17:27:50.399 INFO 33267 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.27] 2019-10-19 17:27:50.469 INFO 33267 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2019-10-19 17:27:50.469 INFO 33267 --- [ main] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1150 ms 2019-10-19 17:27:50.631 INFO 33267 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService &#39;applicationTaskExecutor&#39; 2019-10-19 17:27:50.816 INFO 33267 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &#39;&#39; 2019-10-19 17:27:50.819 INFO 33267 --- [ main] c.s.s.SpringbootWebApplication : Started SpringbootWebApplication in 2.547 seconds (JVM running for 5.328) 看到上面日志Tomcat started on port(s): 8080，就表示Spring Boot项目已经初始化并启动成功了。是不是很简单，开箱即用嘛！！！当然啦，我们要做的事情，可不止这么多，接下来写个Controller试试。 2、配置Spring Boot在resources目录下，有个application.properties文件，我喜欢改成application.yml。然后就可以在这个文件中配置需要的属性啦，比如将服务端口号改成8081： server: port: 8081 启动应用之后，就可以在日志里看到端口被改成： o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8081 (http) with context path &#39;&#39; context path也是可以进行配置的。在使用spring boot的时候，需要集成一些其他的中间件，它们的属性都配置在这里，那他们有什么样的属性，怎么看呢？别急，后面介绍！ 3、编写逻辑，加入相应的启动注解启动之后，在浏览器流输入http://localhost:8080/，就可以看到效果啦，是不是很酷： Hello World! Bingo！！！恭喜你，已经初步掌握Spring Boot啦！上面已经包含了springboot整合中间件的过程，不知道你发现没，没有？不急，后面再说！现在你就只需要知道，使用Spring Boot无非就这么 三板斧 就行了！","categories":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"}],"keywords":[{"name":"tech","slug":"tech","permalink":"/categories/tech/"}]},{"title":"博客首篇","slug":"thought-introduction","date":"2019-10-18T10:08:08.000Z","updated":"2019-10-31T14:15:16.063Z","comments":true,"path":"2019/10/18/thought-introduction/","link":"","permalink":"/2019/10/18/thought-introduction/","excerpt":"","text":"前因那是在很久很久以前，总觉得写博客很浪费时间（其实现在也这么觉得，哈哈哈），不需要去写博客，有什么问题或是需要学习什么知识，直接官网或是Google或是度娘不就行了吗，来得多快呢。也总相信自己能够记住自己学习的东西，不需要去记笔记。然后呢，每次学习知识或是遇到问题都去官网或是Google或是度娘，乐此不疲。其实这是一个严重的问题，自己却不以为意或是没有察觉。但是，时间一长，这个问题就会逐渐暴露出来：学习的东西有自己的理解和感悟，但是没有总结出来，很零散，没有自己的知识结构，形成不了自己的知识体系！因为越往后，自己就会觉得自己怎么突然什么都不会了，怎么什么都想不起来了，知识更新迭代那么快，自己怎么跟不上了呢（也许有那么一部分凤毛棱角的人不会这么觉得）？学习的东西，在工作中并不是都会用到，不做笔记，总会有忘记的时候，好记性不如烂笔头（祖先的智慧结晶）。理解的东西或是会的东西忘记了怎么办呢？官网或是Google或是度娘再来几遍？如此往复吗？记不住又不喜欢花点时间总结成自己的东西记下来，越往后，不觉得自己相比与其他人来说，学习新东西的时候越来越慢了吗，不会觉得自己跟不上知识的更新迭代了吗？能找回来最好，但是每次都会花费比较多的时间，可能就要落后咯。一时的感悟或是理解可能就找不回来咯！所以呢，还是要记记笔记滴，杂七杂八的记呗！ 经过先前也看过一些博客，不是很简洁，总会有很多除了博客内容之外的其他的一些东西（不举例了哈），想着自己去搞一个，不过对于只会后端的我来说，挑战性是何其大。然后发现了Hexo和Hugo，两者我选择了Hexo，可能是主题比较多吧（哈哈哈）。正好那段时间正在学习Python，那干脆前端用Hexo的主题（我把Hexo的页面给摘出来了，费着劲自己干），然后后端用Python的web框架Django，DB用MongoDB。然后就开干了，正当快把网站搞好的时候，我就去某大厂了，后面就没有时间再搞。 直到最近总想着把之前的博客搞起来。是选择之前自己搞的网站呢，还是直接使用Hexo搭建呢？从时间就是金钱的角度，我先选择直接使用Hexo搭建起来，后续再做打算也不迟。于是呢，就有了现在的多多博客。 结果通过这个博客，壮着胆子把常用的一些主流框架的学习总结起来，形成自己的知识结构体系。与此同时也可以记录自己生活的点点滴滴，反正就是杂七杂八的呗！ 首次写博客，心里“激动”，难免有错，大家勿怪！！！","categories":[{"name":"thought","slug":"thought","permalink":"/categories/thought/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"}],"keywords":[{"name":"thought","slug":"thought","permalink":"/categories/thought/"}]}]}